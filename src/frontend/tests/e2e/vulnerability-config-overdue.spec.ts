/**
 * E2E Test: Vulnerability Configuration & Overdue Status
 *
 * Tests the vulnerability overdue tracking and exception workflows added in Feature 021:
 * 1. Admin can configure "Reminder One" threshold
 * 2. Overdue status badges appear on vulnerabilities
 * 3. Exception suppresses overdue status
 * 4. Asset-based exceptions work
 * 5. Product-based exceptions with autocomplete work
 * 6. Impact preview shows correct information
 *
 * Related to: Feature 021-vulnerability-overdue-exception-logic
 */

import { test, expect } from '@playwright/test';

test.describe('Vulnerability Configuration - Admin', () => {
    test.beforeEach(async ({ page }) => {
        // Login as admin
        await page.goto('/login');
        await page.fill('input[name="username"]', 'admin');
        await page.fill('input[name="password"]', 'admin');
        await page.click('button[type="submit"]');
        await page.waitForURL('/');
    });

    test('navigate to vulnerability config page', async ({ page }) => {
        // Navigate to admin page
        await page.goto('/admin');
        await expect(page.locator('h1:has-text("Admin")')).toBeVisible();

        // Click on Vulnerability Settings card
        await page.click('text=Vulnerability Settings');
        await page.waitForURL('/admin/vulnerability-config');

        // Verify page loaded with tabs
        await expect(page.locator('#vulnConfigTabs')).toBeVisible();
        await expect(page.locator('#settings-tab')).toBeVisible();
        await expect(page.locator('#exceptions-tab')).toBeVisible();
    });

    test('view and update reminder one threshold', async ({ page }) => {
        await page.goto('/admin/vulnerability-config');

        // Ensure we're on Settings tab
        await page.click('#settings-tab');
        await expect(page.locator('#settings')).toBeVisible();

        // Find the Reminder One input
        const reminderInput = page.locator('input#reminderOneDays');
        await expect(reminderInput).toBeVisible();

        // Get current value
        const currentValue = await reminderInput.inputValue();
        console.log('Current Reminder One:', currentValue);

        // Change to a different value
        const newValue = '45';
        await reminderInput.fill(newValue);

        // Verify Save button is enabled
        const saveButton = page.locator('button:has-text("Save Configuration")');
        await expect(saveButton).toBeEnabled();

        // Click Save
        await saveButton.click();

        // Wait for success message
        await expect(page.locator('.alert-success')).toBeVisible({ timeout: 5000 });
        await expect(page.locator('text=Configuration saved successfully')).toBeVisible();

        // Verify value persisted
        await expect(reminderInput).toHaveValue(newValue);

        // Verify last updated info appears
        await expect(page.locator('text=Last updated by')).toBeVisible();
    });

    test('validation for extreme threshold values', async ({ page }) => {
        await page.goto('/admin/vulnerability-config');
        await page.click('#settings-tab');

        const reminderInput = page.locator('input#reminderOneDays');

        // Test value too low
        await reminderInput.fill('0');
        await expect(page.locator('.alert-warning, text=very short threshold')).toBeVisible();

        // Test value too high
        await reminderInput.fill('400');
        const saveButton = page.locator('button:has-text("Save Configuration")');
        await saveButton.click();
        await expect(page.locator('.alert-danger, text=Invalid configuration')).toBeVisible();

        // Test valid value
        await reminderInput.fill('30');
        await saveButton.click();
        await expect(page.locator('.alert-success')).toBeVisible({ timeout: 5000 });
    });

    test('reset button restores original value', async ({ page }) => {
        await page.goto('/admin/vulnerability-config');
        await page.click('#settings-tab');

        const reminderInput = page.locator('input#reminderOneDays');
        const originalValue = await reminderInput.inputValue();

        // Change value
        await reminderInput.fill('60');

        // Click Reset
        await page.click('button:has-text("Reset")');

        // Verify value restored
        await expect(reminderInput).toHaveValue(originalValue);
    });
});

test.describe('Vulnerability Overdue Status Display', () => {
    test.beforeEach(async ({ page }) => {
        // Login as regular user
        await page.goto('/login');
        await page.fill('input[name="username"]', 'admin');
        await page.fill('input[name="password"]', 'admin');
        await page.click('button[type="submit"]');
        await page.waitForURL('/');

        // Navigate to current vulnerabilities
        await page.goto('/vulnerabilities/current');
    });

    test('overdue status badges are visible', async ({ page }) => {
        // Wait for table to load
        await expect(page.locator('table')).toBeVisible({ timeout: 10000 });

        // Check if Overdue Status column exists
        await expect(page.locator('th:has-text("Overdue Status")')).toBeVisible();

        // Verify at least one badge is visible
        const badges = page.locator('.badge').filter({ hasText: /OK|OVERDUE|EXCEPTED/ });
        await expect(badges.first()).toBeVisible({ timeout: 5000 });
    });

    test('hover tooltips show detailed information', async ({ page }) => {
        await expect(page.locator('table')).toBeVisible({ timeout: 10000 });

        // Find a badge
        const badge = page.locator('.badge').filter({ hasText: /OK|OVERDUE|EXCEPTED/ }).first();
        
        if (await badge.isVisible()) {
            // Hover over badge
            await badge.hover();

            // Tooltip should appear (implementation-dependent)
            // This might need adjustment based on actual tooltip implementation
            await page.waitForTimeout(500);
        }
    });

    test('filter vulnerabilities by overdue status', async ({ page }) => {
        // Wait for filters to load
        await page.waitForSelector('select#overdueFilter, select[name="overdueStatus"]', { timeout: 5000 });

        // Try to find the overdue filter dropdown
        const overdueFilter = page.locator('select').filter({ hasText: /OK|OVERDUE|All/ }).first();
        
        if (await overdueFilter.isVisible()) {
            // Select OVERDUE only
            await overdueFilter.selectOption({ label: 'OVERDUE' });

            // Wait for table to update
            await page.waitForTimeout(1000);

            // Verify only OVERDUE badges are visible
            const badges = page.locator('.badge').filter({ hasText: 'OVERDUE' });
            const okBadges = page.locator('.badge').filter({ hasText: 'OK' });

            if (await badges.count() > 0) {
                expect(await badges.count()).toBeGreaterThan(0);
            }
        }
    });

    test('sort vulnerabilities by overdue status', async ({ page }) => {
        await expect(page.locator('table')).toBeVisible({ timeout: 10000 });

        // Find Overdue Status column header
        const overdueHeader = page.locator('th').filter({ hasText: 'Overdue Status' }).first();

        if (await overdueHeader.isVisible()) {
            // Click to sort
            await overdueHeader.click();
            await page.waitForTimeout(500);

            // Click again to reverse sort
            await overdueHeader.click();
            await page.waitForTimeout(500);

            // Verify sort icons appear
            const sortIcon = overdueHeader.locator('i.bi-chevron-up, i.bi-chevron-down');
            await expect(sortIcon).toBeVisible();
        }
    });
});

test.describe('Exception Management with Overdue Suppression', () => {
    test.beforeEach(async ({ page }) => {
        // Login as admin
        await page.goto('/login');
        await page.fill('input[name="username"]', 'admin');
        await page.fill('input[name="password"]', 'admin');
        await page.click('button[type="submit"]');
        await page.waitForURL('/');

        // Navigate to exception management via admin config
        await page.goto('/admin/vulnerability-config');
        await page.click('#exceptions-tab');
        await expect(page.locator('#exceptions')).toBeVisible();
    });

    test('create IP exception and verify affected count', async ({ page }) => {
        // Click Create Exception
        await page.click('button:has-text("Create Exception")');

        // Wait for modal
        await expect(page.locator('.modal.show')).toBeVisible();

        // Select IP type
        const typeRadio = page.locator('input[type="radio"][value="IP"]');
        await typeRadio.check();

        // Fill target value
        await page.fill('input#targetValue, input[name="targetValue"]', '192.168.1.100');

        // Set expiration date (30 days from now)
        const futureDate = new Date();
        futureDate.setDate(futureDate.getDate() + 30);
        const dateString = futureDate.toISOString().slice(0, 16);
        await page.fill('input[type="datetime-local"]', dateString);

        // Fill reason
        await page.fill('textarea', 'Test exception for E2E test');

        // Submit
        await page.click('button:has-text("Create"), button:has-text("Preview & Create")');

        // If preview modal appears, confirm
        const confirmButton = page.locator('button:has-text("Confirm")');
        if (await confirmButton.isVisible({ timeout: 2000 })) {
            await confirmButton.click();
        }

        // Wait for modal to close
        await expect(page.locator('.modal.show')).not.toBeVisible({ timeout: 5000 });

        // Verify exception in table
        await expect(page.locator('text=192.168.1.100')).toBeVisible();

        // Look for affected count (if displayed)
        const affectedCell = page.locator('tr:has-text("192.168.1.100")').locator('td').filter({ hasText: /\d+ vuln/ });
        if (await affectedCell.isVisible()) {
            console.log('Affected count displayed:', await affectedCell.textContent());
        }
    });

    test('create ASSET exception using selector', async ({ page }) => {
        await page.click('button:has-text("Create Exception")');
        await expect(page.locator('.modal.show')).toBeVisible();

        // Select ASSET type
        const assetRadio = page.locator('input[type="radio"][value="ASSET"]');
        if (await assetRadio.isVisible({ timeout: 2000 })) {
            await assetRadio.check();

            // Wait for asset selector to load
            await page.waitForTimeout(500);

            // Select an asset from dropdown
            const assetSelect = page.locator('select').filter({ hasText: /.+/ }).first();
            if (await assetSelect.isVisible()) {
                const options = await assetSelect.locator('option').count();
                if (options > 1) { // More than just placeholder
                    await assetSelect.selectOption({ index: 1 });

                    // Set expiration date
                    const futureDate = new Date();
                    futureDate.setDate(futureDate.getDate() + 30);
                    const dateString = futureDate.toISOString().slice(0, 16);
                    await page.fill('input[type="datetime-local"]', dateString);

                    // Fill reason
                    await page.fill('textarea', 'Asset exception test');

                    // Submit
                    await page.click('button:has-text("Create"), button:has-text("Preview & Create")');

                    // Handle preview if it appears
                    const confirmButton = page.locator('button:has-text("Confirm")');
                    if (await confirmButton.isVisible({ timeout: 2000 })) {
                        await confirmButton.click();
                    }

                    // Verify success
                    await expect(page.locator('.modal.show')).not.toBeVisible({ timeout: 5000 });
                }
            }
        }
    });

    test('create PRODUCT exception with autocomplete', async ({ page }) => {
        await page.click('button:has-text("Create Exception")');
        await expect(page.locator('.modal.show')).toBeVisible();

        // Select PRODUCT type
        const productRadio = page.locator('input[type="radio"][value="PRODUCT"]');
        await productRadio.check();

        // Wait for autocomplete to initialize
        await page.waitForTimeout(500);

        // Type in product field to trigger autocomplete
        const productInput = page.locator('input[placeholder*="product"], input[name="targetValue"]');
        await productInput.fill('OpenSSH');

        // Wait for suggestions
        await page.waitForTimeout(500);

        // Check if dropdown with suggestions appears
        const suggestions = page.locator('.dropdown-menu, .autocomplete-suggestions');
        if (await suggestions.isVisible({ timeout: 1000 })) {
            // Click first suggestion
            await suggestions.locator('button, a, li').first().click();
        }

        // Set expiration date
        const futureDate = new Date();
        futureDate.setDate(futureDate.getDate() + 30);
        const dateString = futureDate.toISOString().slice(0, 16);
        await page.fill('input[type="datetime-local"]', dateString);

        // Fill reason
        await page.fill('textarea', 'Product exception with autocomplete');

        // Click Preview & Create
        await page.click('button:has-text("Preview & Create")');

        // Impact preview modal should appear
        const previewModal = page.locator('.modal').filter({ hasText: /Impact Preview|Affected/ });
        if (await previewModal.isVisible({ timeout: 3000 })) {
            // Verify preview content
            await expect(previewModal.locator('text=Total Affected')).toBeVisible();
            await expect(previewModal.locator('text=Severity Breakdown')).toBeVisible();

            // Confirm creation
            await previewModal.locator('button:has-text("Confirm")').click();
        }

        // Verify modal closed and exception created
        await expect(page.locator('.modal.show')).not.toBeVisible({ timeout: 5000 });
    });

    test('edit existing exception', async ({ page }) => {
        // First, ensure at least one exception exists
        const exceptionRows = page.locator('tbody tr');
        const count = await exceptionRows.count();

        if (count > 0) {
            // Click edit button on first exception
            const editButton = exceptionRows.first().locator('button[title="Edit exception"], button:has(i.bi-pencil)');
            await editButton.click();

            // Modal should open with pre-filled values
            await expect(page.locator('.modal.show')).toBeVisible();
            await expect(page.locator('.modal-title:has-text("Edit")')).toBeVisible();

            // Change reason
            const reasonTextarea = page.locator('textarea');
            await reasonTextarea.fill('Updated reason for E2E test');

            // Change expiration date
            const futureDate = new Date();
            futureDate.setDate(futureDate.getDate() + 60);
            const dateString = futureDate.toISOString().slice(0, 16);
            await page.fill('input[type="datetime-local"]', dateString);

            // Save
            await page.click('button:has-text("Save"), button:has-text("Update")');

            // Verify modal closed
            await expect(page.locator('.modal.show')).not.toBeVisible({ timeout: 5000 });

            // Verify updated reason appears in table
            await expect(page.locator('text=Updated reason')).toBeVisible();
        }
    });

    test('delete exception with confirmation', async ({ page }) => {
        // First, create a test exception to delete
        await page.click('button:has-text("Create Exception")');
        await expect(page.locator('.modal.show')).toBeVisible();

        const typeRadio = page.locator('input[type="radio"][value="IP"]');
        await typeRadio.check();
        await page.fill('input#targetValue, input[name="targetValue"]', '10.0.0.99');

        const futureDate = new Date();
        futureDate.setDate(futureDate.getDate() + 30);
        const dateString = futureDate.toISOString().slice(0, 16);
        await page.fill('input[type="datetime-local"]', dateString);
        await page.fill('textarea', 'Exception to be deleted');

        await page.click('button:has-text("Create")');

        // Handle preview if it appears
        const confirmButton = page.locator('button:has-text("Confirm")');
        if (await confirmButton.isVisible({ timeout: 2000 })) {
            await confirmButton.click();
        }

        await expect(page.locator('.modal.show')).not.toBeVisible({ timeout: 5000 });

        // Now delete it
        const testRow = page.locator('tr:has-text("10.0.0.99")');
        const deleteButton = testRow.locator('button[title="Delete exception"], button:has(i.bi-trash)');
        
        // Set up dialog handler for confirmation
        page.once('dialog', dialog => {
            console.log('Dialog message:', dialog.message());
            dialog.accept();
        });

        await deleteButton.click();

        // Wait a bit for deletion to process
        await page.waitForTimeout(1000);

        // Verify exception removed from table
        await expect(page.locator('tr:has-text("10.0.0.99")')).not.toBeVisible({ timeout: 3000 });
    });
});

test.describe('Role-Based Access Control', () => {
    test('non-admin cannot access config page', async ({ page }) => {
        // This test would require a non-admin user
        // Skipping if not available
        test.skip(true, 'Requires non-admin test user');
    });

    test('admin can access all features', async ({ page }) => {
        // Login as admin
        await page.goto('/login');
        await page.fill('input[name="username"]', 'admin');
        await page.fill('input[name="password"]', 'admin');
        await page.click('button[type="submit"]');
        await page.waitForURL('/');

        // Verify admin can access config
        await page.goto('/admin/vulnerability-config');
        await expect(page.locator('h2:has-text("Vulnerability Settings")')).toBeVisible();

        // Verify admin can access both tabs
        await page.click('#settings-tab');
        await expect(page.locator('#settings')).toBeVisible();

        await page.click('#exceptions-tab');
        await expect(page.locator('#exceptions')).toBeVisible();

        // Verify admin can create exceptions
        await page.click('button:has-text("Create Exception")');
        await expect(page.locator('.modal.show')).toBeVisible();
    });
});

test.describe('Exception Expiration Handling', () => {
    test.beforeEach(async ({ page }) => {
        await page.goto('/login');
        await page.fill('input[name="username"]', 'admin');
        await page.fill('input[name="password"]', 'admin');
        await page.click('button[type="submit"]');
        await page.waitForURL('/');
        await page.goto('/admin/vulnerability-config');
        await page.click('#exceptions-tab');
    });

    test('expired exceptions show expired badge', async ({ page }) => {
        // Look for exceptions in the table
        const expiredBadges = page.locator('.badge.bg-danger').filter({ hasText: 'Expired' });
        
        // If there are any expired exceptions, verify they're marked
        const count = await expiredBadges.count();
        console.log('Found expired exceptions:', count);

        // This test passes if we can query for expired badges
        // (actual presence depends on test data)
    });

    test('active exceptions show active badge', async ({ page }) => {
        const activeBadges = page.locator('.badge.bg-success').filter({ hasText: 'Active' });
        const count = await activeBadges.count();
        console.log('Found active exceptions:', count);
    });
});
