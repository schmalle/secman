/**
 * Vulnerability Export Utility
 *
 * Client-side Excel generation for CrowdStrike vulnerability data using exceljs
 *
 * Features:
 * - Generates Excel workbook with vulnerability data
 * - Formatted headers with severity-based coloring
 * - Summary sheet with statistics
 * - Auto-fit column widths
 *
 * Related to: CrowdStrike Vulnerability Lookup feature
 */

import ExcelJS from 'exceljs';
import type { CrowdStrikeVulnerabilityDto } from '../services/crowdstrikeService';

export interface VulnerabilityExportOptions {
    hostname: string;
    instanceId?: string | null;
    queriedAt: string;
}

/**
 * Export vulnerabilities to Excel file
 *
 * @param vulnerabilities List of vulnerabilities to export
 * @param options Export options including hostname and query timestamp
 * @returns Promise that resolves when file is generated and downloaded
 */
export async function exportVulnerabilitiesToExcel(
    vulnerabilities: CrowdStrikeVulnerabilityDto[],
    options: VulnerabilityExportOptions
): Promise<void> {
    const workbook = new ExcelJS.Workbook();

    // Set workbook properties
    workbook.creator = 'Secman';
    workbook.created = new Date();
    workbook.modified = new Date();
    workbook.lastModifiedBy = 'Secman';

    // Create summary sheet
    const summarySheet = workbook.addWorksheet('Summary');

    // Add summary information
    summarySheet.columns = [
        { header: 'Property', key: 'property', width: 25 },
        { header: 'Value', key: 'value', width: 50 },
    ];

    // Calculate severity counts
    const severityCounts = vulnerabilities.reduce((acc, vuln) => {
        const severity = vuln.severity || 'Unknown';
        acc[severity] = (acc[severity] || 0) + 1;
        return acc;
    }, {} as Record<string, number>);

    // Calculate exception counts
    const exceptedCount = vulnerabilities.filter(v => v.hasException).length;
    const notExceptedCount = vulnerabilities.length - exceptedCount;

    const summaryRows = [
        { property: 'Export Date', value: new Date().toLocaleString() },
        { property: 'Query Timestamp', value: new Date(options.queriedAt).toLocaleString() },
        { property: '', value: '' },
        { property: 'System Information', value: '' },
        { property: '  Hostname', value: options.hostname },
    ];

    if (options.instanceId) {
        summaryRows.push({ property: '  Instance ID', value: options.instanceId });
    }

    summaryRows.push(
        { property: '', value: '' },
        { property: 'Vulnerability Summary', value: '' },
        { property: '  Total Vulnerabilities', value: String(vulnerabilities.length) },
        { property: '', value: '' },
        { property: 'By Severity', value: '' },
        { property: '  Critical', value: String(severityCounts['Critical'] || 0) },
        { property: '  High', value: String(severityCounts['High'] || 0) },
        { property: '  Medium', value: String(severityCounts['Medium'] || 0) },
        { property: '  Low', value: String(severityCounts['Low'] || 0) },
        { property: '  Informational', value: String(severityCounts['Informational'] || 0) },
        { property: '', value: '' },
        { property: 'By Exception Status', value: '' },
        { property: '  Excepted', value: String(exceptedCount) },
        { property: '  Not Excepted', value: String(notExceptedCount) },
    );

    summarySheet.addRows(summaryRows);

    // Style summary sheet
    summarySheet.getRow(1).font = { bold: true, size: 12 };
    summarySheet.getRow(1).fill = {
        type: 'pattern',
        pattern: 'solid',
        fgColor: { argb: 'FF4472C4' },
    };
    summarySheet.getRow(1).font = { ...summarySheet.getRow(1).font, color: { argb: 'FFFFFFFF' } };

    // Create vulnerabilities sheet
    const vulnSheet = workbook.addWorksheet('Vulnerabilities');
    vulnSheet.columns = [
        { header: 'CVE ID', key: 'cveId', width: 18 },
        { header: 'Severity', key: 'severity', width: 12 },
        { header: 'CVSS Score', key: 'cvssScore', width: 12 },
        { header: 'Affected Product', key: 'affectedProduct', width: 40 },
        { header: 'Days Open', key: 'daysOpen', width: 12 },
        { header: 'Detected At', key: 'detectedAt', width: 20 },
        { header: 'Status', key: 'status', width: 10 },
        { header: 'Exception', key: 'hasException', width: 12 },
        { header: 'Exception Reason', key: 'exceptionReason', width: 30 },
        { header: 'Hostname', key: 'hostname', width: 25 },
        { header: 'IP Address', key: 'ip', width: 15 },
    ];

    // Add vulnerability rows
    vulnerabilities.forEach((vuln) => {
        const row = vulnSheet.addRow({
            cveId: vuln.cveId || '-',
            severity: vuln.severity,
            cvssScore: vuln.cvssScore ?? '-',
            affectedProduct: vuln.affectedProduct || '-',
            daysOpen: vuln.daysOpen || '-',
            detectedAt: vuln.detectedAt ? new Date(vuln.detectedAt).toLocaleString() : '-',
            status: vuln.status || 'open',
            hasException: vuln.hasException ? 'Yes' : 'No',
            exceptionReason: vuln.exceptionReason || '-',
            hostname: vuln.hostname || options.hostname,
            ip: vuln.ip || '-',
        });

        // Color-code severity cells
        const severityCell = row.getCell('severity');
        const severityColor = getSeverityColor(vuln.severity);
        if (severityColor) {
            severityCell.fill = {
                type: 'pattern',
                pattern: 'solid',
                fgColor: { argb: severityColor.bg },
            };
            severityCell.font = { color: { argb: severityColor.text }, bold: true };
        }

        // Color-code exception cells
        const exceptionCell = row.getCell('hasException');
        if (vuln.hasException) {
            exceptionCell.fill = {
                type: 'pattern',
                pattern: 'solid',
                fgColor: { argb: 'FF198754' }, // Green
            };
            exceptionCell.font = { color: { argb: 'FFFFFFFF' }, bold: true };
        }
    });

    // Style header row
    styleHeaderRow(vulnSheet, 'FF2C3E50');

    // Add auto-filter
    vulnSheet.autoFilter = {
        from: 'A1',
        to: `K${vulnerabilities.length + 1}`,
    };

    // Freeze header row
    vulnSheet.views = [{ state: 'frozen', ySplit: 1 }];

    // Generate buffer and trigger download
    const buffer = await workbook.xlsx.writeBuffer();
    const blob = new Blob([buffer], {
        type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
    });

    // Create sanitized filename
    const safeHostname = options.hostname.replace(/[^a-zA-Z0-9-_]/g, '_');
    const dateStr = new Date().toISOString().split('T')[0];

    // Create download link
    const url = window.URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `Vulnerabilities_${safeHostname}_${dateStr}.xlsx`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    window.URL.revokeObjectURL(url);
}

/**
 * Get color codes for severity level
 */
function getSeverityColor(severity: string): { bg: string; text: string } | null {
    const sev = severity?.toLowerCase() || '';
    if (sev.includes('critical')) return { bg: 'FFDC3545', text: 'FFFFFFFF' }; // Red
    if (sev.includes('high')) return { bg: 'FFFFC107', text: 'FF000000' }; // Yellow
    if (sev.includes('medium')) return { bg: 'FF17A2B8', text: 'FFFFFFFF' }; // Blue
    if (sev.includes('low')) return { bg: 'FF28A745', text: 'FFFFFFFF' }; // Green
    if (sev.includes('informational')) return { bg: 'FF6C757D', text: 'FFFFFFFF' }; // Gray
    return null;
}

/**
 * Style the header row of a worksheet
 */
function styleHeaderRow(sheet: ExcelJS.Worksheet, color: string): void {
    const headerRow = sheet.getRow(1);
    headerRow.font = { bold: true, size: 11, color: { argb: 'FFFFFFFF' } };
    headerRow.fill = {
        type: 'pattern',
        pattern: 'solid',
        fgColor: { argb: color },
    };
    headerRow.alignment = { vertical: 'middle', horizontal: 'left' };
    headerRow.height = 22;

    // Add borders
    headerRow.eachCell((cell) => {
        cell.border = {
            top: { style: 'thin' },
            left: { style: 'thin' },
            bottom: { style: 'medium' },
            right: { style: 'thin' },
        };
    });

    // Enable text wrap for all cells
    sheet.eachRow((row, rowNumber) => {
        if (rowNumber > 1) {
            row.eachCell((cell) => {
                cell.alignment = { ...cell.alignment, wrapText: true, vertical: 'top' };
                cell.border = {
                    top: { style: 'thin', color: { argb: 'FFE0E0E0' } },
                    left: { style: 'thin', color: { argb: 'FFE0E0E0' } },
                    bottom: { style: 'thin', color: { argb: 'FFE0E0E0' } },
                    right: { style: 'thin', color: { argb: 'FFE0E0E0' } },
                };
            });
        }
    });
}
