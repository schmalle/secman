/**
 * Vulnerability Management Service
 *
 * Handles API calls for vulnerability management functionality
 * including current vulnerabilities and exceptions
 *
 * Related to: Feature 004-i-want-to (VULN Role & Vulnerability Management UI)
 * Related to: Feature 021-vulnerability-overdue-exception-logic
 */

import { authenticatedGet, authenticatedPost, authenticatedPut, authenticatedDelete } from '../utils/auth';

export interface CurrentVulnerability {
    id: number;
    assetName: string;
    assetIp: string | null;
    vulnerabilityId: string | null;
    cvssSeverity: string | null;
    vulnerableProductVersions: string | null;
    daysOpen: string | null;
    scanTimestamp: string;
    hasException: boolean;
    exceptionReason: string | null;
    // Feature 021: Overdue status fields
    ageInDays?: number;
    overdueStatus?: 'OK' | 'OVERDUE' | 'EXCEPTED';
    daysOverdue?: number | null;
    exceptionId?: number | null;
    exceptionEndDate?: string | null;
}

export interface PaginatedVulnerabilitiesResponse {
    content: CurrentVulnerability[];
    totalElements: number;
    totalPages: number;
    currentPage: number;
    pageSize: number;
    hasNext: boolean;
    hasPrevious: boolean;
}

export interface VulnerabilityException {
    id: number;
    exceptionType: string;
    targetValue: string;
    expirationDate: string;
    reason: string;
    createdBy: string;
    createdAt: string;
    // Feature 021: Asset exception fields
    assetId?: number | null;
    assetName?: string | null;
}

export interface CreateExceptionRequest {
    exceptionType: string;
    targetValue: string;
    expirationDate: string;
    reason: string;
    // Feature 021: Asset ID for ASSET-type exceptions
    assetId?: number | null;
}

export interface UpdateExceptionRequest {
    expirationDate: string;
    reason: string;
}

/**
 * Asset interface for asset selector
 * Feature 021: Asset exception management
 */
export interface Asset {
    id: number;
    name: string;
    ip: string | null;
}

/**
 * Get current vulnerabilities with optional filters and pagination
 *
 * @param severity Optional CVSS severity filter
 * @param system Optional system/asset name filter
 * @param exceptionStatus Optional exception status filter
 * @param product Optional product/version filter
 * @param adDomain Optional AD domain filter
 * @param cloudAccountId Optional AWS cloud account ID filter
 * @param page Page number (0-indexed, default: 0)
 * @param size Page size (default: 50)
 * @returns Paginated response with vulnerabilities
 */
export async function getCurrentVulnerabilities(
    severity?: string,
    system?: string,
    exceptionStatus?: string,
    product?: string,
    adDomain?: string,
    cloudAccountId?: string,
    page?: number,
    size?: number,
    sort?: string,
    sortDir?: string
): Promise<PaginatedVulnerabilitiesResponse> {
    const params = new URLSearchParams();
    if (severity) params.append('severity', severity);
    if (system) params.append('system', system);
    if (exceptionStatus) params.append('exceptionStatus', exceptionStatus);
    if (product) params.append('product', product);
    if (adDomain) params.append('adDomain', adDomain);
    if (cloudAccountId) params.append('cloudAccountId', cloudAccountId);
    if (page !== undefined) params.append('page', page.toString());
    if (size !== undefined) params.append('size', size.toString());
    if (sort) params.append('sort', sort);
    if (sortDir) params.append('sortDir', sortDir);

    const queryString = params.toString();
    const url = `/api/vulnerabilities/current${queryString ? `?${queryString}` : ''}`;

    const response = await authenticatedGet(url);

    if (!response.ok) {
        throw new Error(`Failed to fetch vulnerabilities: ${response.status}`);
    }

    return await response.json();
}

/**
 * Get all vulnerability exceptions
 *
 * @returns List of vulnerability exceptions
 */
export async function getVulnerabilityExceptions(): Promise<VulnerabilityException[]> {
    const response = await authenticatedGet('/api/vulnerability-exceptions');

    if (!response.ok) {
        throw new Error(`Failed to fetch exceptions: ${response.status}`);
    }

    return await response.json();
}

/**
 * Create a new vulnerability exception
 *
 * @param request Exception creation request
 * @returns Created exception
 */
export async function createException(
    request: CreateExceptionRequest
): Promise<VulnerabilityException> {
    const response = await authenticatedPost('/api/vulnerability-exceptions', request);

    if (!response.ok) {
        const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
        throw new Error(errorData.error || `Failed to create exception: ${response.status}`);
    }

    return await response.json();
}

/**
 * Update an existing vulnerability exception
 *
 * @param id Exception ID
 * @param request Exception update request
 * @returns Updated exception
 */
export async function updateException(
    id: number,
    request: UpdateExceptionRequest
): Promise<VulnerabilityException> {
    const response = await authenticatedPut(`/api/vulnerability-exceptions/${id}`, request);

    if (!response.ok) {
        const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
        throw new Error(errorData.error || `Failed to update exception: ${response.status}`);
    }

    return await response.json();
}

/**
 * Delete a vulnerability exception
 *
 * @param id Exception ID
 */
export async function deleteException(id: number): Promise<void> {
    const response = await authenticatedDelete(`/api/vulnerability-exceptions/${id}`);

    if (!response.ok) {
        const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
        throw new Error(errorData.error || `Failed to delete exception: ${response.status}`);
    }
}

/**
 * Get all assets for asset exception selector
 * Feature 021: Asset exception management
 *
 * @returns List of assets
 */
export async function getAssets(): Promise<Asset[]> {
    const response = await authenticatedGet('/api/assets');

    if (!response.ok) {
        throw new Error(`Failed to fetch assets: ${response.status}`);
    }

    return await response.json();
}

/**
 * Preview exception impact - shows affected vulnerabilities
 * Feature 021 Phase 3: Product Exception Enhancement
 *
 * @param request Preview request with exception details
 * @returns Impact preview with affected vulnerabilities sample
 */
export interface PreviewExceptionImpactRequest {
    exceptionType: string;
    targetValue: string;
    assetId?: number | null;
}

export interface ExceptionImpactPreview {
    affectedVulnerabilities: CurrentVulnerability[];
    totalCount: number;
    sampleSize: number;
    countBySeverity: Record<string, number>;
}

export async function previewExceptionImpact(
    request: PreviewExceptionImpactRequest
): Promise<ExceptionImpactPreview> {
    const response = await authenticatedPost('/api/vulnerability-exceptions/preview', request);

    if (!response.ok) {
        const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
        throw new Error(errorData.error || `Failed to preview exception impact: ${response.status}`);
    }

    return await response.json();
}

/**
 * Get distinct product versions for autocomplete
 * Feature 021 Phase 3: Product Exception Enhancement
 *
 * @param search Optional search term to filter products
 * @param limit Maximum number of results
 * @returns List of unique product version strings
 */
export async function getDistinctProducts(search?: string, limit: number = 50): Promise<string[]> {
    const params = new URLSearchParams();
    if (search) params.append('search', search);
    params.append('limit', limit.toString());

    const response = await authenticatedGet(`/api/vulnerability-products?${params.toString()}`);

    if (!response.ok) {
        throw new Error(`Failed to fetch products: ${response.status}`);
    }

    return await response.json();
}

/**
 * Get distinct AD domains from assets
 * For filter dropdown population in Current Vulnerabilities view
 *
 * @returns List of unique AD domain names
 */
export async function getDistinctAdDomains(): Promise<string[]> {
    const response = await authenticatedGet('/api/vulnerability-ad-domains');

    if (!response.ok) {
        throw new Error(`Failed to fetch AD domains: ${response.status}`);
    }

    return await response.json();
}

/**
 * Get distinct AWS cloud account IDs from assets
 * For filter dropdown population in Current Vulnerabilities view
 *
 * @returns List of unique AWS cloud account IDs
 */
export async function getDistinctCloudAccountIds(): Promise<string[]> {
    const response = await authenticatedGet('/api/vulnerability-cloud-account-ids');

    if (!response.ok) {
        throw new Error(`Failed to fetch AWS cloud account IDs: ${response.status}`);
    }

    return await response.json();
}

/**
 * Cleanup Result interface for duplicate vulnerability cleanup
 * Feature: Vulnerability Duplicate Cleanup
 */
export interface VulnerabilityCleanupResult {
    totalScanned: number;
    duplicatesFound: number;
    duplicatesRemoved: number;
    uniqueVulnerabilitiesRemaining: number;
    message: string;
}

/**
 * Cleanup duplicate vulnerabilities (ADMIN only)
 *
 * Removes duplicate vulnerabilities from the database.
 * A duplicate is defined as:
 * - Same asset ID
 * - Same vulnerability ID (CVE)
 * - Same scan timestamp
 *
 * The operation keeps the oldest record (lowest ID) and deletes the rest.
 * This operation is idempotent and can be safely called multiple times.
 *
 * @returns VulnerabilityCleanupResult with statistics
 */
export async function cleanupDuplicateVulnerabilities(): Promise<VulnerabilityCleanupResult> {
    const response = await authenticatedPost('/api/vulnerabilities/cleanup-duplicates', null);

    if (!response.ok) {
        const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
        throw new Error(errorData.error || `Failed to cleanup duplicates: ${response.status}`);
    }

    return await response.json();
}

// ==================== Export Job Types ====================

export interface ExportJob {
    jobId: string;
    status: 'PENDING' | 'PROCESSING' | 'COMPLETED' | 'FAILED' | 'CANCELLED' | 'EXPIRED';
    exportType: string;
    progressPercent: number;
    totalItems: number;
    processedItems: number;
    fileName: string | null;
    fileSizeBytes: number | null;
    errorMessage: string | null;
    createdAt: string;
    startedAt: string | null;
    completedAt: string | null;
    isDownloadable: boolean;
    isRunning: boolean;
}

export interface StartExportResponse {
    jobId: string;
    message: string;
    status: string;
}

/**
 * Start a vulnerability export job
 * Feature: Vulnerability Export Performance Optimization - Background Job Pattern
 *
 * Creates a background export job and returns immediately with the job ID.
 * Use pollExportStatus() to track progress.
 *
 * @returns StartExportResponse with job ID
 */
export async function startVulnerabilityExport(): Promise<StartExportResponse> {
    const response = await authenticatedPost('/api/vulnerabilities/export', null);

    if (!response.ok) {
        if (response.status === 429) {
            const errorData = await response.json().catch(() => ({ error: 'Rate limit exceeded' }));
            throw new Error(errorData.error || 'You already have an export in progress. Please wait.');
        }
        const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
        throw new Error(errorData.error || `Failed to start export: ${response.status}`);
    }

    return await response.json();
}

/**
 * Get export job status
 *
 * @param jobId Job ID from startVulnerabilityExport()
 * @returns ExportJob with current status and progress
 */
export async function getExportJobStatus(jobId: string): Promise<ExportJob> {
    const response = await authenticatedGet(`/api/vulnerabilities/export/${jobId}/status`);

    if (!response.ok) {
        if (response.status === 404) {
            throw new Error('Export job not found');
        }
        const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
        throw new Error(errorData.error || `Failed to get export status: ${response.status}`);
    }

    return await response.json();
}

/**
 * Download completed export file
 *
 * @param jobId Job ID of completed export
 */
export async function downloadExportFile(jobId: string): Promise<void> {
    const response = await authenticatedGet(`/api/vulnerabilities/export/${jobId}/download`);

    if (!response.ok) {
        if (response.status === 400) {
            const errorData = await response.json().catch(() => ({ error: 'Export not ready' }));
            throw new Error(errorData.error || 'Export is not ready for download');
        }
        throw new Error(`Failed to download export: ${response.status}`);
    }

    // Get the blob from response
    const blob = await response.blob();

    // Extract filename from Content-Disposition header, fallback to default
    const contentDisposition = response.headers.get('Content-Disposition');
    const filenameMatch = contentDisposition?.match(/filename="?([^"]+)"?/);
    const filename = filenameMatch?.[1] || `vulnerabilities_export_${new Date().toISOString().split('T')[0]}.xlsx`;

    // Trigger download
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

/**
 * Cancel a running export job
 *
 * @param jobId Job ID to cancel
 */
export async function cancelExportJob(jobId: string): Promise<void> {
    const response = await authenticatedDelete(`/api/vulnerabilities/export/${jobId}`);

    if (!response.ok && response.status !== 204) {
        const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
        throw new Error(errorData.error || `Failed to cancel export: ${response.status}`);
    }
}

/**
 * Reset stuck export jobs
 * Use this when exports get stuck in PENDING/PROCESSING status
 *
 * @returns Number of jobs reset
 */
export async function resetStuckExportJobs(): Promise<{ message: string; resetCount: number }> {
    const response = await authenticatedPost('/api/vulnerabilities/export/reset', null);

    if (!response.ok) {
        const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
        throw new Error(errorData.error || `Failed to reset stuck exports: ${response.status}`);
    }

    return await response.json();
}

/**
 * Export vulnerabilities with progress tracking
 * Feature: Vulnerability Export Performance Optimization - Background Job Pattern
 *
 * This is the main function to use for exporting. It:
 * 1. Starts the export job
 * 2. Polls for progress (calls onProgress callback)
 * 3. Downloads the file when complete
 *
 * @param onProgress Optional callback for progress updates
 * @returns Promise that resolves when download completes
 */
export async function exportVulnerabilitiesServerSide(
    onProgress?: (job: ExportJob) => void
): Promise<void> {
    // Start the export job
    const startResponse = await startVulnerabilityExport();
    const jobId = startResponse.jobId;

    // Poll for status
    const pollInterval = 2000; // 2 seconds
    const maxPolls = 300; // 10 minutes max
    let polls = 0;

    while (polls < maxPolls) {
        const job = await getExportJobStatus(jobId);

        // Call progress callback
        if (onProgress) {
            onProgress(job);
        }

        // Check if done
        if (job.status === 'COMPLETED') {
            // Download the file
            await downloadExportFile(jobId);
            return;
        }

        if (job.status === 'FAILED') {
            throw new Error(job.errorMessage || 'Export failed');
        }

        if (job.status === 'CANCELLED') {
            throw new Error('Export was cancelled');
        }

        if (job.status === 'EXPIRED') {
            throw new Error('Export file has expired');
        }

        // Wait before next poll
        await new Promise(resolve => setTimeout(resolve, pollInterval));
        polls++;
    }

    throw new Error('Export timed out. Please try again.');
}
