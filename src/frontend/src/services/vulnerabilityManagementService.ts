/**
 * Vulnerability Management Service
 *
 * Handles API calls for vulnerability management functionality
 * including current vulnerabilities and exceptions
 *
 * Related to: Feature 004-i-want-to (VULN Role & Vulnerability Management UI)
 * Related to: Feature 021-vulnerability-overdue-exception-logic
 */

import { authenticatedGet, authenticatedPost, authenticatedPut, authenticatedDelete } from '../utils/auth';

export interface CurrentVulnerability {
    id: number;
    assetName: string;
    assetIp: string | null;
    vulnerabilityId: string | null;
    cvssSeverity: string | null;
    vulnerableProductVersions: string | null;
    daysOpen: string | null;
    scanTimestamp: string;
    hasException: boolean;
    exceptionReason: string | null;
    // Feature 021: Overdue status fields
    ageInDays?: number;
    overdueStatus?: 'OK' | 'OVERDUE' | 'EXCEPTED';
    daysOverdue?: number | null;
    exceptionId?: number | null;
    exceptionEndDate?: string | null;
}

export interface PaginatedVulnerabilitiesResponse {
    content: CurrentVulnerability[];
    totalElements: number;
    totalPages: number;
    currentPage: number;
    pageSize: number;
    hasNext: boolean;
    hasPrevious: boolean;
}

export interface VulnerabilityException {
    id: number;
    exceptionType: string;
    targetValue: string;
    expirationDate: string;
    reason: string;
    createdBy: string;
    createdAt: string;
    // Feature 021: Asset exception fields
    assetId?: number | null;
    assetName?: string | null;
}

export interface CreateExceptionRequest {
    exceptionType: string;
    targetValue: string;
    expirationDate: string;
    reason: string;
    // Feature 021: Asset ID for ASSET-type exceptions
    assetId?: number | null;
}

export interface UpdateExceptionRequest {
    expirationDate: string;
    reason: string;
}

/**
 * Asset interface for asset selector
 * Feature 021: Asset exception management
 */
export interface Asset {
    id: number;
    name: string;
    ip: string | null;
}

/**
 * Get current vulnerabilities with optional filters and pagination
 *
 * @param severity Optional CVSS severity filter
 * @param system Optional system/asset name filter
 * @param exceptionStatus Optional exception status filter
 * @param product Optional product/version filter
 * @param page Page number (0-indexed, default: 0)
 * @param size Page size (default: 50)
 * @returns Paginated response with vulnerabilities
 */
export async function getCurrentVulnerabilities(
    severity?: string,
    system?: string,
    exceptionStatus?: string,
    product?: string,
    page?: number,
    size?: number
): Promise<PaginatedVulnerabilitiesResponse> {
    const params = new URLSearchParams();
    if (severity) params.append('severity', severity);
    if (system) params.append('system', system);
    if (exceptionStatus) params.append('exceptionStatus', exceptionStatus);
    if (product) params.append('product', product);
    if (page !== undefined) params.append('page', page.toString());
    if (size !== undefined) params.append('size', size.toString());

    const queryString = params.toString();
    const url = `/api/vulnerabilities/current${queryString ? `?${queryString}` : ''}`;

    const response = await authenticatedGet(url);

    if (!response.ok) {
        throw new Error(`Failed to fetch vulnerabilities: ${response.status}`);
    }

    return await response.json();
}

/**
 * Get all vulnerability exceptions
 *
 * @returns List of vulnerability exceptions
 */
export async function getVulnerabilityExceptions(): Promise<VulnerabilityException[]> {
    const response = await authenticatedGet('/api/vulnerabilities/exceptions');

    if (!response.ok) {
        throw new Error(`Failed to fetch exceptions: ${response.status}`);
    }

    return await response.json();
}

/**
 * Create a new vulnerability exception
 *
 * @param request Exception creation request
 * @returns Created exception
 */
export async function createException(
    request: CreateExceptionRequest
): Promise<VulnerabilityException> {
    const response = await authenticatedPost('/api/vulnerabilities/exceptions', request);

    if (!response.ok) {
        const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
        throw new Error(errorData.error || `Failed to create exception: ${response.status}`);
    }

    return await response.json();
}

/**
 * Update an existing vulnerability exception
 *
 * @param id Exception ID
 * @param request Exception update request
 * @returns Updated exception
 */
export async function updateException(
    id: number,
    request: UpdateExceptionRequest
): Promise<VulnerabilityException> {
    const response = await authenticatedPut(`/api/vulnerabilities/exceptions/${id}`, request);

    if (!response.ok) {
        const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
        throw new Error(errorData.error || `Failed to update exception: ${response.status}`);
    }

    return await response.json();
}

/**
 * Delete a vulnerability exception
 *
 * @param id Exception ID
 */
export async function deleteException(id: number): Promise<void> {
    const response = await authenticatedDelete(`/api/vulnerabilities/exceptions/${id}`);

    if (!response.ok) {
        const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
        throw new Error(errorData.error || `Failed to delete exception: ${response.status}`);
    }
}

/**
 * Get all assets for asset exception selector
 * Feature 021: Asset exception management
 *
 * @returns List of assets
 */
export async function getAssets(): Promise<Asset[]> {
    const response = await authenticatedGet('/api/assets');

    if (!response.ok) {
        throw new Error(`Failed to fetch assets: ${response.status}`);
    }

    return await response.json();
}
