/**
 * Vulnerability Service
 *
 * Handles API calls for vulnerability management functionality
 *
 * Related to: Feature 003-i-want-to (Vulnerability Management System)
 */

export interface VulnerabilityImportResponse {
    message: string;
    imported: number;
    skipped: number;
    assetsCreated: number;
    skippedDetails?: Array<{
        row: number;
        reason: string;
    }>;
}

export interface Vulnerability {
    id: number;
    vulnerabilityId: string | null;
    cvssSeverity: string | null;
    vulnerableProductVersions: string | null;
    daysOpen: string | null;
    scanTimestamp: string;
    createdAt: string;
}

/**
 * Upload vulnerability Excel file
 *
 * @param file Excel file (.xlsx) containing vulnerability data
 * @param scanDate ISO 8601 datetime string when scan was performed
 * @returns Import response with counts and skipped details
 */
export async function uploadVulnerabilityFile(
    file: File,
    scanDate: string
): Promise<VulnerabilityImportResponse> {
    console.log('[VulnerabilityService] uploadVulnerabilityFile called');
    console.log('[VulnerabilityService] File:', file.name, 'Size:', file.size);
    console.log('[VulnerabilityService] Scan date:', scanDate);

    const formData = new FormData();
    formData.append('xlsxFile', file);
    formData.append('scanDate', scanDate);

    const url = '/api/import/upload-vulnerability-xlsx';
    console.log('[VulnerabilityService] Calling API:', url);

    try {
        // Authentication via HttpOnly secman_auth cookie (sent automatically with credentials: 'include')
        const response = await fetch(url, {
            method: 'POST',
            credentials: 'include',
            body: formData
        });

        console.log('[VulnerabilityService] Response status:', response.status);
        console.log('[VulnerabilityService] Response ok:', response.ok);

        if (!response.ok) {
            // Try to parse error response
            try {
                const errorData = await response.json();
                console.error('[VulnerabilityService] Error response:', errorData);
                throw new Error(errorData.error || `Upload failed with status ${response.status}`);
            } catch (e) {
                console.error('[VulnerabilityService] Failed to parse error:', e);
                throw new Error(`Upload failed with status ${response.status}`);
            }
        }

        const result = await response.json();
        console.log('[VulnerabilityService] Success response:', result);
        return result;
    } catch (error) {
        console.error('[VulnerabilityService] Fetch error:', error);
        throw error;
    }
}

/**
 * Get vulnerabilities for a specific asset
 *
 * @param assetId Asset ID
 * @returns List of vulnerabilities
 */
export async function getAssetVulnerabilities(
    assetId: number
): Promise<Vulnerability[]> {
    // Authentication via HttpOnly secman_auth cookie (sent automatically with credentials: 'include')
    const response = await fetch(
        `/api/assets/${assetId}/vulnerabilities`,
        {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json'
            },
            credentials: 'include',
        }
    );

    if (!response.ok) {
        if (response.status === 404) {
            throw new Error('Asset not found');
        }
        throw new Error(`Failed to fetch vulnerabilities: ${response.status}`);
    }

    return await response.json();
}
