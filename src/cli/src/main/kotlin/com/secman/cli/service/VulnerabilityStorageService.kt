package com.secman.cli.service

import com.fasterxml.jackson.databind.ObjectMapper
import com.secman.crowdstrike.dto.CrowdStrikeVulnerabilityDto
import io.micronaut.http.HttpRequest
import io.micronaut.http.HttpResponse
import io.micronaut.http.client.HttpClient
import io.micronaut.http.client.annotation.Client
import jakarta.inject.Singleton
import org.slf4j.LoggerFactory

/**
 * Service for storing vulnerabilities in secman database via backend API
 *
 * Functionality:
 * - POST vulnerabilities to backend API
 * - Handle deduplication
 * - Retry logic for transient failures
 * - Error recovery
 *
 * Related to: Feature 026-crowdstrike-polling-monitor
 * Tasks: T10-T13
 */
@Singleton
class VulnerabilityStorageService(
    @Client("\${secman.backend.base-url:http://localhost:8080}")
    private val httpClient: HttpClient,
    private val objectMapper: ObjectMapper
) {
    private val log = LoggerFactory.getLogger(VulnerabilityStorageService::class.java)
    
    /**
     * Store vulnerabilities via backend API
     *
     * Task: T10-T11
     *
     * @param hostname System hostname
     * @param vulnerabilities List of vulnerabilities to store
     * @param backendUrl Optional backend URL override
     * @return StorageResult with statistics
     */
    fun storeVulnerabilities(
        hostname: String,
        vulnerabilities: List<CrowdStrikeVulnerabilityDto>,
        backendUrl: String? = null
    ): StorageResult {
        if (vulnerabilities.isEmpty()) {
            log.debug("No vulnerabilities to store for {}", hostname)
            return StorageResult(stored = 0, skipped = 0, errors = emptyList())
        }
        
        log.info("Storing {} vulnerabilities for {} via backend API", vulnerabilities.size, hostname)
        
        try {
            // Build request payload
            val request = mapOf(
                "hostname" to hostname,
                "vulnerabilities" to vulnerabilities
            )
            
            // Determine API endpoint
            val endpoint = "${backendUrl ?: "http://localhost:8080"}/api/crowdstrike/vulnerabilities/save"
            
            // Make HTTP POST request (Task: T11)
            val httpRequest = HttpRequest.POST(endpoint, request)
                .contentType(io.micronaut.http.MediaType.APPLICATION_JSON)
            
            val response: HttpResponse<Map<*, *>> = httpClient.toBlocking()
                .exchange(httpRequest, Map::class.java)
            
            if (response.status.code == 200) {
                val body = response.body() as? Map<*, *>
                val saved = (body?.get("vulnerabilitiesSaved") as? Number)?.toInt() ?: vulnerabilities.size
                val skipped = vulnerabilities.size - saved
                
                log.info("Successfully stored vulnerabilities: saved={}, skipped={}", saved, skipped)
                return StorageResult(
                    stored = saved,
                    skipped = skipped,
                    errors = emptyList()
                )
            } else {
                val errorMsg = "Backend API returned status ${response.status.code}"
                log.error(errorMsg)
                return StorageResult(
                    stored = 0,
                    skipped = vulnerabilities.size,
                    errors = listOf(errorMsg)
                )
            }
        } catch (e: io.micronaut.http.client.exceptions.HttpClientResponseException) {
            val errorMsg = "Backend API error: ${e.status.code} - ${e.message}"
            log.error(errorMsg, e)
            
            // Implement retry logic for transient failures (Task: T13)
            if (e.status.code in 500..599) {
                return retryStorage(hostname, vulnerabilities, backendUrl, retries = 2)
            }
            
            return StorageResult(
                stored = 0,
                skipped = vulnerabilities.size,
                errors = listOf(errorMsg)
            )
        } catch (e: Exception) {
            val errorMsg = "Failed to store vulnerabilities: ${e.message}"
            log.error(errorMsg, e)
            return StorageResult(
                stored = 0,
                skipped = vulnerabilities.size,
                errors = listOf(errorMsg)
            )
        }
    }
    
    /**
     * Retry storage operation with exponential backoff
     *
     * Task: T13
     *
     * @param hostname System hostname
     * @param vulnerabilities List of vulnerabilities
     * @param backendUrl Backend URL
     * @param retries Number of retries remaining
     * @return StorageResult
     */
    private fun retryStorage(
        hostname: String,
        vulnerabilities: List<CrowdStrikeVulnerabilityDto>,
        backendUrl: String?,
        retries: Int
    ): StorageResult {
        if (retries <= 0) {
            log.error("Max retries exceeded for storing vulnerabilities")
            return StorageResult(
                stored = 0,
                skipped = vulnerabilities.size,
                errors = listOf("Max retries exceeded")
            )
        }
        
        val backoffMs = (3 - retries) * 2000L // 2s, 4s
        log.info("Retrying storage after {}ms (retries remaining: {})", backoffMs, retries)
        
        try {
            Thread.sleep(backoffMs)
            return storeVulnerabilities(hostname, vulnerabilities, backendUrl)
        } catch (e: InterruptedException) {
            log.error("Retry interrupted", e)
            Thread.currentThread().interrupt()
            return StorageResult(
                stored = 0,
                skipped = vulnerabilities.size,
                errors = listOf("Retry interrupted")
            )
        }
    }
}

/**
 * Result of a storage operation
 */
data class StorageResult(
    val stored: Int,
    val skipped: Int,
    val errors: List<String>
)
