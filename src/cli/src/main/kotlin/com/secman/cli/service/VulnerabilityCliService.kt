package com.secman.cli.service

import io.micronaut.http.HttpRequest
import io.micronaut.http.HttpResponse
import io.micronaut.http.client.HttpClient
import io.micronaut.http.client.annotation.Client
import jakarta.inject.Singleton
import org.slf4j.LoggerFactory

/**
 * Service for adding vulnerabilities via CLI
 * Feature: 052-cli-add-vulnerability
 *
 * Functionality:
 * - Authenticate with backend API
 * - POST vulnerability to backend CLI endpoint
 * - Return operation result
 */
@Singleton
class VulnerabilityCliService(
    @Client("\${secman.backend.base-url:http://localhost:8080}")
    private val httpClient: HttpClient
) {
    private val log = LoggerFactory.getLogger(VulnerabilityCliService::class.java)

    /**
     * Authenticate with backend API and get JWT token
     *
     * @param username Backend username
     * @param password Backend password
     * @param backendUrl Backend API URL
     * @return JWT token or null if authentication failed
     */
    fun authenticate(username: String, password: String, backendUrl: String): String? {
        try {
            val endpoint = "$backendUrl/api/auth/login"
            val request = HttpRequest.POST(endpoint, mapOf(
                "username" to username,
                "password" to password
            )).contentType(io.micronaut.http.MediaType.APPLICATION_JSON)

            val response: HttpResponse<Map<*, *>> = httpClient.toBlocking()
                .exchange(request, Map::class.java)

            if (response.status.code == 200) {
                val body = response.body() as? Map<*, *>
                val token = body?.get("access_token")?.toString()
                    ?: body?.get("token")?.toString()
                    ?: body?.get("accessToken")?.toString()

                if (token != null) {
                    log.info("Successfully authenticated with backend")
                    return token
                }
            }

            log.error("Authentication failed: status={}", response.status)
            return null
        } catch (e: io.micronaut.http.client.exceptions.HttpClientResponseException) {
            log.error("Authentication error: {} - {}", e.status.code, e.message)
            return null
        } catch (e: Exception) {
            log.error("Authentication error: {}", e.message, e)
            return null
        }
    }

    /**
     * Add or update vulnerability via backend API
     *
     * @param hostname Target asset hostname
     * @param cve CVE identifier
     * @param criticality Severity level (CRITICAL/HIGH/MEDIUM/LOW)
     * @param daysOpen Number of days the vulnerability has been open
     * @param backendUrl Backend API URL
     * @param authToken JWT authentication token
     * @return AddVulnerabilityResult with operation result
     */
    fun addVulnerability(
        hostname: String,
        cve: String,
        criticality: String,
        daysOpen: Int,
        backendUrl: String,
        authToken: String
    ): AddVulnerabilityResult {
        log.info("Adding vulnerability: hostname={}, cve={}, criticality={}, daysOpen={}",
            hostname, cve, criticality, daysOpen)

        try {
            val endpoint = "$backendUrl/api/vulnerabilities/cli-add"
            val request = HttpRequest.POST(endpoint, mapOf(
                "hostname" to hostname,
                "cve" to cve,
                "criticality" to criticality,
                "daysOpen" to daysOpen
            ))
                .contentType(io.micronaut.http.MediaType.APPLICATION_JSON)
                .header("Authorization", "Bearer $authToken")

            val response: HttpResponse<Map<*, *>> = httpClient.toBlocking()
                .exchange(request, Map::class.java)

            if (response.status.code == 200) {
                val body = response.body() as? Map<*, *>
                return AddVulnerabilityResult(
                    success = body?.get("success") as? Boolean ?: true,
                    message = body?.get("message")?.toString() ?: "Vulnerability added",
                    assetName = body?.get("assetName")?.toString() ?: hostname,
                    assetCreated = body?.get("assetCreated") as? Boolean ?: false,
                    vulnerabilityId = body?.get("vulnerabilityId")?.toString() ?: cve,
                    operation = body?.get("operation")?.toString() ?: "CREATED"
                )
            } else {
                return AddVulnerabilityResult(
                    success = false,
                    message = "Backend API returned status ${response.status.code}",
                    assetName = hostname,
                    assetCreated = false,
                    vulnerabilityId = cve,
                    operation = "FAILED"
                )
            }
        } catch (e: io.micronaut.http.client.exceptions.HttpClientResponseException) {
            val errorMsg = when (e.status.code) {
                400 -> {
                    val body = try { e.response.getBody(Map::class.java).orElse(null) } catch (ex: Exception) { null }
                    body?.get("error")?.toString() ?: "Invalid request: ${e.message}"
                }
                401 -> "Authentication required"
                403 -> "Insufficient permissions (ADMIN or VULN role required)"
                else -> "Backend API error: ${e.status.code} - ${e.message}"
            }
            log.error("Add vulnerability error: {}", errorMsg)
            return AddVulnerabilityResult(
                success = false,
                message = errorMsg,
                assetName = hostname,
                assetCreated = false,
                vulnerabilityId = cve,
                operation = "FAILED"
            )
        } catch (e: java.net.ConnectException) {
            val errorMsg = "Cannot connect to backend at $backendUrl"
            log.error(errorMsg, e)
            return AddVulnerabilityResult(
                success = false,
                message = errorMsg,
                assetName = hostname,
                assetCreated = false,
                vulnerabilityId = cve,
                operation = "CONNECTION_ERROR",
                exitCode = 2
            )
        } catch (e: Exception) {
            val errorMsg = "Failed to add vulnerability: ${e.message}"
            log.error(errorMsg, e)
            return AddVulnerabilityResult(
                success = false,
                message = errorMsg,
                assetName = hostname,
                assetCreated = false,
                vulnerabilityId = cve,
                operation = "FAILED"
            )
        }
    }
}

/**
 * Result of add vulnerability operation
 * Feature: 052-cli-add-vulnerability
 */
data class AddVulnerabilityResult(
    val success: Boolean,
    val message: String,
    val assetName: String,
    val assetCreated: Boolean,
    val vulnerabilityId: String,
    val operation: String,
    val exitCode: Int = if (success) 0 else 1
)
