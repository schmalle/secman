package com.secman.cli.service

import com.fasterxml.jackson.databind.ObjectMapper
import com.secman.crowdstrike.dto.CrowdStrikeVulnerabilityDto
import io.micronaut.http.HttpRequest
import io.micronaut.http.HttpResponse
import io.micronaut.http.client.HttpClient
import io.micronaut.http.client.annotation.Client
import jakarta.inject.Singleton
import org.slf4j.LoggerFactory
import java.time.LocalDateTime

/**
 * Service for storing vulnerabilities in secman database via backend API
 *
 * Functionality:
 * - POST vulnerabilities to backend API
 * - Handle deduplication
 * - Retry logic for transient failures
 * - Error recovery
 *
 * Related to: Feature 026-crowdstrike-polling-monitor
 * Tasks: T10-T13
 */
@Singleton
class VulnerabilityStorageService(
    @Client("\${secman.backend.base-url:http://localhost:8080}")
    private val httpClient: HttpClient,
    private val objectMapper: ObjectMapper
) {
    private val log = LoggerFactory.getLogger(VulnerabilityStorageService::class.java)

    /**
     * Authenticate with backend API and get JWT token
     *
     * @param username Backend username
     * @param password Backend password
     * @param backendUrl Backend API URL
     * @return JWT token or null if authentication failed
     */
    fun authenticate(username: String, password: String, backendUrl: String): String? {
        try {
            val endpoint = "$backendUrl/api/auth/login"
            val request = HttpRequest.POST(endpoint, mapOf(
                "username" to username,
                "password" to password
            )).contentType(io.micronaut.http.MediaType.APPLICATION_JSON)

            val response: HttpResponse<Map<*, *>> = httpClient.toBlocking()
                .exchange(request, Map::class.java)

            if (response.status.code == 200) {
                val body = response.body() as? Map<*, *>
                val token = body?.get("access_token")?.toString()
                    ?: body?.get("token")?.toString()
                    ?: body?.get("accessToken")?.toString()

                if (token != null) {
                    log.info("Successfully authenticated with backend")
                    return token
                }
            }

            log.error("Authentication failed: status={}", response.status)
            return null
        } catch (e: Exception) {
            log.error("Authentication error: {}", e.message, e)
            return null
        }
    }

    /**
     * Store vulnerabilities via backend API
     *
     * Task: T10-T11
     *
     * @param hostname System hostname
     * @param vulnerabilities List of vulnerabilities to store
     * @param backendUrl Optional backend URL override
     * @param authToken Optional JWT authentication token
     * @return StorageResult with statistics
     */
    fun storeVulnerabilities(
        hostname: String,
        vulnerabilities: List<CrowdStrikeVulnerabilityDto>,
        backendUrl: String? = null,
        authToken: String? = null
    ): StorageResult {
        if (vulnerabilities.isEmpty()) {
            log.debug("No vulnerabilities to store for {}", hostname)
            return StorageResult(stored = 0, skipped = 0, errors = emptyList())
        }
        
        log.info("Storing {} vulnerabilities for {} via backend API", vulnerabilities.size, hostname)
        
        try {
            // Build request payload
            val request = mapOf(
                "hostname" to hostname,
                "vulnerabilities" to vulnerabilities
            )
            
            // Determine API endpoint
            val endpoint = "${backendUrl ?: "http://localhost:8080"}/api/crowdstrike/vulnerabilities/save"
            
            // Make HTTP POST request with authentication (Task: T11)
            val httpRequest = HttpRequest.POST(endpoint, request)
                .contentType(io.micronaut.http.MediaType.APPLICATION_JSON)

            // Add JWT token to Authorization header if provided
            if (authToken != null) {
                httpRequest.header("Authorization", "Bearer $authToken")
            }

            val response: HttpResponse<Map<*, *>> = httpClient.toBlocking()
                .exchange(httpRequest, Map::class.java)
            
            if (response.status.code == 200) {
                val body = response.body() as? Map<*, *>
                val saved = (body?.get("vulnerabilitiesSaved") as? Number)?.toInt() ?: vulnerabilities.size
                val skipped = (body?.get("vulnerabilitiesSkipped") as? Number)?.toInt() ?: 0
                val assetsCreated = (body?.get("assetsCreated") as? Number)?.toInt() ?: 0
                val message = body?.get("message")?.toString() ?: "Saved successfully"

                log.info("Successfully stored vulnerabilities: saved={}, skipped={}, assetsCreated={}", saved, skipped, assetsCreated)
                return StorageResult(
                    stored = saved,
                    skipped = skipped,
                    errors = emptyList(),
                    assetsCreated = assetsCreated,
                    message = message
                )
            } else {
                val errorMsg = "Backend API returned status ${response.status.code}"
                log.error(errorMsg)
                return StorageResult(
                    stored = 0,
                    skipped = vulnerabilities.size,
                    errors = listOf(errorMsg)
                )
            }
        } catch (e: io.micronaut.http.client.exceptions.HttpClientResponseException) {
            val errorMsg = "Backend API error: ${e.status.code} - ${e.message}"
            log.error(errorMsg, e)
            
            // Implement retry logic for transient failures (Task: T13)
            if (e.status.code in 500..599) {
                return retryStorage(hostname, vulnerabilities, backendUrl, retries = 2)
            }
            
            return StorageResult(
                stored = 0,
                skipped = vulnerabilities.size,
                errors = listOf(errorMsg)
            )
        } catch (e: Exception) {
            val errorMsg = "Failed to store vulnerabilities: ${e.message}"
            log.error(errorMsg, e)
            return StorageResult(
                stored = 0,
                skipped = vulnerabilities.size,
                errors = listOf(errorMsg)
            )
        }
    }
    
    /**
     * Retry storage operation with exponential backoff
     *
     * Task: T13
     *
     * @param hostname System hostname
     * @param vulnerabilities List of vulnerabilities
     * @param backendUrl Backend URL
     * @param retries Number of retries remaining
     * @return StorageResult
     */
    private fun retryStorage(
        hostname: String,
        vulnerabilities: List<CrowdStrikeVulnerabilityDto>,
        backendUrl: String?,
        retries: Int
    ): StorageResult {
        if (retries <= 0) {
            log.error("Max retries exceeded for storing vulnerabilities")
            return StorageResult(
                stored = 0,
                skipped = vulnerabilities.size,
                errors = listOf("Max retries exceeded")
            )
        }
        
        val backoffMs = (3 - retries) * 2000L // 2s, 4s
        log.info("Retrying storage after {}ms (retries remaining: {})", backoffMs, retries)
        
        try {
            Thread.sleep(backoffMs)
            return storeVulnerabilities(hostname, vulnerabilities, backendUrl)
        } catch (e: InterruptedException) {
            log.error("Retry interrupted", e)
            Thread.currentThread().interrupt()
            return StorageResult(
                stored = 0,
                skipped = vulnerabilities.size,
                errors = listOf("Retry interrupted")
            )
        }
    }

    /**
     * Store server vulnerabilities with metadata via backend batch import API
     *
     * Feature: 032-servers-query-import
     * Task: T011
     *
     * This method implements chunking/batching to avoid 413 Request Entity Too Large errors
     * when processing large datasets (e.g., 94947 vulnerabilities across 857 servers).
     *
     * @param serverBatches Map of hostname to server data with metadata and vulnerabilities
     * @param backendUrl Optional backend URL override
     * @param authToken Optional JWT authentication token
     * @param batchSize Number of servers to process per batch (default 50)
     * @return BatchStorageResult with aggregated statistics from all batches
     */
    fun storeServerVulnerabilities(
        serverBatches: Map<String, ServerVulnerabilityBatch>,
        backendUrl: String? = null,
        authToken: String? = null,
        batchSize: Int = 50
    ): BatchStorageResult {
        if (serverBatches.isEmpty()) {
            log.debug("No server vulnerabilities to store")
            return BatchStorageResult(
                serversProcessed = 0,
                serversCreated = 0,
                serversUpdated = 0,
                vulnerabilitiesImported = 0,
                vulnerabilitiesSkipped = 0,
                errors = emptyList()
            )
        }

        val totalServers = serverBatches.size
        log.info("Storing vulnerabilities for {} servers via backend batch import API (batch size: {})", totalServers, batchSize)

        // Split servers into chunks to avoid 413 errors
        val serverChunks = serverBatches.entries.chunked(batchSize)
        val totalChunks = serverChunks.size

        log.info("Split into {} batches of up to {} servers each", totalChunks, batchSize)

        // Aggregate results across all batches
        var totalServersProcessed = 0
        var totalServersCreated = 0
        var totalServersUpdated = 0
        var totalVulnerabilitiesImported = 0
        var totalVulnerabilitiesSkipped = 0
        val allErrors = mutableListOf<String>()

        // Process each chunk
        serverChunks.forEachIndexed { index, chunk ->
            val chunkNumber = index + 1
            val chunkSize = chunk.size

            log.info("Importing batch {}/{} ({} servers)...", chunkNumber, totalChunks, chunkSize)
            println("Importing batch $chunkNumber/$totalChunks ($chunkSize servers)...")

            try {
                // Convert chunk to map for processing
                val chunkMap = chunk.associate { it.key to it.value }

                // Process this chunk
                val chunkResult = processSingleBatch(chunkMap, backendUrl, authToken)

                // Aggregate results
                totalServersProcessed += chunkResult.serversProcessed
                totalServersCreated += chunkResult.serversCreated
                totalServersUpdated += chunkResult.serversUpdated
                totalVulnerabilitiesImported += chunkResult.vulnerabilitiesImported
                totalVulnerabilitiesSkipped += chunkResult.vulnerabilitiesSkipped
                allErrors.addAll(chunkResult.errors)

                log.info("Batch {}/{} completed: processed={}, created={}, updated={}, imported={}, skipped={}",
                    chunkNumber, totalChunks, chunkResult.serversProcessed, chunkResult.serversCreated,
                    chunkResult.serversUpdated, chunkResult.vulnerabilitiesImported, chunkResult.vulnerabilitiesSkipped)

            } catch (e: Exception) {
                val errorMsg = "Failed to process batch $chunkNumber/$totalChunks: ${e.message}"
                log.error(errorMsg, e)
                allErrors.add(errorMsg)
                // Continue processing remaining batches even if one fails
            }
        }

        log.info("All batches completed: total servers processed={}, created={}, updated={}, vulnerabilities imported={}, skipped={}, errors={}",
            totalServersProcessed, totalServersCreated, totalServersUpdated,
            totalVulnerabilitiesImported, totalVulnerabilitiesSkipped, allErrors.size)

        println("\nImport Summary:")
        println("  Servers processed: $totalServersProcessed")
        println("  Servers created: $totalServersCreated")
        println("  Servers updated: $totalServersUpdated")
        println("  Vulnerabilities imported: $totalVulnerabilitiesImported")
        println("  Vulnerabilities skipped: $totalVulnerabilitiesSkipped")
        if (allErrors.isNotEmpty()) {
            println("  Errors: ${allErrors.size}")
        }

        return BatchStorageResult(
            serversProcessed = totalServersProcessed,
            serversCreated = totalServersCreated,
            serversUpdated = totalServersUpdated,
            vulnerabilitiesImported = totalVulnerabilitiesImported,
            vulnerabilitiesSkipped = totalVulnerabilitiesSkipped,
            errors = allErrors
        )
    }

    /**
     * Process a single batch of servers via backend import API
     *
     * This is a helper method extracted from storeServerVulnerabilities to enable batching.
     *
     * @param serverBatch Map of hostname to server data for this batch
     * @param backendUrl Optional backend URL override
     * @param authToken Optional JWT authentication token
     * @return BatchStorageResult for this single batch
     */
    private fun processSingleBatch(
        serverBatch: Map<String, ServerVulnerabilityBatch>,
        backendUrl: String?,
        authToken: String?
    ): BatchStorageResult {
        try {
            // Validate and sanitize batch data before sending
            log.info("Validating batch with {} servers before sending to backend", serverBatch.size)

            val validatedBatch = serverBatch.mapNotNull { (hostname, batch) ->
                // Validate hostname
                if (hostname.isBlank()) {
                    log.warn("Skipping server with blank hostname")
                    return@mapNotNull null
                }
                if (hostname.length > 255) {
                    log.warn("Skipping server with hostname too long: '{}' ({} chars)", hostname.take(50), hostname.length)
                    return@mapNotNull null
                }

                // Validate and filter vulnerabilities
                val validVulns = batch.vulnerabilities.filterIndexed { index, vuln ->
                    // Check CVE ID
                    val cveId = vuln.cveId
                    if (cveId.isNullOrBlank()) {
                        log.warn("Skipping vulnerability with blank CVE ID for server '{}'", hostname)
                        return@filterIndexed false
                    }
                    if (cveId.length > 255) {
                        log.warn("Skipping vulnerability with CVE ID too long for server '{}': {} chars", hostname, cveId.length)
                        return@filterIndexed false
                    }

                    // Check severity
                    val severity = vuln.severity
                    if (severity.isNullOrBlank()) {
                        log.warn("Skipping vulnerability {} for server '{}': severity is blank", cveId, hostname)
                        return@filterIndexed false
                    }
                    if (severity.length > 50) {
                        log.warn("Skipping vulnerability {} for server '{}': severity too long ({} chars)", cveId, hostname, severity.length)
                        return@filterIndexed false
                    }

                    // Check affectedProduct length (not required but has size limit)
                    val affectedProduct = vuln.affectedProduct
                    if (affectedProduct != null && affectedProduct.length > 512) {
                        log.warn("Truncating affectedProduct for vulnerability {} on server '{}': {} chars",
                            cveId, hostname, affectedProduct.length)
                        // We'll truncate this in the DTO creation below
                    }

                    true
                }

                // Keep server only if it has valid vulnerabilities
                if (validVulns.isEmpty()) {
                    log.warn("Skipping server '{}': all {} vulnerabilities were invalid", hostname, batch.vulnerabilities.size)
                    return@mapNotNull null
                }

                // Return validated batch
                hostname to batch.copy(vulnerabilities = validVulns)
            }.toMap()

            if (validatedBatch.isEmpty()) {
                log.error("All servers in batch were invalid - no data to send")
                return BatchStorageResult(
                    serversProcessed = 0,
                    serversCreated = 0,
                    serversUpdated = 0,
                    vulnerabilitiesImported = 0,
                    vulnerabilitiesSkipped = serverBatch.values.sumOf { it.vulnerabilities.size },
                    errors = listOf("All servers in batch failed validation")
                )
            }

            val skippedServers = serverBatch.size - validatedBatch.size
            if (skippedServers > 0) {
                log.warn("Filtered out {} invalid servers, proceeding with {} valid servers", skippedServers, validatedBatch.size)
            }

            // Convert to backend DTO format
            val serverBatchDtos = validatedBatch.map { (hostname, batch) ->
                mapOf(
                    "hostname" to hostname,
                    "groups" to batch.groups,
                    "cloudAccountId" to batch.cloudAccountId,
                    "cloudInstanceId" to batch.cloudInstanceId,
                    "adDomain" to batch.adDomain,
                    "osVersion" to batch.osVersion,
                    "ip" to batch.ip,
                    "vulnerabilities" to batch.vulnerabilities.map { vuln ->
                        mapOf(
                            "cveId" to vuln.cveId,
                            "severity" to vuln.severity,
                            "affectedProduct" to vuln.affectedProduct?.take(512),  // Truncate to 512 chars
                            "daysOpen" to parseDaysOpenToInt(vuln.daysOpen)  // Parse "526 days" -> 526
                        )
                    }
                )
            }

            // Determine API endpoint (Feature 032 batch import)
            val endpoint = "${backendUrl ?: "http://localhost:8080"}/api/crowdstrike/servers/import"

            // Make HTTP POST request with optional authentication
            val httpRequest = HttpRequest.POST(endpoint, serverBatchDtos)
                .contentType(io.micronaut.http.MediaType.APPLICATION_JSON)

            // Add JWT token to Authorization header if provided
            if (authToken != null) {
                httpRequest.header("Authorization", "Bearer $authToken")
            }

            val response: HttpResponse<Map<*, *>> = httpClient.toBlocking()
                .exchange(httpRequest, Map::class.java)

            if (response.status.code == 200) {
                val body = response.body() as? Map<*, *>

                val serversProcessed = (body?.get("serversProcessed") as? Number)?.toInt() ?: serverBatch.size
                val serversCreated = (body?.get("serversCreated") as? Number)?.toInt() ?: 0
                val serversUpdated = (body?.get("serversUpdated") as? Number)?.toInt() ?: 0
                val vulnerabilitiesImported = (body?.get("vulnerabilitiesImported") as? Number)?.toInt() ?: 0
                val vulnerabilitiesSkipped = (body?.get("vulnerabilitiesSkipped") as? Number)?.toInt() ?: 0
                @Suppress("UNCHECKED_CAST")
                val errors = (body?.get("errors") as? List<String>) ?: emptyList()

                return BatchStorageResult(
                    serversProcessed = serversProcessed,
                    serversCreated = serversCreated,
                    serversUpdated = serversUpdated,
                    vulnerabilitiesImported = vulnerabilitiesImported,
                    vulnerabilitiesSkipped = vulnerabilitiesSkipped,
                    errors = errors
                )
            } else {
                val errorMsg = "Backend API returned status ${response.status.code}"
                log.error(errorMsg)
                return BatchStorageResult(
                    serversProcessed = 0,
                    serversCreated = 0,
                    serversUpdated = 0,
                    vulnerabilitiesImported = 0,
                    vulnerabilitiesSkipped = 0,
                    errors = listOf(errorMsg)
                )
            }
        } catch (e: io.micronaut.http.client.exceptions.HttpClientResponseException) {
            // Try to extract detailed validation errors from response
            val responseBody = try {
                e.response.getBody(Map::class.java).orElse(null)
            } catch (ex: Exception) {
                null
            }

            // Extract validation violations if present
            val violations = responseBody?.get("violations") as? List<*>
            val detailedErrors = violations?.joinToString("; ") { it.toString() }

            val errorMsg = if (detailedErrors != null) {
                "Backend API error: ${e.status.code} - Validation failed: $detailedErrors"
            } else {
                val errorDetail = responseBody?.get("error") ?: responseBody?.get("message") ?: e.message
                "Backend API error: ${e.status.code} - $errorDetail"
            }

            log.error(errorMsg)

            // Log batch details for debugging
            val hostnameList = serverBatch.keys.take(5).joinToString(", ")
            val moreCount = if (serverBatch.size > 5) " and ${serverBatch.size - 5} more" else ""
            log.error("Failed batch contained {} servers: {}{}", serverBatch.size, hostnameList, moreCount)

            return BatchStorageResult(
                serversProcessed = 0,
                serversCreated = 0,
                serversUpdated = 0,
                vulnerabilitiesImported = 0,
                vulnerabilitiesSkipped = 0,
                errors = listOf(errorMsg)
            )
        } catch (e: Exception) {
            val errorMsg = "Failed to store server vulnerabilities: ${e.message}"
            log.error(errorMsg, e)
            return BatchStorageResult(
                serversProcessed = 0,
                serversCreated = 0,
                serversUpdated = 0,
                vulnerabilitiesImported = 0,
                vulnerabilitiesSkipped = 0,
                errors = listOf(errorMsg)
            )
        }
    }

    /**
     * Parse daysOpen string to integer value
     *
     * Handles formats:
     * - "526 days" -> 526
     * - "1 day" -> 1
     * - "0 days" -> 0
     * - null or invalid -> 0
     *
     * @param daysOpen String in format "X days" or "X day"
     * @return Integer value of days
     */
    private fun parseDaysOpenToInt(daysOpen: String?): Int {
        if (daysOpen.isNullOrBlank()) {
            return 0
        }

        return try {
            // Extract numeric part from "526 days" or "1 day"
            daysOpen.split(" ").firstOrNull()?.toIntOrNull() ?: 0
        } catch (e: Exception) {
            log.warn("Failed to parse daysOpen '{}': {}", daysOpen, e.message)
            0
        }
    }
}

/**
 * Result of a storage operation
 */
data class StorageResult(
    val stored: Int,
    val skipped: Int,
    val errors: List<String>,
    val assetsCreated: Int = 0,
    val message: String = ""
)

/**
 * Batch of vulnerabilities for a single server with metadata
 *
 * Feature: 032-servers-query-import
 */
data class ServerVulnerabilityBatch(
    val hostname: String,
    val vulnerabilities: List<CrowdStrikeVulnerabilityDto>,
    val groups: String? = null,
    val cloudAccountId: String? = null,
    val cloudInstanceId: String? = null,
    val adDomain: String? = null,
    val osVersion: String? = null,
    val ip: String? = null
)

/**
 * Result of a batch storage operation
 *
 * Feature: 032-servers-query-import
 */
data class BatchStorageResult(
    val serversProcessed: Int,
    val serversCreated: Int,
    val serversUpdated: Int,
    val vulnerabilitiesImported: Int,
    val vulnerabilitiesSkipped: Int,
    val errors: List<String>
)
