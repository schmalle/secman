package com.secman.unit

import com.secman.domain.Asset
import com.secman.domain.Vulnerability
import com.secman.repository.VulnerabilityRepository
import com.secman.service.AssetMergeService
import com.secman.service.VulnerabilityImportService
import io.micronaut.test.extensions.junit5.annotation.MicronautTest
import io.mockk.every
import io.mockk.mockk
import io.mockk.verify
import org.apache.poi.xssf.usermodel.XSSFWorkbook
import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.DisplayName
import org.junit.jupiter.api.Test
import java.io.ByteArrayInputStream
import java.io.ByteArrayOutputStream
import java.time.LocalDateTime

/**
 * Unit test for VulnerabilityImportService
 *
 * Tests Excel parsing logic in isolation using mocks:
 * - Header validation
 * - Row parsing (valid, invalid, empty cells)
 * - File format validation
 * - Error handling and skipped rows tracking
 *
 * Related to: Feature 003-i-want-to (Vulnerability Management System)
 */
@MicronautTest
class VulnerabilityImportServiceTest {

    private lateinit var vulnerabilityRepository: VulnerabilityRepository
    private lateinit var assetMergeService: AssetMergeService
    private lateinit var service: VulnerabilityImportService

    @BeforeEach
    fun setup() {
        vulnerabilityRepository = mockk()
        assetMergeService = mockk()
        service = VulnerabilityImportService(vulnerabilityRepository, assetMergeService)
    }

    @Test
    @DisplayName("Import valid Excel file should parse all rows successfully")
    fun testImportValidFile() {
        // Create valid Excel file
        val xlsxFile = createValidExcel()
        val scanDate = LocalDateTime.now()

        // Mock asset merge service
        val mockAsset = Asset(name = "server1.example.com", owner = "Security Team", type = "Server")
        mockAsset.id = 1L
        mockAsset.createdAt = LocalDateTime.now().minusMinutes(2) // Not newly created
        every { assetMergeService.findOrCreateAsset(any(), any(), any(), any(), any(), any(), any()) } returns mockAsset

        // Mock repository save
        every { vulnerabilityRepository.saveAll(any<Iterable<Vulnerability>>()) } answers {
            val vulns = firstArg<Iterable<Vulnerability>>()
            vulns.map { vuln ->
                vuln.id = 1L
                vuln
            }
        }

        // Import
        val response = service.importFromExcel(ByteArrayInputStream(xlsxFile), scanDate)

        // Verify
        assertEquals(2, response.imported)
        assertEquals(0, response.skipped)
        assertEquals(0, response.assetsCreated)
        assertTrue(response.skippedDetails.isEmpty())

        // Verify repository was called
        verify(exactly = 1) { vulnerabilityRepository.saveAll(any<Iterable<Vulnerability>>()) }
    }

    @Test
    @DisplayName("Import with missing required header should throw exception")
    fun testImportWithMissingHeader() {
        // Create Excel with missing required header
        val xlsxFile = createExcelWithMissingHeader()
        val scanDate = LocalDateTime.now()

        // Should throw exception
        val exception = assertThrows(IllegalArgumentException::class.java) {
            service.importFromExcel(ByteArrayInputStream(xlsxFile), scanDate)
        }

        assertTrue(exception.message!!.contains("Missing required headers"))
        assertTrue(exception.message!!.contains("Hostname"))
    }

    @Test
    @DisplayName("Import with invalid row should skip row and continue")
    fun testImportWithInvalidRow() {
        // Create Excel with one invalid row (missing hostname) and one valid row
        val xlsxFile = createExcelWithInvalidRow()
        val scanDate = LocalDateTime.now()

        // Mock asset merge service for valid row
        val mockAsset = Asset(name = "valid.example.com", owner = "Security Team", type = "Server")
        mockAsset.id = 1L
        mockAsset.createdAt = LocalDateTime.now().minusMinutes(2)
        every { assetMergeService.findOrCreateAsset(any(), any(), any(), any(), any(), any(), any()) } returns mockAsset

        // Mock repository save
        every { vulnerabilityRepository.saveAll(any<Iterable<Vulnerability>>()) } answers {
            val vulns = firstArg<Iterable<Vulnerability>>()
            vulns.map { vuln ->
                vuln.id = 1L
                vuln
            }
        }

        // Import
        val response = service.importFromExcel(ByteArrayInputStream(xlsxFile), scanDate)

        // Verify: 1 imported, 1 skipped
        assertEquals(1, response.imported)
        assertEquals(1, response.skipped)
        assertEquals(1, response.skippedDetails.size)
        assertTrue(response.skippedDetails.first().reason.contains("hostname"))
    }

    @Test
    @DisplayName("Import with empty cells should preserve nulls")
    fun testImportWithEmptyCells() {
        // Create Excel with empty cells
        val xlsxFile = createExcelWithEmptyCells()
        val scanDate = LocalDateTime.now()

        // Mock asset merge service - accept any parameters including nulls
        val mockAsset = Asset(name = "empty-cells.example.com", owner = "Security Team", type = "Server")
        mockAsset.id = 1L
        mockAsset.createdAt = LocalDateTime.now().minusMinutes(2)

        every {
            assetMergeService.findOrCreateAsset(
                hostname = any(),
                ip = any(),
                groups = any(),
                cloudAccountId = any(),
                cloudInstanceId = any(),
                osVersion = any(),
                adDomain = any()
            )
        } returns mockAsset

        // Mock repository save
        every { vulnerabilityRepository.saveAll(any<Iterable<Vulnerability>>()) } answers {
            val vulns = firstArg<Iterable<Vulnerability>>()
            vulns.map { vuln ->
                vuln.id = 1L
                vuln
            }
        }

        // Import
        val response = service.importFromExcel(ByteArrayInputStream(xlsxFile), scanDate)

        // Verify import succeeded
        assertEquals(1, response.imported)

        // Verify findOrCreateAsset was called with the hostname
        verify {
            assetMergeService.findOrCreateAsset(
                hostname = "empty-cells.example.com",
                ip = any(),
                groups = any(),
                cloudAccountId = any(),
                cloudInstanceId = any(),
                osVersion = any(),
                adDomain = any()
            )
        }
    }

    @Test
    @DisplayName("Import with newly created asset should track in assetsCreated count")
    fun testImportWithNewAsset() {
        // Create valid Excel file
        val xlsxFile = createValidExcel()
        val scanDate = LocalDateTime.now()

        // Mock asset merge service to return newly created asset
        val mockAsset = Asset(name = "server1.example.com", owner = "Security Team", type = "Server")
        mockAsset.id = 1L
        mockAsset.createdAt = LocalDateTime.now() // Newly created (within last minute)
        every { assetMergeService.findOrCreateAsset(any(), any(), any(), any(), any(), any(), any()) } returns mockAsset

        // Mock repository save
        every { vulnerabilityRepository.saveAll(any<Iterable<Vulnerability>>()) } answers {
            val vulns = firstArg<Iterable<Vulnerability>>()
            vulns.map { vuln ->
                vuln.id = 1L
                vuln
            }
        }

        // Import
        val response = service.importFromExcel(ByteArrayInputStream(xlsxFile), scanDate)

        // Verify assetsCreated tracked
        assertEquals(2, response.imported)
        assertEquals(1, response.assetsCreated) // Only server1 counted (both rows are server1)
    }

    @Test
    @DisplayName("Import empty file should return error")
    fun testImportEmptyFile() {
        // Create Excel with no sheets
        val workbook = XSSFWorkbook()
        val outputStream = ByteArrayOutputStream()
        workbook.write(outputStream)
        workbook.close()

        val scanDate = LocalDateTime.now()

        // Should throw exception
        val exception = assertThrows(IllegalArgumentException::class.java) {
            service.importFromExcel(ByteArrayInputStream(outputStream.toByteArray()), scanDate)
        }

        assertTrue(exception.message!!.contains("no sheets"))
    }

    @Test
    @DisplayName("Import file with formula cells should evaluate formulas")
    fun testImportWithFormulaCells() {
        // Create Excel with formula cell
        val xlsxFile = createExcelWithFormula()
        val scanDate = LocalDateTime.now()

        // Mock asset merge service
        val mockAsset = Asset(name = "formula-test.example.com", owner = "Security Team", type = "Server")
        mockAsset.id = 1L
        mockAsset.createdAt = LocalDateTime.now().minusMinutes(2)
        every { assetMergeService.findOrCreateAsset(any(), any(), any(), any(), any(), any(), any()) } returns mockAsset

        // Mock repository save
        every { vulnerabilityRepository.saveAll(any<Iterable<Vulnerability>>()) } answers {
            val vulns = firstArg<Iterable<Vulnerability>>()
            vulns.map { vuln ->
                vuln.id = 1L
                vuln
            }
        }

        // Import (should not fail)
        val response = service.importFromExcel(ByteArrayInputStream(xlsxFile), scanDate)

        // Verify successful import
        assertEquals(1, response.imported)
    }

    /**
     * Create valid Excel file with 2 vulnerabilities
     */
    private fun createValidExcel(): ByteArray {
        val workbook = XSSFWorkbook()
        val sheet = workbook.createSheet("Sheet1")

        // Header row
        val headerRow = sheet.createRow(0)
        listOf(
            "Hostname", "Local IP", "Host groups", "Cloud service account ID",
            "Cloud service instance ID", "OS version", "Active Directory domain",
            "Vulnerability ID", "CVSS severity", "Vulnerable product versions", "Days open"
        ).forEachIndexed { index, header ->
            headerRow.createCell(index).setCellValue(header)
        }

        // Data rows
        val row1 = sheet.createRow(1)
        row1.createCell(0).setCellValue("server1.example.com")
        row1.createCell(1).setCellValue("10.0.0.1")
        row1.createCell(7).setCellValue("CVE-2024-0001")
        row1.createCell(8).setCellValue("9.8 Critical")

        val row2 = sheet.createRow(2)
        row2.createCell(0).setCellValue("server1.example.com")
        row2.createCell(1).setCellValue("10.0.0.1")
        row2.createCell(7).setCellValue("CVE-2024-0002")
        row2.createCell(8).setCellValue("7.5 High")

        val outputStream = ByteArrayOutputStream()
        workbook.write(outputStream)
        workbook.close()

        return outputStream.toByteArray()
    }

    /**
     * Create Excel with missing required header
     */
    private fun createExcelWithMissingHeader(): ByteArray {
        val workbook = XSSFWorkbook()
        val sheet = workbook.createSheet("Sheet1")

        // Header row - missing "Hostname"
        val headerRow = sheet.createRow(0)
        listOf(
            "Local IP", "Host groups", "Cloud service account ID",
            "Cloud service instance ID", "OS version", "Active Directory domain",
            "Vulnerability ID", "CVSS severity", "Vulnerable product versions", "Days open"
        ).forEachIndexed { index, header ->
            headerRow.createCell(index).setCellValue(header)
        }

        val outputStream = ByteArrayOutputStream()
        workbook.write(outputStream)
        workbook.close()

        return outputStream.toByteArray()
    }

    /**
     * Create Excel with one invalid row (missing hostname) and one valid row
     */
    private fun createExcelWithInvalidRow(): ByteArray {
        val workbook = XSSFWorkbook()
        val sheet = workbook.createSheet("Sheet1")

        // Header row
        val headerRow = sheet.createRow(0)
        listOf(
            "Hostname", "Local IP", "Host groups", "Cloud service account ID",
            "Cloud service instance ID", "OS version", "Active Directory domain",
            "Vulnerability ID", "CVSS severity", "Vulnerable product versions", "Days open"
        ).forEachIndexed { index, header ->
            headerRow.createCell(index).setCellValue(header)
        }

        // Invalid row - missing hostname
        val row1 = sheet.createRow(1)
        // hostname cell is empty
        row1.createCell(1).setCellValue("10.0.0.1")
        row1.createCell(7).setCellValue("CVE-2024-0001")

        // Valid row
        val row2 = sheet.createRow(2)
        row2.createCell(0).setCellValue("valid.example.com")
        row2.createCell(7).setCellValue("CVE-2024-0002")

        val outputStream = ByteArrayOutputStream()
        workbook.write(outputStream)
        workbook.close()

        return outputStream.toByteArray()
    }

    /**
     * Create Excel with empty cells
     */
    private fun createExcelWithEmptyCells(): ByteArray {
        val workbook = XSSFWorkbook()
        val sheet = workbook.createSheet("Sheet1")

        // Header row
        val headerRow = sheet.createRow(0)
        listOf(
            "Hostname", "Local IP", "Host groups", "Cloud service account ID",
            "Cloud service instance ID", "OS version", "Active Directory domain",
            "Vulnerability ID", "CVSS severity", "Vulnerable product versions", "Days open"
        ).forEachIndexed { index, header ->
            headerRow.createCell(index).setCellValue(header)
        }

        // Data row with only hostname filled
        val row1 = sheet.createRow(1)
        row1.createCell(0).setCellValue("empty-cells.example.com")
        // All other cells empty

        val outputStream = ByteArrayOutputStream()
        workbook.write(outputStream)
        workbook.close()

        return outputStream.toByteArray()
    }

    /**
     * Create Excel with formula cells
     */
    private fun createExcelWithFormula(): ByteArray {
        val workbook = XSSFWorkbook()
        val sheet = workbook.createSheet("Sheet1")

        // Header row
        val headerRow = sheet.createRow(0)
        listOf(
            "Hostname", "Local IP", "Host groups", "Cloud service account ID",
            "Cloud service instance ID", "OS version", "Active Directory domain",
            "Vulnerability ID", "CVSS severity", "Vulnerable product versions", "Days open"
        ).forEachIndexed { index, header ->
            headerRow.createCell(index).setCellValue(header)
        }

        // Data row with formula
        val row1 = sheet.createRow(1)
        row1.createCell(0).setCellValue("formula-test.example.com")
        // Create a numeric formula cell for Days open
        val formulaCell = row1.createCell(10)
        formulaCell.cellFormula = "10+20" // Simple formula that evaluates to 30

        val outputStream = ByteArrayOutputStream()
        workbook.write(outputStream)
        workbook.close()

        return outputStream.toByteArray()
    }

}
