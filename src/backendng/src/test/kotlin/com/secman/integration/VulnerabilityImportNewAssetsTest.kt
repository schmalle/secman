package com.secman.integration

import com.secman.repository.AssetRepository
import com.secman.repository.VulnerabilityRepository
import com.secman.service.AssetMergeService
import io.micronaut.http.HttpRequest
import io.micronaut.http.HttpStatus
import io.micronaut.http.client.HttpClient
import io.micronaut.http.client.annotation.Client
import io.micronaut.http.client.multipart.MultipartBody
import io.micronaut.test.extensions.junit5.annotation.MicronautTest
import jakarta.inject.Inject
import org.apache.poi.xssf.usermodel.XSSFWorkbook
import org.junit.jupiter.api.AfterEach
import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.DisplayName
import org.junit.jupiter.api.Test
import java.io.ByteArrayOutputStream
import java.time.LocalDateTime
import java.time.format.DateTimeFormatter

/**
 * Integration test: Import vulnerabilities with unknown (new) assets
 *
 * Tests:
 * - Assets are auto-created for unknown hostnames
 * - Default values are set: owner="Security Team", type="Server", description="Auto-created from vulnerability scan"
 * - Vulnerabilities are correctly linked to newly created assets
 *
 * Related to: Feature 003-i-want-to (Vulnerability Management System)
 */
@MicronautTest(transactional = false)
class VulnerabilityImportNewAssetsTest {

    @Inject
    @field:Client("/")
    lateinit var client: HttpClient

    @Inject
    lateinit var assetRepository: AssetRepository

    @Inject
    lateinit var vulnerabilityRepository: VulnerabilityRepository

    @AfterEach
    fun cleanup() {
        // Clean up test data
        vulnerabilityRepository.deleteAll()
        assetRepository.deleteAll()
    }

    @Test
    @DisplayName("Import vulnerability for unknown asset should auto-create asset with defaults")
    fun testImportWithUnknownAsset() {
        val newHostname = "new-server.example.com"
        val newIp = "10.0.0.50"

        // Verify asset doesn't exist
        assertFalse(assetRepository.findByName(newHostname).isPresent)

        // Create Excel file with vulnerability for unknown asset
        val xlsxFile = createVulnerabilityExcel(
            hostname = newHostname,
            ip = newIp,
            groups = "Production, Web Servers",
            cloudAccountId = "aws-account-123",
            cloudInstanceId = "i-0123456789abcdef",
            osVersion = "Ubuntu 22.04",
            adDomain = "corp.example.com",
            vulnerabilityId = "CVE-2024-0001",
            cvssSeverity = "9.8 Critical"
        )

        val scanDate = LocalDateTime.now().minusDays(1)
        val scanDateStr = scanDate.format(DateTimeFormatter.ISO_LOCAL_DATE_TIME)

        // Upload the file
        val body = MultipartBody.builder()
            .addPart("xlsxFile", "vulnerabilities.xlsx", xlsxFile)
            .addPart("scanDate", scanDateStr)
            .build()

        val request = HttpRequest.POST("/api/import/upload-vulnerability-xlsx", body)
            .basicAuth("admin", "admin")

        val response = client.toBlocking().exchange(request, Map::class.java)

        // Verify response
        assertEquals(HttpStatus.OK, response.status)
        val responseBody = response.body() as Map<*, *>
        assertEquals(1, responseBody["imported"])
        assertEquals(0, responseBody["skipped"])
        assertEquals(1, responseBody["assetsCreated"]) // Should create new asset

        // Verify asset was created with defaults
        val createdAsset = assetRepository.findByName(newHostname)
        assertTrue(createdAsset.isPresent)

        val asset = createdAsset.get()
        assertEquals(newHostname, asset.name)
        assertEquals(AssetMergeService.DEFAULT_OWNER, asset.owner) // "Security Team"
        assertEquals(AssetMergeService.DEFAULT_TYPE, asset.type) // "Server"
        assertEquals(AssetMergeService.DEFAULT_DESCRIPTION, asset.description) // "Auto-created from vulnerability scan"
        assertEquals(newIp, asset.ip)
        assertEquals("Production, Web Servers", asset.groups)
        assertEquals("aws-account-123", asset.cloudAccountId)
        assertEquals("i-0123456789abcdef", asset.cloudInstanceId)
        assertEquals("Ubuntu 22.04", asset.osVersion)
        assertEquals("corp.example.com", asset.adDomain)

        // Verify vulnerability is linked to new asset
        val vulnerabilities = vulnerabilityRepository.findByAssetId(asset.id!!, io.micronaut.data.model.Pageable.unpaged())
        assertEquals(1, vulnerabilities.totalSize)

        val vulnerability = vulnerabilities.content.first()
        assertEquals(asset.id, vulnerability.asset.id)
        assertEquals("CVE-2024-0001", vulnerability.vulnerabilityId)
        assertEquals("9.8 Critical", vulnerability.cvssSeverity)
        assertTrue(vulnerability.scanTimestamp.isEqual(scanDate))
    }

    @Test
    @DisplayName("Import vulnerabilities for multiple unknown assets should create all assets")
    fun testImportWithMultipleUnknownAssets() {
        // Create Excel file with vulnerabilities for 3 different unknown hosts
        val xlsxFile = createMultiHostVulnerabilitiesExcel(
            hosts = listOf(
                mapOf(
                    "hostname" to "server1.example.com",
                    "ip" to "10.0.0.1",
                    "vulnId" to "CVE-2024-0001"
                ),
                mapOf(
                    "hostname" to "server2.example.com",
                    "ip" to "10.0.0.2",
                    "vulnId" to "CVE-2024-0002"
                ),
                mapOf(
                    "hostname" to "server3.example.com",
                    "ip" to "10.0.0.3",
                    "vulnId" to "CVE-2024-0003"
                )
            )
        )

        val scanDate = LocalDateTime.now().minusDays(2)
        val scanDateStr = scanDate.format(DateTimeFormatter.ISO_LOCAL_DATE_TIME)

        // Upload the file
        val body = MultipartBody.builder()
            .addPart("xlsxFile", "vulnerabilities.xlsx", xlsxFile)
            .addPart("scanDate", scanDateStr)
            .build()

        val request = HttpRequest.POST("/api/import/upload-vulnerability-xlsx", body)
            .basicAuth("admin", "admin")

        val response = client.toBlocking().exchange(request, Map::class.java)

        // Verify response
        assertEquals(HttpStatus.OK, response.status)
        val responseBody = response.body() as Map<*, *>
        assertEquals(3, responseBody["imported"])
        assertEquals(0, responseBody["skipped"])
        assertEquals(3, responseBody["assetsCreated"]) // Should create 3 new assets

        // Verify all 3 assets were created
        assertEquals(3, assetRepository.count())

        // Verify each asset has default values
        val asset1 = assetRepository.findByName("server1.example.com").get()
        assertEquals(AssetMergeService.DEFAULT_OWNER, asset1.owner)
        assertEquals(AssetMergeService.DEFAULT_TYPE, asset1.type)
        assertEquals(AssetMergeService.DEFAULT_DESCRIPTION, asset1.description)

        val asset2 = assetRepository.findByName("server2.example.com").get()
        assertEquals(AssetMergeService.DEFAULT_OWNER, asset2.owner)

        val asset3 = assetRepository.findByName("server3.example.com").get()
        assertEquals(AssetMergeService.DEFAULT_OWNER, asset3.owner)

        // Verify each asset has exactly 1 vulnerability
        assertEquals(1, vulnerabilityRepository.countByAssetId(asset1.id!!))
        assertEquals(1, vulnerabilityRepository.countByAssetId(asset2.id!!))
        assertEquals(1, vulnerabilityRepository.countByAssetId(asset3.id!!))
    }

    @Test
    @DisplayName("Import vulnerability with minimal data should create asset with null optional fields")
    fun testImportWithMinimalData() {
        val newHostname = "minimal-server.example.com"

        // Create Excel file with only hostname (all other fields empty)
        val xlsxFile = createVulnerabilityExcel(
            hostname = newHostname,
            ip = null,
            groups = null,
            cloudAccountId = null,
            cloudInstanceId = null,
            osVersion = null,
            adDomain = null,
            vulnerabilityId = "CVE-2024-0001",
            cvssSeverity = null
        )

        val scanDate = LocalDateTime.now()
        val scanDateStr = scanDate.format(DateTimeFormatter.ISO_LOCAL_DATE_TIME)

        // Upload the file
        val body = MultipartBody.builder()
            .addPart("xlsxFile", "vulnerabilities.xlsx", xlsxFile)
            .addPart("scanDate", scanDateStr)
            .build()

        val request = HttpRequest.POST("/api/import/upload-vulnerability-xlsx", body)
            .basicAuth("admin", "admin")

        val response = client.toBlocking().exchange(request, Map::class.java)

        // Verify response
        assertEquals(HttpStatus.OK, response.status)

        // Verify asset was created with null optional fields
        val createdAsset = assetRepository.findByName(newHostname).get()
        assertEquals(newHostname, createdAsset.name)
        assertEquals(AssetMergeService.DEFAULT_OWNER, createdAsset.owner)
        assertEquals(AssetMergeService.DEFAULT_TYPE, createdAsset.type)
        assertEquals(AssetMergeService.DEFAULT_DESCRIPTION, createdAsset.description)
        assertNull(createdAsset.ip)
        assertNull(createdAsset.groups)
        assertNull(createdAsset.cloudAccountId)
        assertNull(createdAsset.cloudInstanceId)
        assertNull(createdAsset.osVersion)
        assertNull(createdAsset.adDomain)

        // Verify vulnerability was created with minimal data
        val vulnerability = vulnerabilityRepository.findByAssetId(createdAsset.id!!, io.micronaut.data.model.Pageable.unpaged()).content.first()
        assertEquals("CVE-2024-0001", vulnerability.vulnerabilityId)
        assertNull(vulnerability.cvssSeverity)
        assertNull(vulnerability.vulnerableProductVersions)
        assertNull(vulnerability.daysOpen)
    }

    /**
     * Create Excel file with single vulnerability
     */
    private fun createVulnerabilityExcel(
        hostname: String,
        ip: String?,
        groups: String?,
        cloudAccountId: String?,
        cloudInstanceId: String?,
        osVersion: String?,
        adDomain: String?,
        vulnerabilityId: String,
        cvssSeverity: String?
    ): ByteArray {
        val workbook = XSSFWorkbook()
        val sheet = workbook.createSheet("Sheet1")

        // Header row
        val headerRow = sheet.createRow(0)
        val headers = listOf(
            "Hostname", "Local IP", "Host groups", "Cloud service account ID",
            "Cloud service instance ID", "OS version", "Active Directory domain",
            "Vulnerability ID", "CVSS severity", "Vulnerable product versions", "Days open"
        )
        headers.forEachIndexed { index, header ->
            headerRow.createCell(index).setCellValue(header)
        }

        // Data row
        val dataRow = sheet.createRow(1)
        dataRow.createCell(0).setCellValue(hostname)
        ip?.let { dataRow.createCell(1).setCellValue(it) }
        groups?.let { dataRow.createCell(2).setCellValue(it) }
        cloudAccountId?.let { dataRow.createCell(3).setCellValue(it) }
        cloudInstanceId?.let { dataRow.createCell(4).setCellValue(it) }
        osVersion?.let { dataRow.createCell(5).setCellValue(it) }
        adDomain?.let { dataRow.createCell(6).setCellValue(it) }
        dataRow.createCell(7).setCellValue(vulnerabilityId)
        cvssSeverity?.let { dataRow.createCell(8).setCellValue(it) }

        val outputStream = ByteArrayOutputStream()
        workbook.write(outputStream)
        workbook.close()

        return outputStream.toByteArray()
    }

    /**
     * Create Excel file with vulnerabilities for multiple hosts
     */
    private fun createMultiHostVulnerabilitiesExcel(
        hosts: List<Map<String, String>>
    ): ByteArray {
        val workbook = XSSFWorkbook()
        val sheet = workbook.createSheet("Sheet1")

        // Header row
        val headerRow = sheet.createRow(0)
        val headers = listOf(
            "Hostname", "Local IP", "Host groups", "Cloud service account ID",
            "Cloud service instance ID", "OS version", "Active Directory domain",
            "Vulnerability ID", "CVSS severity", "Vulnerable product versions", "Days open"
        )
        headers.forEachIndexed { index, header ->
            headerRow.createCell(index).setCellValue(header)
        }

        // Data rows
        hosts.forEachIndexed { index, host ->
            val dataRow = sheet.createRow(index + 1)
            dataRow.createCell(0).setCellValue(host["hostname"])
            dataRow.createCell(1).setCellValue(host["ip"])
            dataRow.createCell(2).setCellValue("")
            dataRow.createCell(3).setCellValue("")
            dataRow.createCell(4).setCellValue("")
            dataRow.createCell(5).setCellValue("")
            dataRow.createCell(6).setCellValue("")
            dataRow.createCell(7).setCellValue(host["vulnId"])
            dataRow.createCell(8).setCellValue("")
            dataRow.createCell(9).setCellValue("")
            dataRow.createCell(10).setCellValue("")
        }

        val outputStream = ByteArrayOutputStream()
        workbook.write(outputStream)
        workbook.close()

        return outputStream.toByteArray()
    }
}
