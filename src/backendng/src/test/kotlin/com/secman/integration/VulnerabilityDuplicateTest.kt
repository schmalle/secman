package com.secman.integration

import com.secman.repository.AssetRepository
import com.secman.repository.VulnerabilityRepository
import io.micronaut.http.HttpRequest
import io.micronaut.http.HttpStatus
import io.micronaut.http.client.HttpClient
import io.micronaut.http.client.annotation.Client
import io.micronaut.http.client.multipart.MultipartBody
import io.micronaut.test.extensions.junit5.annotation.MicronautTest
import jakarta.inject.Inject
import org.apache.poi.xssf.usermodel.XSSFWorkbook
import org.junit.jupiter.api.AfterEach
import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.DisplayName
import org.junit.jupiter.api.Test
import java.io.ByteArrayOutputStream
import java.time.LocalDateTime
import java.time.format.DateTimeFormatter

/**
 * Integration test: Duplicate vulnerability handling
 *
 * Tests historical tracking of vulnerabilities:
 * - Same vulnerability imported multiple times (different scan dates) should create separate records
 * - Each vulnerability record has its own scan timestamp
 * - No deduplication occurs - all imports are kept as historical records
 *
 * Related to: Feature 003-i-want-to (Vulnerability Management System)
 */
@MicronautTest(transactional = false)
class VulnerabilityDuplicateTest {

    @Inject
    @field:Client("/")
    lateinit var client: HttpClient

    @Inject
    lateinit var assetRepository: AssetRepository

    @Inject
    lateinit var vulnerabilityRepository: VulnerabilityRepository

    @AfterEach
    fun cleanup() {
        // Clean up test data
        vulnerabilityRepository.deleteAll()
        assetRepository.deleteAll()
    }

    @Test
    @DisplayName("Import same vulnerability twice with different scan dates should create two records")
    fun testDuplicateVulnerabilityDifferentScanDates() {
        val hostname = "duplicate-test.example.com"
        val vulnerabilityId = "CVE-2024-0001"

        // First import - scan date 1 week ago
        val scanDate1 = LocalDateTime.now().minusWeeks(1)
        val xlsxFile1 = createVulnerabilityExcel(hostname, vulnerabilityId, "9.8 Critical")
        uploadFile(xlsxFile1, scanDate1)

        // Verify first vulnerability created
        val asset = assetRepository.findByName(hostname).get()
        val vulns1 = vulnerabilityRepository.findByAssetId(asset.id!!, io.micronaut.data.model.Pageable.unpaged())
        assertEquals(1, vulns1.totalSize)
        assertEquals(vulnerabilityId, vulns1.content.first().vulnerabilityId)
        assertTrue(vulns1.content.first().scanTimestamp.isEqual(scanDate1))

        // Second import - scan date today (same vulnerability)
        val scanDate2 = LocalDateTime.now()
        val xlsxFile2 = createVulnerabilityExcel(hostname, vulnerabilityId, "9.8 Critical")
        uploadFile(xlsxFile2, scanDate2)

        // Verify second vulnerability created (not deduplicated)
        val vulns2 = vulnerabilityRepository.findByAssetId(asset.id!!, io.micronaut.data.model.Pageable.unpaged())
        assertEquals(2, vulns2.totalSize) // Two separate records

        // Verify both records have same vulnerability ID but different scan timestamps
        val timestamps = vulns2.content.map { it.scanTimestamp }.sorted()
        assertEquals(2, timestamps.size)
        assertTrue(timestamps[0].isEqual(scanDate1))
        assertTrue(timestamps[1].isEqual(scanDate2))

        // Verify both have same vulnerability ID
        val vulnIds = vulns2.content.map { it.vulnerabilityId }
        assertTrue(vulnIds.all { it == vulnerabilityId })
    }

    @Test
    @DisplayName("Import same vulnerability three times should create three records")
    fun testMultipleDuplicates() {
        val hostname = "multi-duplicate.example.com"
        val vulnerabilityId = "CVE-2024-0002"

        // Import 1 - 3 weeks ago
        val scanDate1 = LocalDateTime.now().minusWeeks(3)
        uploadFile(createVulnerabilityExcel(hostname, vulnerabilityId, "7.5 High"), scanDate1)

        // Import 2 - 2 weeks ago
        val scanDate2 = LocalDateTime.now().minusWeeks(2)
        uploadFile(createVulnerabilityExcel(hostname, vulnerabilityId, "7.5 High"), scanDate2)

        // Import 3 - 1 week ago
        val scanDate3 = LocalDateTime.now().minusWeeks(1)
        uploadFile(createVulnerabilityExcel(hostname, vulnerabilityId, "7.5 High"), scanDate3)

        // Verify three separate records
        val asset = assetRepository.findByName(hostname).get()
        val vulns = vulnerabilityRepository.findByAssetId(asset.id!!, io.micronaut.data.model.Pageable.unpaged())
        assertEquals(3, vulns.totalSize)

        // Verify scan timestamps are different
        val timestamps = vulns.content.map { it.scanTimestamp }.sorted()
        assertTrue(timestamps[0].isEqual(scanDate1))
        assertTrue(timestamps[1].isEqual(scanDate2))
        assertTrue(timestamps[2].isEqual(scanDate3))

        // Verify all have same vulnerability ID
        assertTrue(vulns.content.all { it.vulnerabilityId == vulnerabilityId })
    }

    @Test
    @DisplayName("Import same scan data twice should still create duplicate records")
    fun testIdenticalImportCreatesDuplicates() {
        val hostname = "identical-import.example.com"
        val vulnerabilityId = "CVE-2024-0003"
        val scanDate = LocalDateTime.now().minusDays(5)

        // First import
        val xlsxFile1 = createVulnerabilityExcel(hostname, vulnerabilityId, "5.3 Medium")
        uploadFile(xlsxFile1, scanDate)

        // Second import - SAME scan date, SAME data
        val xlsxFile2 = createVulnerabilityExcel(hostname, vulnerabilityId, "5.3 Medium")
        uploadFile(xlsxFile2, scanDate)

        // Verify two records created (no deduplication even with same scan date)
        val asset = assetRepository.findByName(hostname).get()
        val vulns = vulnerabilityRepository.findByAssetId(asset.id!!, io.micronaut.data.model.Pageable.unpaged())
        assertEquals(2, vulns.totalSize)

        // Both should have same scan timestamp and vulnerability ID
        assertTrue(vulns.content.all { it.scanTimestamp.isEqual(scanDate) })
        assertTrue(vulns.content.all { it.vulnerabilityId == vulnerabilityId })
    }

    @Test
    @DisplayName("Import vulnerability with different severity should create new record")
    fun testDuplicateWithDifferentSeverity() {
        val hostname = "severity-change.example.com"
        val vulnerabilityId = "CVE-2024-0004"

        // First import - Critical severity
        val scanDate1 = LocalDateTime.now().minusDays(10)
        uploadFile(createVulnerabilityExcel(hostname, vulnerabilityId, "9.8 Critical"), scanDate1)

        // Second import - High severity (severity changed, maybe re-scored)
        val scanDate2 = LocalDateTime.now()
        uploadFile(createVulnerabilityExcel(hostname, vulnerabilityId, "7.5 High"), scanDate2)

        // Verify two records with different severities
        val asset = assetRepository.findByName(hostname).get()
        val vulns = vulnerabilityRepository.findByAssetId(asset.id!!, io.micronaut.data.model.Pageable.unpaged())
        assertEquals(2, vulns.totalSize)

        val severities = vulns.content.map { it.cvssSeverity }.toSet()
        assertEquals(2, severities.size)
        assertTrue(severities.contains("9.8 Critical"))
        assertTrue(severities.contains("7.5 High"))
    }

    @Test
    @DisplayName("Import multiple vulnerabilities where some are duplicates")
    fun testMixedDuplicatesAndNew() {
        val hostname = "mixed-duplicates.example.com"

        // First import - CVE-0001 and CVE-0002
        val scanDate1 = LocalDateTime.now().minusDays(7)
        val xlsxFile1 = createMultipleVulnerabilitiesExcel(
            hostname,
            listOf(
                mapOf("id" to "CVE-2024-0001", "severity" to "9.8 Critical"),
                mapOf("id" to "CVE-2024-0002", "severity" to "7.5 High")
            )
        )
        uploadFile(xlsxFile1, scanDate1)

        // Verify 2 vulnerabilities
        val asset = assetRepository.findByName(hostname).get()
        assertEquals(2, vulnerabilityRepository.countByAssetId(asset.id!!))

        // Second import - CVE-0001 (duplicate), CVE-0003 (new)
        val scanDate2 = LocalDateTime.now()
        val xlsxFile2 = createMultipleVulnerabilitiesExcel(
            hostname,
            listOf(
                mapOf("id" to "CVE-2024-0001", "severity" to "9.8 Critical"), // Duplicate
                mapOf("id" to "CVE-2024-0003", "severity" to "5.3 Medium") // New
            )
        )
        uploadFile(xlsxFile2, scanDate2)

        // Verify 4 total vulnerabilities (2 + 2, no deduplication)
        assertEquals(4, vulnerabilityRepository.countByAssetId(asset.id!!))

        // Verify CVE-0001 appears twice
        val allVulns = vulnerabilityRepository.findByAssetId(asset.id!!, io.micronaut.data.model.Pageable.unpaged())
        val cve0001Count = allVulns.content.count { it.vulnerabilityId == "CVE-2024-0001" }
        assertEquals(2, cve0001Count)

        // Verify unique vulnerability IDs
        val uniqueVulnIds = allVulns.content.map { it.vulnerabilityId }.toSet()
        assertEquals(3, uniqueVulnIds.size) // CVE-0001, CVE-0002, CVE-0003
    }

    @Test
    @DisplayName("Query vulnerabilities by scan date range returns correct records")
    fun testQueryByDateRange() {
        val hostname = "date-range-query.example.com"
        val vulnerabilityId = "CVE-2024-0005"

        // Import at 3 different dates
        val scanDate1 = LocalDateTime.now().minusDays(30) // 30 days ago
        uploadFile(createVulnerabilityExcel(hostname, vulnerabilityId, "Critical"), scanDate1)

        val scanDate2 = LocalDateTime.now().minusDays(15) // 15 days ago
        uploadFile(createVulnerabilityExcel(hostname, vulnerabilityId, "Critical"), scanDate2)

        val scanDate3 = LocalDateTime.now().minusDays(5) // 5 days ago
        uploadFile(createVulnerabilityExcel(hostname, vulnerabilityId, "Critical"), scanDate3)

        val asset = assetRepository.findByName(hostname).get()

        // Query for vulnerabilities between 20 days ago and 10 days ago
        val startDate = LocalDateTime.now().minusDays(20)
        val endDate = LocalDateTime.now().minusDays(10)
        val vulnsInRange = vulnerabilityRepository.findByAssetIdAndScanTimestampBetween(
            asset.id!!,
            startDate,
            endDate,
            io.micronaut.data.model.Sort.of(io.micronaut.data.model.Sort.Order.desc("scanTimestamp"))
        )

        // Should only return the middle record (15 days ago)
        assertEquals(1, vulnsInRange.size)
        assertTrue(vulnsInRange.first().scanTimestamp.isEqual(scanDate2))
    }

    /**
     * Upload vulnerability Excel file with specific scan date
     */
    private fun uploadFile(xlsxFile: ByteArray, scanDate: LocalDateTime) {
        val scanDateStr = scanDate.format(DateTimeFormatter.ISO_LOCAL_DATE_TIME)

        val body = MultipartBody.builder()
            .addPart("xlsxFile", "vulnerabilities.xlsx", xlsxFile)
            .addPart("scanDate", scanDateStr)
            .build()

        val request = HttpRequest.POST("/api/import/upload-vulnerability-xlsx", body)
            .basicAuth("admin", "admin")

        val response = client.toBlocking().exchange(request, Map::class.java)
        assertEquals(HttpStatus.OK, response.status)
    }

    /**
     * Create Excel file with single vulnerability
     */
    private fun createVulnerabilityExcel(
        hostname: String,
        vulnerabilityId: String,
        cvssSeverity: String
    ): ByteArray {
        val workbook = XSSFWorkbook()
        val sheet = workbook.createSheet("Sheet1")

        // Header row
        val headerRow = sheet.createRow(0)
        val headers = listOf(
            "Hostname", "Local IP", "Host groups", "Cloud service account ID",
            "Cloud service instance ID", "OS version", "Active Directory domain",
            "Vulnerability ID", "CVSS severity", "Vulnerable product versions", "Days open"
        )
        headers.forEachIndexed { index, header ->
            headerRow.createCell(index).setCellValue(header)
        }

        // Data row
        val dataRow = sheet.createRow(1)
        dataRow.createCell(0).setCellValue(hostname)
        dataRow.createCell(7).setCellValue(vulnerabilityId)
        dataRow.createCell(8).setCellValue(cvssSeverity)

        val outputStream = ByteArrayOutputStream()
        workbook.write(outputStream)
        workbook.close()

        return outputStream.toByteArray()
    }

    /**
     * Create Excel file with multiple vulnerabilities
     */
    private fun createMultipleVulnerabilitiesExcel(
        hostname: String,
        vulnerabilities: List<Map<String, String>>
    ): ByteArray {
        val workbook = XSSFWorkbook()
        val sheet = workbook.createSheet("Sheet1")

        // Header row
        val headerRow = sheet.createRow(0)
        val headers = listOf(
            "Hostname", "Local IP", "Host groups", "Cloud service account ID",
            "Cloud service instance ID", "OS version", "Active Directory domain",
            "Vulnerability ID", "CVSS severity", "Vulnerable product versions", "Days open"
        )
        headers.forEachIndexed { index, header ->
            headerRow.createCell(index).setCellValue(header)
        }

        // Data rows
        vulnerabilities.forEachIndexed { index, vuln ->
            val dataRow = sheet.createRow(index + 1)
            dataRow.createCell(0).setCellValue(hostname)
            dataRow.createCell(7).setCellValue(vuln["id"])
            dataRow.createCell(8).setCellValue(vuln["severity"])
        }

        val outputStream = ByteArrayOutputStream()
        workbook.write(outputStream)
        workbook.close()

        return outputStream.toByteArray()
    }
}
