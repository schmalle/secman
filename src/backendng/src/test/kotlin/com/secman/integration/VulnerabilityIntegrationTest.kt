package com.secman.integration

import com.secman.domain.User
import com.secman.dto.AddVulnerabilityRequestDto
import com.secman.dto.AddVulnerabilityResponseDto
import com.secman.repository.AssetRepository
import com.secman.repository.UserRepository
import com.secman.repository.VulnerabilityRepository
import com.secman.testutil.BaseIntegrationTest
import com.secman.testutil.TestAuthHelper
import com.secman.testutil.TestDataFactory
import io.micronaut.http.HttpRequest
import io.micronaut.http.HttpStatus
import io.micronaut.http.client.HttpClient
import io.micronaut.http.client.annotation.Client
import io.micronaut.http.client.exceptions.HttpClientResponseException
import jakarta.inject.Inject
import org.assertj.core.api.Assertions.assertThat
import org.junit.jupiter.api.*
import org.junit.jupiter.api.condition.EnabledIf
import java.time.LocalDateTime
import java.time.temporal.ChronoUnit

/**
 * Integration tests for CLI add-vulnerability endpoint.
 * Feature: 056-test-suite (User Story 1 - P1)
 *
 * Tests the full flow with real database via Testcontainers:
 * - Asset auto-creation
 * - Vulnerability persistence
 * - RBAC enforcement
 */
@DisplayName("CLI Add Vulnerability Integration Tests")
@EnabledIf("com.secman.testutil.DockerAvailable#isDockerAvailable")
class VulnerabilityIntegrationTest : BaseIntegrationTest() {

    @Inject
    @field:Client("/")
    lateinit var client: HttpClient

    @Inject
    lateinit var userRepository: UserRepository

    @Inject
    lateinit var assetRepository: AssetRepository

    @Inject
    lateinit var vulnerabilityRepository: VulnerabilityRepository

    private lateinit var adminUser: User
    private lateinit var vulnUser: User
    private lateinit var regularUser: User

    @BeforeEach
    fun setupTestUsers() {
        // Create test users for each test
        adminUser = userRepository.save(TestDataFactory.createAdminUser(
            username = "integ-admin-${System.nanoTime()}",
            email = "integ-admin-${System.nanoTime()}@test.com"
        ))
        vulnUser = userRepository.save(TestDataFactory.createVulnUser(
            username = "integ-vuln-${System.nanoTime()}",
            email = "integ-vuln-${System.nanoTime()}@test.com"
        ))
        regularUser = userRepository.save(TestDataFactory.createRegularUser(
            username = "integ-user-${System.nanoTime()}",
            email = "integ-user-${System.nanoTime()}@test.com"
        ))
    }

    @Nested
    @DisplayName("CLI Add Vulnerability - Primary Test Case")
    inner class PrimaryTestCaseTests {

        @Test
        @DisplayName("VI-001: Add vulnerability for system-a with HIGH criticality and 60 days open")
        fun `cliAddVulnerability_systemA_high_60days`() {
            // Given: Admin user authenticated
            val token = TestAuthHelper.getAuthToken(client, adminUser.username)
            val hostname = "system-a-${System.nanoTime()}"

            val request = AddVulnerabilityRequestDto(
                hostname = hostname,
                cve = "CVE-2024-TEST001",
                criticality = "HIGH",
                daysOpen = 60
            )

            // When: POST to cli-add endpoint
            val httpRequest = HttpRequest.POST("/api/vulnerabilities/cli-add", request)
                .bearerAuth(token)

            val response = client.toBlocking().exchange(httpRequest, AddVulnerabilityResponseDto::class.java)

            // Then: HTTP 200 and success response
            assertThat(response.status).isEqualTo(HttpStatus.OK)
            val body = response.body()!!
            assertThat(body.success).isTrue()
            assertThat(body.assetName).isEqualTo(hostname)
            assertThat(body.vulnerabilityId).isEqualTo("CVE-2024-TEST001")
            assertThat(body.assetCreated).isTrue()
            assertThat(body.operation).isEqualTo("CREATED")

            // Verify asset in database
            val asset = assetRepository.findByNameIgnoreCase(hostname)
            assertThat(asset).isNotNull
            assertThat(asset!!.type).isEqualTo("SERVER")
            assertThat(asset.owner).isEqualTo("CLI-IMPORT")

            // Verify vulnerability in database
            val vuln = vulnerabilityRepository.findByAssetAndVulnerabilityId(asset, "CVE-2024-TEST001")
            assertThat(vuln).isNotNull
            assertThat(vuln!!.cvssSeverity).isEqualTo("High")
            assertThat(vuln.daysOpen).isEqualTo("60 days")

            // Verify scanTimestamp is approximately 60 days ago
            val expectedTimestamp = LocalDateTime.now().minusDays(60)
            assertThat(vuln.scanTimestamp)
                .isCloseTo(expectedTimestamp, org.assertj.core.api.Assertions.within(1, ChronoUnit.MINUTES))
        }

        @Test
        @DisplayName("VI-002: Add vulnerability to existing asset")
        fun `cliAddVulnerability_addsToExistingAsset`() {
            // Given: Existing asset with one vulnerability
            val token = TestAuthHelper.getAuthToken(client, adminUser.username)
            val hostname = "existing-system-${System.nanoTime()}"

            // First, add an initial vulnerability (creates the asset)
            val firstRequest = AddVulnerabilityRequestDto(
                hostname = hostname,
                cve = "CVE-2024-FIRST",
                criticality = "MEDIUM",
                daysOpen = 30
            )
            client.toBlocking().exchange(
                HttpRequest.POST("/api/vulnerabilities/cli-add", firstRequest).bearerAuth(token),
                AddVulnerabilityResponseDto::class.java
            )

            val assetCountBefore = assetRepository.count()
            val vulnCountBefore = vulnerabilityRepository.count()

            // When: Add second vulnerability to same hostname
            val secondRequest = AddVulnerabilityRequestDto(
                hostname = hostname,
                cve = "CVE-2024-SECOND",
                criticality = "HIGH",
                daysOpen = 45
            )
            val response = client.toBlocking().exchange(
                HttpRequest.POST("/api/vulnerabilities/cli-add", secondRequest).bearerAuth(token),
                AddVulnerabilityResponseDto::class.java
            )

            // Then: Asset count unchanged, vuln count increased by 1
            assertThat(response.status).isEqualTo(HttpStatus.OK)
            val body = response.body()!!
            assertThat(body.assetCreated).isFalse()
            assertThat(body.operation).isEqualTo("CREATED")

            assertThat(assetRepository.count()).isEqualTo(assetCountBefore)
            assertThat(vulnerabilityRepository.count()).isEqualTo(vulnCountBefore + 1)

            // Verify both vulnerabilities exist for the asset
            val asset = assetRepository.findByNameIgnoreCase(hostname)!!
            val firstVuln = vulnerabilityRepository.findByAssetAndVulnerabilityId(asset, "CVE-2024-FIRST")
            val secondVuln = vulnerabilityRepository.findByAssetAndVulnerabilityId(asset, "CVE-2024-SECOND")
            assertThat(firstVuln).isNotNull
            assertThat(secondVuln).isNotNull
        }
    }

    @Nested
    @DisplayName("Web API Query Tests")
    inner class WebApiQueryTests {

        @Test
        @DisplayName("VI-003: getCurrentVulnerabilities returns added vulnerability")
        fun `getCurrentVulnerabilities_returnsAddedVuln`() {
            // Given: A vulnerability added via CLI
            val token = TestAuthHelper.getAuthToken(client, adminUser.username)
            val hostname = "query-test-${System.nanoTime()}"
            val cve = "CVE-2024-QUERY${System.nanoTime()}"

            val addRequest = AddVulnerabilityRequestDto(
                hostname = hostname,
                cve = cve,
                criticality = "HIGH",
                daysOpen = 30
            )
            client.toBlocking().exchange(
                HttpRequest.POST("/api/vulnerabilities/cli-add", addRequest).bearerAuth(token),
                AddVulnerabilityResponseDto::class.java
            )

            // When: Query current vulnerabilities
            val response = client.toBlocking().exchange(
                HttpRequest.GET<Any>("/api/vulnerabilities/current").bearerAuth(token),
                String::class.java
            )

            // Then: Response contains the added vulnerability
            assertThat(response.status).isEqualTo(HttpStatus.OK)
            val body = response.body()!!
            assertThat(body).contains(cve)
            assertThat(body).contains(hostname)
        }
    }

    @Nested
    @DisplayName("RBAC Tests")
    inner class RbacTests {

        @Test
        @DisplayName("VI-004: Admin can add vulnerability")
        fun `rbac_adminCanAddVuln`() {
            val token = TestAuthHelper.getAuthToken(client, adminUser.username)
            val hostname = "rbac-admin-${System.nanoTime()}"

            val request = AddVulnerabilityRequestDto(
                hostname = hostname,
                cve = "CVE-2024-ADMIN",
                criticality = "LOW",
                daysOpen = 10
            )

            val response = client.toBlocking().exchange(
                HttpRequest.POST("/api/vulnerabilities/cli-add", request).bearerAuth(token),
                AddVulnerabilityResponseDto::class.java
            )

            assertThat(response.status).isEqualTo(HttpStatus.OK)
        }

        @Test
        @DisplayName("VI-005: VULN role can add vulnerability")
        fun `rbac_vulnRoleCanAddVuln`() {
            val token = TestAuthHelper.getAuthToken(client, vulnUser.username)
            val hostname = "rbac-vuln-${System.nanoTime()}"

            val request = AddVulnerabilityRequestDto(
                hostname = hostname,
                cve = "CVE-2024-VULN",
                criticality = "MEDIUM",
                daysOpen = 20
            )

            val response = client.toBlocking().exchange(
                HttpRequest.POST("/api/vulnerabilities/cli-add", request).bearerAuth(token),
                AddVulnerabilityResponseDto::class.java
            )

            assertThat(response.status).isEqualTo(HttpStatus.OK)
        }

        @Test
        @DisplayName("VI-006: Regular USER cannot add vulnerability (HTTP 403)")
        fun `rbac_userCannotAddVuln`() {
            val token = TestAuthHelper.getAuthToken(client, regularUser.username)
            val hostname = "rbac-user-${System.nanoTime()}"

            val request = AddVulnerabilityRequestDto(
                hostname = hostname,
                cve = "CVE-2024-USER",
                criticality = "HIGH",
                daysOpen = 30
            )

            val exception = assertThrows<HttpClientResponseException> {
                client.toBlocking().exchange(
                    HttpRequest.POST("/api/vulnerabilities/cli-add", request).bearerAuth(token),
                    AddVulnerabilityResponseDto::class.java
                )
            }

            assertThat(exception.status).isEqualTo(HttpStatus.FORBIDDEN)
        }

        @Test
        @DisplayName("VI-007: Unauthenticated request denied (HTTP 401)")
        fun `rbac_unauthenticatedDenied`() {
            val request = AddVulnerabilityRequestDto(
                hostname = "unauth-system",
                cve = "CVE-2024-UNAUTH",
                criticality = "HIGH",
                daysOpen = 30
            )

            val exception = assertThrows<HttpClientResponseException> {
                client.toBlocking().exchange(
                    HttpRequest.POST("/api/vulnerabilities/cli-add", request),
                    AddVulnerabilityResponseDto::class.java
                )
            }

            assertThat(exception.status).isEqualTo(HttpStatus.UNAUTHORIZED)
        }
    }
}
