package com.secman.integration

import com.secman.repository.AssetRepository
import com.secman.repository.VulnerabilityRepository
import io.micronaut.http.HttpRequest
import io.micronaut.http.HttpStatus
import io.micronaut.http.client.HttpClient
import io.micronaut.http.client.annotation.Client
import io.micronaut.http.client.multipart.MultipartBody
import io.micronaut.test.extensions.junit5.annotation.MicronautTest
import jakarta.inject.Inject
import org.apache.poi.xssf.usermodel.XSSFWorkbook
import org.junit.jupiter.api.AfterEach
import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.DisplayName
import org.junit.jupiter.api.Test
import java.io.ByteArrayOutputStream
import java.time.LocalDateTime
import java.time.format.DateTimeFormatter

/**
 * Integration test: Import vulnerabilities with empty/null fields
 *
 * Tests:
 * - Empty cells are preserved as null in database
 * - Import succeeds even with minimal data
 * - Only hostname is truly required
 *
 * Related to: Feature 003-i-want-to (Vulnerability Management System)
 */
@MicronautTest(transactional = false)
class VulnerabilityImportEmptyFieldsTest {

    @Inject
    @field:Client("/")
    lateinit var client: HttpClient

    @Inject
    lateinit var assetRepository: AssetRepository

    @Inject
    lateinit var vulnerabilityRepository: VulnerabilityRepository

    @AfterEach
    fun cleanup() {
        // Clean up test data
        vulnerabilityRepository.deleteAll()
        assetRepository.deleteAll()
    }

    @Test
    @DisplayName("Import with all optional fields empty should preserve nulls")
    fun testImportWithAllEmptyFields() {
        val hostname = "empty-fields.example.com"

        // Create Excel with only hostname filled
        val xlsxFile = createExcelWithEmptyFields(hostname)

        val scanDate = LocalDateTime.now()
        val scanDateStr = scanDate.format(DateTimeFormatter.ISO_LOCAL_DATE_TIME)

        // Upload the file
        val body = MultipartBody.builder()
            .addPart("xlsxFile", "vulnerabilities.xlsx", xlsxFile)
            .addPart("scanDate", scanDateStr)
            .build()

        val request = HttpRequest.POST("/api/import/upload-vulnerability-xlsx", body)
            .basicAuth("admin", "admin")

        val response = client.toBlocking().exchange(request, Map::class.java)

        // Verify response
        assertEquals(HttpStatus.OK, response.status)
        val responseBody = response.body() as Map<*, *>
        assertEquals(1, responseBody["imported"])

        // Verify asset created with nulls
        val asset = assetRepository.findByName(hostname).get()
        assertNull(asset.ip)
        assertNull(asset.groups)
        assertNull(asset.cloudAccountId)
        assertNull(asset.cloudInstanceId)
        assertNull(asset.osVersion)
        assertNull(asset.adDomain)

        // Verify vulnerability created with nulls
        val vulnerability = vulnerabilityRepository.findByAssetId(asset.id!!, io.micronaut.data.model.Pageable.unpaged()).content.first()
        assertNull(vulnerability.vulnerabilityId)
        assertNull(vulnerability.cvssSeverity)
        assertNull(vulnerability.vulnerableProductVersions)
        assertNull(vulnerability.daysOpen)
        assertNotNull(vulnerability.scanTimestamp) // Scan timestamp always set
    }

    @Test
    @DisplayName("Import with mix of empty and filled fields")
    fun testImportWithMixedEmptyFields() {
        val hostname = "mixed-fields.example.com"

        // Create Excel with some fields filled, some empty
        val xlsxFile = createExcelWithMixedFields(
            hostname = hostname,
            ip = "10.0.0.100",
            groups = null, // Empty
            cloudAccountId = "aws-123",
            cloudInstanceId = null, // Empty
            osVersion = "Ubuntu 22.04",
            adDomain = null, // Empty
            vulnerabilityId = "CVE-2024-0001",
            cvssSeverity = null, // Empty
            vulnerableProductVersions = "Apache 2.4.0-2.4.50",
            daysOpen = null // Empty
        )

        val scanDate = LocalDateTime.now()
        val scanDateStr = scanDate.format(DateTimeFormatter.ISO_LOCAL_DATE_TIME)

        // Upload the file
        val body = MultipartBody.builder()
            .addPart("xlsxFile", "vulnerabilities.xlsx", xlsxFile)
            .addPart("scanDate", scanDateStr)
            .build()

        val request = HttpRequest.POST("/api/import/upload-vulnerability-xlsx", body)
            .basicAuth("admin", "admin")

        val response = client.toBlocking().exchange(request, Map::class.java)

        // Verify response
        assertEquals(HttpStatus.OK, response.status)

        // Verify asset has filled and null fields
        val asset = assetRepository.findByName(hostname).get()
        assertEquals("10.0.0.100", asset.ip) // Filled
        assertNull(asset.groups) // Empty
        assertEquals("aws-123", asset.cloudAccountId) // Filled
        assertNull(asset.cloudInstanceId) // Empty
        assertEquals("Ubuntu 22.04", asset.osVersion) // Filled
        assertNull(asset.adDomain) // Empty

        // Verify vulnerability has filled and null fields
        val vulnerability = vulnerabilityRepository.findByAssetId(asset.id!!, io.micronaut.data.model.Pageable.unpaged()).content.first()
        assertEquals("CVE-2024-0001", vulnerability.vulnerabilityId) // Filled
        assertNull(vulnerability.cvssSeverity) // Empty
        assertEquals("Apache 2.4.0-2.4.50", vulnerability.vulnerableProductVersions) // Filled
        assertNull(vulnerability.daysOpen) // Empty
    }

    @Test
    @DisplayName("Import with whitespace-only fields should treat as empty")
    fun testImportWithWhitespaceFields() {
        val hostname = "whitespace-fields.example.com"

        // Create Excel with whitespace-only fields
        val xlsxFile = createExcelWithWhitespaceFields(hostname)

        val scanDate = LocalDateTime.now()
        val scanDateStr = scanDate.format(DateTimeFormatter.ISO_LOCAL_DATE_TIME)

        // Upload the file
        val body = MultipartBody.builder()
            .addPart("xlsxFile", "vulnerabilities.xlsx", xlsxFile)
            .addPart("scanDate", scanDateStr)
            .build()

        val request = HttpRequest.POST("/api/import/upload-vulnerability-xlsx", body)
            .basicAuth("admin", "admin")

        val response = client.toBlocking().exchange(request, Map::class.java)

        // Verify response
        assertEquals(HttpStatus.OK, response.status)

        // Verify whitespace fields are treated as null
        val asset = assetRepository.findByName(hostname).get()
        assertNull(asset.ip) // Whitespace → null
        assertNull(asset.groups) // Whitespace → null
        assertNull(asset.cloudAccountId) // Whitespace → null

        val vulnerability = vulnerabilityRepository.findByAssetId(asset.id!!, io.micronaut.data.model.Pageable.unpaged()).content.first()
        assertNull(vulnerability.vulnerabilityId) // Whitespace → null
        assertNull(vulnerability.cvssSeverity) // Whitespace → null
    }

    @Test
    @DisplayName("Import multiple rows with varying empty fields")
    fun testImportMultipleRowsWithVaryingEmptyFields() {
        // Create Excel with 3 rows, each with different fields empty
        val xlsxFile = createExcelWithVaryingEmptyFields()

        val scanDate = LocalDateTime.now()
        val scanDateStr = scanDate.format(DateTimeFormatter.ISO_LOCAL_DATE_TIME)

        // Upload the file
        val body = MultipartBody.builder()
            .addPart("xlsxFile", "vulnerabilities.xlsx", xlsxFile)
            .addPart("scanDate", scanDateStr)
            .build()

        val request = HttpRequest.POST("/api/import/upload-vulnerability-xlsx", body)
            .basicAuth("admin", "admin")

        val response = client.toBlocking().exchange(request, Map::class.java)

        // Verify response
        assertEquals(HttpStatus.OK, response.status)
        val responseBody = response.body() as Map<*, *>
        assertEquals(3, responseBody["imported"])
        assertEquals(3, responseBody["assetsCreated"])

        // Verify each asset has correct null/filled pattern
        val asset1 = assetRepository.findByName("host1.example.com").get()
        assertNotNull(asset1.ip)
        assertNull(asset1.groups)

        val asset2 = assetRepository.findByName("host2.example.com").get()
        assertNull(asset2.ip)
        assertNotNull(asset2.groups)

        val asset3 = assetRepository.findByName("host3.example.com").get()
        assertNull(asset3.ip)
        assertNull(asset3.groups)
    }

    /**
     * Create Excel with all optional fields empty
     */
    private fun createExcelWithEmptyFields(hostname: String): ByteArray {
        val workbook = XSSFWorkbook()
        val sheet = workbook.createSheet("Sheet1")

        // Header row
        val headerRow = sheet.createRow(0)
        val headers = listOf(
            "Hostname", "Local IP", "Host groups", "Cloud service account ID",
            "Cloud service instance ID", "OS version", "Active Directory domain",
            "Vulnerability ID", "CVSS severity", "Vulnerable product versions", "Days open"
        )
        headers.forEachIndexed { index, header ->
            headerRow.createCell(index).setCellValue(header)
        }

        // Data row - only hostname filled
        val dataRow = sheet.createRow(1)
        dataRow.createCell(0).setCellValue(hostname)
        // All other cells left empty (null)

        val outputStream = ByteArrayOutputStream()
        workbook.write(outputStream)
        workbook.close()

        return outputStream.toByteArray()
    }

    /**
     * Create Excel with mix of filled and empty fields
     */
    private fun createExcelWithMixedFields(
        hostname: String,
        ip: String?,
        groups: String?,
        cloudAccountId: String?,
        cloudInstanceId: String?,
        osVersion: String?,
        adDomain: String?,
        vulnerabilityId: String?,
        cvssSeverity: String?,
        vulnerableProductVersions: String?,
        daysOpen: String?
    ): ByteArray {
        val workbook = XSSFWorkbook()
        val sheet = workbook.createSheet("Sheet1")

        // Header row
        val headerRow = sheet.createRow(0)
        val headers = listOf(
            "Hostname", "Local IP", "Host groups", "Cloud service account ID",
            "Cloud service instance ID", "OS version", "Active Directory domain",
            "Vulnerability ID", "CVSS severity", "Vulnerable product versions", "Days open"
        )
        headers.forEachIndexed { index, header ->
            headerRow.createCell(index).setCellValue(header)
        }

        // Data row
        val dataRow = sheet.createRow(1)
        dataRow.createCell(0).setCellValue(hostname)
        ip?.let { dataRow.createCell(1).setCellValue(it) }
        groups?.let { dataRow.createCell(2).setCellValue(it) }
        cloudAccountId?.let { dataRow.createCell(3).setCellValue(it) }
        cloudInstanceId?.let { dataRow.createCell(4).setCellValue(it) }
        osVersion?.let { dataRow.createCell(5).setCellValue(it) }
        adDomain?.let { dataRow.createCell(6).setCellValue(it) }
        vulnerabilityId?.let { dataRow.createCell(7).setCellValue(it) }
        cvssSeverity?.let { dataRow.createCell(8).setCellValue(it) }
        vulnerableProductVersions?.let { dataRow.createCell(9).setCellValue(it) }
        daysOpen?.let { dataRow.createCell(10).setCellValue(it) }

        val outputStream = ByteArrayOutputStream()
        workbook.write(outputStream)
        workbook.close()

        return outputStream.toByteArray()
    }

    /**
     * Create Excel with whitespace-only fields
     */
    private fun createExcelWithWhitespaceFields(hostname: String): ByteArray {
        val workbook = XSSFWorkbook()
        val sheet = workbook.createSheet("Sheet1")

        // Header row
        val headerRow = sheet.createRow(0)
        val headers = listOf(
            "Hostname", "Local IP", "Host groups", "Cloud service account ID",
            "Cloud service instance ID", "OS version", "Active Directory domain",
            "Vulnerability ID", "CVSS severity", "Vulnerable product versions", "Days open"
        )
        headers.forEachIndexed { index, header ->
            headerRow.createCell(index).setCellValue(header)
        }

        // Data row with whitespace fields
        val dataRow = sheet.createRow(1)
        dataRow.createCell(0).setCellValue(hostname)
        dataRow.createCell(1).setCellValue("   ") // Whitespace
        dataRow.createCell(2).setCellValue("  ") // Whitespace
        dataRow.createCell(3).setCellValue(" ") // Whitespace
        dataRow.createCell(7).setCellValue("  ") // Whitespace
        dataRow.createCell(8).setCellValue("   ") // Whitespace

        val outputStream = ByteArrayOutputStream()
        workbook.write(outputStream)
        workbook.close()

        return outputStream.toByteArray()
    }

    /**
     * Create Excel with varying empty fields across multiple rows
     */
    private fun createExcelWithVaryingEmptyFields(): ByteArray {
        val workbook = XSSFWorkbook()
        val sheet = workbook.createSheet("Sheet1")

        // Header row
        val headerRow = sheet.createRow(0)
        val headers = listOf(
            "Hostname", "Local IP", "Host groups", "Cloud service account ID",
            "Cloud service instance ID", "OS version", "Active Directory domain",
            "Vulnerability ID", "CVSS severity", "Vulnerable product versions", "Days open"
        )
        headers.forEachIndexed { index, header ->
            headerRow.createCell(index).setCellValue(header)
        }

        // Row 1: Has IP, no groups
        val row1 = sheet.createRow(1)
        row1.createCell(0).setCellValue("host1.example.com")
        row1.createCell(1).setCellValue("10.0.0.1")
        // groups empty

        // Row 2: No IP, has groups
        val row2 = sheet.createRow(2)
        row2.createCell(0).setCellValue("host2.example.com")
        // ip empty
        row2.createCell(2).setCellValue("Production")

        // Row 3: No IP, no groups
        val row3 = sheet.createRow(3)
        row3.createCell(0).setCellValue("host3.example.com")
        // ip empty
        // groups empty

        val outputStream = ByteArrayOutputStream()
        workbook.write(outputStream)
        workbook.close()

        return outputStream.toByteArray()
    }
}
