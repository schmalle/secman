package com.secman.integration

import com.secman.domain.Asset
import com.secman.repository.AssetRepository
import com.secman.repository.VulnerabilityRepository
import io.micronaut.http.HttpRequest
import io.micronaut.http.HttpStatus
import io.micronaut.http.client.HttpClient
import io.micronaut.http.client.annotation.Client
import io.micronaut.http.client.multipart.MultipartBody
import io.micronaut.test.extensions.junit5.annotation.MicronautTest
import jakarta.inject.Inject
import org.apache.poi.xssf.usermodel.XSSFWorkbook
import org.junit.jupiter.api.AfterEach
import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.DisplayName
import org.junit.jupiter.api.Test
import java.io.ByteArrayOutputStream
import java.time.LocalDateTime
import java.time.format.DateTimeFormatter

/**
 * Integration test: Import vulnerabilities with known (existing) assets
 *
 * Tests:
 * - Vulnerabilities are correctly linked to existing assets
 * - Scan timestamp is recorded correctly
 * - Existing asset data is preserved or merged appropriately
 *
 * Related to: Feature 003-i-want-to (Vulnerability Management System)
 */
@MicronautTest(transactional = false)
class VulnerabilityImportKnownAssetsTest {

    @Inject
    @field:Client("/")
    lateinit var client: HttpClient

    @Inject
    lateinit var assetRepository: AssetRepository

    @Inject
    lateinit var vulnerabilityRepository: VulnerabilityRepository

    private var testAssetId: Long? = null
    private val testHostname = "known-server.example.com"

    @BeforeEach
    fun setup() {
        // Create a known asset before import
        val asset = Asset(
            name = testHostname,
            owner = "Test Owner",
            type = "Application Server",
            description = "Pre-existing test asset",
            ip = "192.168.1.100"
        )
        val saved = assetRepository.save(asset)
        testAssetId = saved.id
    }

    @AfterEach
    fun cleanup() {
        // Clean up test data
        vulnerabilityRepository.deleteAll()
        assetRepository.deleteAll()
    }

    @Test
    @DisplayName("Import vulnerabilities for known asset should link to existing asset")
    fun testImportWithKnownAsset() {
        // Create Excel file with vulnerability for known asset
        val xlsxFile = createVulnerabilityExcel(
            hostname = testHostname,
            ip = "192.168.1.100",
            vulnerabilityId = "CVE-2024-0001",
            cvssSeverity = "9.8 Critical"
        )

        val scanDate = LocalDateTime.now().minusDays(1)
        val scanDateStr = scanDate.format(DateTimeFormatter.ISO_LOCAL_DATE_TIME)

        // Upload the file
        val body = MultipartBody.builder()
            .addPart("xlsxFile", "vulnerabilities.xlsx", xlsxFile)
            .addPart("scanDate", scanDateStr)
            .build()

        val request = HttpRequest.POST("/api/import/upload-vulnerability-xlsx", body)
            .basicAuth("admin", "admin")

        val response = client.toBlocking().exchange(request, Map::class.java)

        // Verify response
        assertEquals(HttpStatus.OK, response.status)
        val responseBody = response.body() as Map<*, *>
        assertEquals(1, responseBody["imported"])
        assertEquals(0, responseBody["skipped"])
        assertEquals(0, responseBody["assetsCreated"]) // Should not create new asset

        // Verify vulnerability is linked to existing asset
        val vulnerabilities = vulnerabilityRepository.findByAssetId(testAssetId!!, io.micronaut.data.model.Pageable.unpaged())
        assertEquals(1, vulnerabilities.totalSize)

        val vulnerability = vulnerabilities.content.first()
        assertEquals(testAssetId, vulnerability.asset.id)
        assertEquals("CVE-2024-0001", vulnerability.vulnerabilityId)
        assertEquals("9.8 Critical", vulnerability.cvssSeverity)

        // Verify scan timestamp
        assertTrue(vulnerability.scanTimestamp.isEqual(scanDate))

        // Verify asset count hasn't changed (no new assets created)
        val assetCount = assetRepository.count()
        assertEquals(1, assetCount)
    }

    @Test
    @DisplayName("Import multiple vulnerabilities for same known asset")
    fun testImportMultipleVulnerabilitiesForKnownAsset() {
        // Create Excel file with multiple vulnerabilities for same asset
        val xlsxFile = createMultipleVulnerabilitiesExcel(
            hostname = testHostname,
            vulnerabilities = listOf(
                mapOf("id" to "CVE-2024-0001", "severity" to "9.8 Critical"),
                mapOf("id" to "CVE-2024-0002", "severity" to "7.5 High"),
                mapOf("id" to "CVE-2024-0003", "severity" to "5.3 Medium")
            )
        )

        val scanDate = LocalDateTime.now().minusDays(2)
        val scanDateStr = scanDate.format(DateTimeFormatter.ISO_LOCAL_DATE_TIME)

        // Upload the file
        val body = MultipartBody.builder()
            .addPart("xlsxFile", "vulnerabilities.xlsx", xlsxFile)
            .addPart("scanDate", scanDateStr)
            .build()

        val request = HttpRequest.POST("/api/import/upload-vulnerability-xlsx", body)
            .basicAuth("admin", "admin")

        val response = client.toBlocking().exchange(request, Map::class.java)

        // Verify response
        assertEquals(HttpStatus.OK, response.status)
        val responseBody = response.body() as Map<*, *>
        assertEquals(3, responseBody["imported"])
        assertEquals(0, responseBody["skipped"])

        // Verify all vulnerabilities are linked to same asset
        val vulnerabilities = vulnerabilityRepository.findByAssetId(testAssetId!!, io.micronaut.data.model.Pageable.unpaged())
        assertEquals(3, vulnerabilities.totalSize)

        // Verify all have same asset and scan timestamp
        vulnerabilities.content.forEach { vuln ->
            assertEquals(testAssetId, vuln.asset.id)
            assertTrue(vuln.scanTimestamp.isEqual(scanDate))
        }

        // Verify vulnerability IDs
        val vulnIds = vulnerabilities.content.map { it.vulnerabilityId }.toSet()
        assertTrue(vulnIds.contains("CVE-2024-0001"))
        assertTrue(vulnIds.contains("CVE-2024-0002"))
        assertTrue(vulnIds.contains("CVE-2024-0003"))
    }

    /**
     * Create Excel file with single vulnerability
     */
    private fun createVulnerabilityExcel(
        hostname: String,
        ip: String,
        vulnerabilityId: String,
        cvssSeverity: String
    ): ByteArray {
        val workbook = XSSFWorkbook()
        val sheet = workbook.createSheet("Sheet1")

        // Header row
        val headerRow = sheet.createRow(0)
        val headers = listOf(
            "Hostname", "Local IP", "Host groups", "Cloud service account ID",
            "Cloud service instance ID", "OS version", "Active Directory domain",
            "Vulnerability ID", "CVSS severity", "Vulnerable product versions", "Days open"
        )
        headers.forEachIndexed { index, header ->
            headerRow.createCell(index).setCellValue(header)
        }

        // Data row
        val dataRow = sheet.createRow(1)
        dataRow.createCell(0).setCellValue(hostname)
        dataRow.createCell(1).setCellValue(ip)
        dataRow.createCell(2).setCellValue("")
        dataRow.createCell(3).setCellValue("")
        dataRow.createCell(4).setCellValue("")
        dataRow.createCell(5).setCellValue("")
        dataRow.createCell(6).setCellValue("")
        dataRow.createCell(7).setCellValue(vulnerabilityId)
        dataRow.createCell(8).setCellValue(cvssSeverity)
        dataRow.createCell(9).setCellValue("")
        dataRow.createCell(10).setCellValue("")

        val outputStream = ByteArrayOutputStream()
        workbook.write(outputStream)
        workbook.close()

        return outputStream.toByteArray()
    }

    /**
     * Create Excel file with multiple vulnerabilities for same host
     */
    private fun createMultipleVulnerabilitiesExcel(
        hostname: String,
        vulnerabilities: List<Map<String, String>>
    ): ByteArray {
        val workbook = XSSFWorkbook()
        val sheet = workbook.createSheet("Sheet1")

        // Header row
        val headerRow = sheet.createRow(0)
        val headers = listOf(
            "Hostname", "Local IP", "Host groups", "Cloud service account ID",
            "Cloud service instance ID", "OS version", "Active Directory domain",
            "Vulnerability ID", "CVSS severity", "Vulnerable product versions", "Days open"
        )
        headers.forEachIndexed { index, header ->
            headerRow.createCell(index).setCellValue(header)
        }

        // Data rows
        vulnerabilities.forEachIndexed { index, vuln ->
            val dataRow = sheet.createRow(index + 1)
            dataRow.createCell(0).setCellValue(hostname)
            dataRow.createCell(1).setCellValue("192.168.1.100")
            dataRow.createCell(2).setCellValue("")
            dataRow.createCell(3).setCellValue("")
            dataRow.createCell(4).setCellValue("")
            dataRow.createCell(5).setCellValue("")
            dataRow.createCell(6).setCellValue("")
            dataRow.createCell(7).setCellValue(vuln["id"])
            dataRow.createCell(8).setCellValue(vuln["severity"])
            dataRow.createCell(9).setCellValue("")
            dataRow.createCell(10).setCellValue("")
        }

        val outputStream = ByteArrayOutputStream()
        workbook.write(outputStream)
        workbook.close()

        return outputStream.toByteArray()
    }
}
