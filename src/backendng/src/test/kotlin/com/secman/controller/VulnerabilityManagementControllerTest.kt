package com.secman.controller

import io.micronaut.http.HttpRequest
import io.micronaut.http.HttpStatus
import io.micronaut.http.client.HttpClient
import io.micronaut.http.client.annotation.Client
import io.micronaut.http.client.exceptions.HttpClientResponseException
import io.micronaut.security.authentication.UsernamePasswordCredentials
import io.micronaut.serde.annotation.Serdeable
import io.micronaut.test.extensions.junit5.annotation.MicronautTest
import jakarta.inject.Inject
import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.assertThrows
import java.time.LocalDateTime

/**
 * Contract tests for VulnerabilityManagementController
 *
 * Tests API endpoints:
 * - GET /api/vulnerabilities/current - Retrieve current vulnerabilities with filtering
 * - GET /api/vulnerability-exceptions - List all vulnerability exceptions
 * - POST /api/vulnerability-exceptions - Create new exception
 * - PUT /api/vulnerability-exceptions/{id} - Update exception
 * - DELETE /api/vulnerability-exceptions/{id} - Delete exception
 *
 * All tests follow TDD approach - they will FAIL until controller is implemented.
 *
 * Related to: Feature 004-i-want-to (VULN Role & Vulnerability Management UI)
 * Tasks: T003-T007 (Contract Tests)
 */
@MicronautTest
class VulnerabilityManagementControllerTest {

    @Inject
    @field:Client("/")
    lateinit var client: HttpClient

    // ============================================================================
    // T003: GET /api/vulnerabilities/current tests
    // ============================================================================

    @Test
    fun `testGetCurrentVulnerabilitiesRequiresAuth - should return 401 without JWT`() {
        // Arrange
        val request = HttpRequest.GET<Any>("/api/vulnerabilities/current")

        // Act & Assert
        val exception = assertThrows<HttpClientResponseException> {
            client.toBlocking().exchange(request, String::class.java)
        }

        assertEquals(HttpStatus.UNAUTHORIZED, exception.status,
            "Endpoint should require authentication and return 401 without JWT")
    }

    @Test
    fun `testGetCurrentVulnerabilitiesRequiresVulnRole - should return 403 for USER role`() {
        // Arrange
        val userToken = authenticateAsUser()
        val request = HttpRequest.GET<Any>("/api/vulnerabilities/current")
            .bearerAuth(userToken)

        // Act & Assert
        val exception = assertThrows<HttpClientResponseException> {
            client.toBlocking().exchange(request, String::class.java)
        }

        assertEquals(HttpStatus.FORBIDDEN, exception.status,
            "USER role should not have access, expected 403 FORBIDDEN")
    }

    @Test
    fun `testGetCurrentVulnerabilitiesReturnsLatestScansOnly - should return vulnerabilities from latest scan per asset`() {
        // Arrange
        val vulnToken = authenticateAsVuln()
        val request = HttpRequest.GET<Any>("/api/vulnerabilities/current")
            .bearerAuth(vulnToken)

        // Act
        val response = client.toBlocking().exchange(request, Array<VulnerabilityWithExceptionDto>::class.java)

        // Assert
        assertEquals(HttpStatus.OK, response.status)
        assertNotNull(response.body())

        // Verify response structure matches contract
        val vulnerabilities = response.body()!!
        vulnerabilities.forEach { vuln ->
            assertNotNull(vuln.id, "Vulnerability ID should not be null")
            assertNotNull(vuln.assetId, "Asset ID should not be null")
            assertNotNull(vuln.assetName, "Asset name should not be null")
            assertNotNull(vuln.scanTimestamp, "Scan timestamp should not be null")
            assertNotNull(vuln.hasException, "hasException field should not be null")
        }

        // Verify only latest scan per asset (groupBy logic verification)
        // If we have the same assetId, all should have the same scanTimestamp
        val assetScans = vulnerabilities.groupBy { it.assetId }
        assetScans.forEach { (assetId, vulns) ->
            val timestamps = vulns.map { it.scanTimestamp }.distinct()
            assertEquals(1, timestamps.size,
                "Asset $assetId should only have vulnerabilities from a single (latest) scan")
        }
    }

    @Test
    fun `testGetCurrentVulnerabilitiesFiltersBySeverity - should filter by severity parameter`() {
        // Arrange
        val vulnToken = authenticateAsVuln()
        val request = HttpRequest.GET<Any>("/api/vulnerabilities/current?severity=High")
            .bearerAuth(vulnToken)

        // Act
        val response = client.toBlocking().exchange(request, Array<VulnerabilityWithExceptionDto>::class.java)

        // Assert
        assertEquals(HttpStatus.OK, response.status)
        assertNotNull(response.body())

        // Verify all returned vulnerabilities have severity=High
        val vulnerabilities = response.body()!!
        vulnerabilities.forEach { vuln ->
            assertEquals("High", vuln.cvssSeverity,
                "All vulnerabilities should have severity=High when filtered")
        }
    }

    @Test
    fun `testGetCurrentVulnerabilitiesFiltersByExceptionStatus - should filter by exceptionStatus parameter`() {
        // Arrange
        val vulnToken = authenticateAsVuln()
        val request = HttpRequest.GET<Any>("/api/vulnerabilities/current?exceptionStatus=excepted")
            .bearerAuth(vulnToken)

        // Act
        val response = client.toBlocking().exchange(request, Array<VulnerabilityWithExceptionDto>::class.java)

        // Assert
        assertEquals(HttpStatus.OK, response.status)
        assertNotNull(response.body())

        // Verify all returned vulnerabilities have hasException=true
        val vulnerabilities = response.body()!!
        vulnerabilities.forEach { vuln ->
            assertTrue(vuln.hasException,
                "All vulnerabilities should have hasException=true when filtered by excepted")
        }
    }

    @Test
    fun `testGetCurrentVulnerabilitiesAdminRoleHasAccess - should return 200 for ADMIN role`() {
        // Arrange
        val adminToken = authenticateAsAdmin()
        val request = HttpRequest.GET<Any>("/api/vulnerabilities/current")
            .bearerAuth(adminToken)

        // Act
        val response = client.toBlocking().exchange(request, Array<VulnerabilityWithExceptionDto>::class.java)

        // Assert
        assertEquals(HttpStatus.OK, response.status,
            "ADMIN role should have access to vulnerabilities endpoint")
    }

    // ============================================================================
    // T004: GET /api/vulnerability-exceptions tests
    // ============================================================================

    @Test
    fun `testGetVulnerabilityExceptionsRequiresAuth - should return 401 without JWT`() {
        // Arrange
        val request = HttpRequest.GET<Any>("/api/vulnerability-exceptions")

        // Act & Assert
        val exception = assertThrows<HttpClientResponseException> {
            client.toBlocking().exchange(request, String::class.java)
        }

        assertEquals(HttpStatus.UNAUTHORIZED, exception.status,
            "Endpoint should require authentication and return 401 without JWT")
    }

    @Test
    fun `testGetVulnerabilityExceptionsRequiresVulnRole - should return 403 for USER role`() {
        // Arrange
        val userToken = authenticateAsUser()
        val request = HttpRequest.GET<Any>("/api/vulnerability-exceptions")
            .bearerAuth(userToken)

        // Act & Assert
        val exception = assertThrows<HttpClientResponseException> {
            client.toBlocking().exchange(request, String::class.java)
        }

        assertEquals(HttpStatus.FORBIDDEN, exception.status,
            "USER role should not have access, expected 403 FORBIDDEN")
    }

    @Test
    fun `testGetVulnerabilityExceptionsReturnsAll - should return all exceptions including expired`() {
        // Arrange
        val vulnToken = authenticateAsVuln()
        val request = HttpRequest.GET<Any>("/api/vulnerability-exceptions")
            .bearerAuth(vulnToken)

        // Act
        val response = client.toBlocking().exchange(request, Array<VulnerabilityExceptionDto>::class.java)

        // Assert
        assertEquals(HttpStatus.OK, response.status)
        assertNotNull(response.body())

        // Verify response structure matches contract
        val exceptions = response.body()!!
        exceptions.forEach { exc ->
            assertNotNull(exc.id, "Exception ID should not be null")
            assertNotNull(exc.exceptionType, "Exception type should not be null")
            assertNotNull(exc.targetValue, "Target value should not be null")
            assertNotNull(exc.reason, "Reason should not be null")
            assertNotNull(exc.createdBy, "Created by should not be null")
            assertNotNull(exc.createdAt, "Created at should not be null")
            assertNotNull(exc.isActive, "isActive field should not be null")
        }
    }

    @Test
    fun `testGetVulnerabilityExceptionsFiltersActiveOnly - should filter active exceptions when activeOnly=true`() {
        // Arrange
        val vulnToken = authenticateAsVuln()
        val request = HttpRequest.GET<Any>("/api/vulnerability-exceptions?activeOnly=true")
            .bearerAuth(vulnToken)

        // Act
        val response = client.toBlocking().exchange(request, Array<VulnerabilityExceptionDto>::class.java)

        // Assert
        assertEquals(HttpStatus.OK, response.status)
        assertNotNull(response.body())

        // Verify all returned exceptions are active
        val exceptions = response.body()!!
        exceptions.forEach { exc ->
            assertTrue(exc.isActive,
                "All exceptions should be active when activeOnly=true filter is applied")
        }
    }

    // ============================================================================
    // T005: POST /api/vulnerability-exceptions tests
    // ============================================================================

    @Test
    fun `testPostExceptionRequiresVulnRole - should return 403 for USER role`() {
        // Arrange
        val userToken = authenticateAsUser()
        val requestBody = CreateVulnerabilityExceptionRequest(
            exceptionType = "PRODUCT",
            targetValue = "OpenSSH 7.4",
            reason = "Compensating controls in place"
        )
        val request = HttpRequest.POST("/api/vulnerability-exceptions", requestBody)
            .bearerAuth(userToken)

        // Act & Assert
        val exception = assertThrows<HttpClientResponseException> {
            client.toBlocking().exchange(request, String::class.java)
        }

        assertEquals(HttpStatus.FORBIDDEN, exception.status,
            "USER role should not be able to create exceptions, expected 403 FORBIDDEN")
    }

    @Test
    fun `testPostExceptionValidation - should return 400 for missing reason`() {
        // Arrange
        val vulnToken = authenticateAsVuln()
        val requestBody = mapOf(
            "exceptionType" to "PRODUCT",
            "targetValue" to "OpenSSH 7.4"
            // Missing required 'reason' field
        )
        val request = HttpRequest.POST("/api/vulnerability-exceptions", requestBody)
            .bearerAuth(vulnToken)

        // Act & Assert
        val exception = assertThrows<HttpClientResponseException> {
            client.toBlocking().exchange(request, String::class.java)
        }

        assertEquals(HttpStatus.BAD_REQUEST, exception.status,
            "Should return 400 for missing required field 'reason'")
    }

    @Test
    fun `testPostExceptionValidationInvalidType - should return 400 for invalid exceptionType`() {
        // Arrange
        val vulnToken = authenticateAsVuln()
        val requestBody = mapOf(
            "exceptionType" to "INVALID_TYPE",
            "targetValue" to "OpenSSH 7.4",
            "reason" to "Test reason"
        )
        val request = HttpRequest.POST("/api/vulnerability-exceptions", requestBody)
            .bearerAuth(vulnToken)

        // Act & Assert
        val exception = assertThrows<HttpClientResponseException> {
            client.toBlocking().exchange(request, String::class.java)
        }

        assertEquals(HttpStatus.BAD_REQUEST, exception.status,
            "Should return 400 for invalid exceptionType (must be IP or PRODUCT)")
    }

    @Test
    fun `testPostExceptionCreatesSuccessfully - should return 201 with valid data`() {
        // Arrange
        val vulnToken = authenticateAsVuln()
        val requestBody = CreateVulnerabilityExceptionRequest(
            exceptionType = "PRODUCT",
            targetValue = "OpenSSH 7.4",
            reason = "Compensating controls in place - WAF blocks this attack vector",
            expirationDate = LocalDateTime.now().plusMonths(6)
        )
        val request = HttpRequest.POST("/api/vulnerability-exceptions", requestBody)
            .bearerAuth(vulnToken)

        // Act
        val response = client.toBlocking().exchange(request, VulnerabilityExceptionDto::class.java)

        // Assert
        assertEquals(HttpStatus.CREATED, response.status,
            "Should return 201 CREATED for successful exception creation")
        assertNotNull(response.body())

        val exception = response.body()!!
        assertNotNull(exception.id, "Created exception should have an ID")
        assertEquals("PRODUCT", exception.exceptionType)
        assertEquals("OpenSSH 7.4", exception.targetValue)
        assertEquals("Compensating controls in place - WAF blocks this attack vector", exception.reason)
        assertTrue(exception.isActive, "Newly created exception with future expiration should be active")
    }

    @Test
    fun `testPostExceptionSetsCreatedBy - should set createdBy from authenticated user`() {
        // Arrange
        val vulnToken = authenticateAsVuln()
        val requestBody = CreateVulnerabilityExceptionRequest(
            exceptionType = "IP",
            targetValue = "192.168.1.50",
            reason = "Test system - vulnerabilities accepted"
        )
        val request = HttpRequest.POST("/api/vulnerability-exceptions", requestBody)
            .bearerAuth(vulnToken)

        // Act
        val response = client.toBlocking().exchange(request, VulnerabilityExceptionDto::class.java)

        // Assert
        assertEquals(HttpStatus.CREATED, response.status)
        assertNotNull(response.body())

        val exception = response.body()!!
        assertEquals("vuln_user", exception.createdBy,
            "createdBy should be set from authenticated user (vuln_user)")
        assertNotNull(exception.createdAt, "createdAt should be set automatically")
    }

    // ============================================================================
    // T006: PUT /api/vulnerability-exceptions/{id} tests
    // ============================================================================

    @Test
    fun `testPutExceptionRequiresVulnRole - should return 403 for USER role`() {
        // Arrange
        val userToken = authenticateAsUser()
        val exceptionId = 1L
        val requestBody = UpdateVulnerabilityExceptionRequest(
            exceptionType = "IP",
            targetValue = "192.168.1.100",
            reason = "Updated reason"
        )
        val request = HttpRequest.PUT("/api/vulnerability-exceptions/$exceptionId", requestBody)
            .bearerAuth(userToken)

        // Act & Assert
        val exception = assertThrows<HttpClientResponseException> {
            client.toBlocking().exchange(request, String::class.java)
        }

        assertEquals(HttpStatus.FORBIDDEN, exception.status,
            "USER role should not be able to update exceptions, expected 403 FORBIDDEN")
    }

    @Test
    fun `testPutExceptionValidation - should return 400 for invalid data`() {
        // Arrange
        val vulnToken = authenticateAsVuln()
        val exceptionId = 1L
        val requestBody = mapOf(
            "exceptionType" to "PRODUCT",
            "targetValue" to "OpenSSH 8.0"
            // Missing required 'reason' field
        )
        val request = HttpRequest.PUT("/api/vulnerability-exceptions/$exceptionId", requestBody)
            .bearerAuth(vulnToken)

        // Act & Assert
        val exception = assertThrows<HttpClientResponseException> {
            client.toBlocking().exchange(request, String::class.java)
        }

        assertEquals(HttpStatus.BAD_REQUEST, exception.status,
            "Should return 400 for missing required field 'reason'")
    }

    @Test
    fun `testPutExceptionNotFound - should return 404 for non-existent ID`() {
        // Arrange
        val vulnToken = authenticateAsVuln()
        val nonExistentId = 99999L
        val requestBody = UpdateVulnerabilityExceptionRequest(
            exceptionType = "IP",
            targetValue = "192.168.1.100",
            reason = "Updated reason"
        )
        val request = HttpRequest.PUT("/api/vulnerability-exceptions/$nonExistentId", requestBody)
            .bearerAuth(vulnToken)

        // Act & Assert
        val exception = assertThrows<HttpClientResponseException> {
            client.toBlocking().exchange(request, String::class.java)
        }

        assertEquals(HttpStatus.NOT_FOUND, exception.status,
            "Should return 404 for non-existent exception ID")
    }

    @Test
    fun `testPutExceptionUpdatesSuccessfully - should return 200 with updated data`() {
        // Arrange - First create an exception to update
        val vulnToken = authenticateAsVuln()
        val createRequest = CreateVulnerabilityExceptionRequest(
            exceptionType = "PRODUCT",
            targetValue = "Apache 2.4.0",
            reason = "Original reason"
        )
        val createResponse = client.toBlocking().exchange(
            HttpRequest.POST("/api/vulnerability-exceptions", createRequest).bearerAuth(vulnToken),
            VulnerabilityExceptionDto::class.java
        )
        val createdId = createResponse.body()!!.id

        // Act - Update the exception
        val updateRequest = UpdateVulnerabilityExceptionRequest(
            exceptionType = "PRODUCT",
            targetValue = "Apache 2.4.1",
            reason = "Updated reason - version changed",
            expirationDate = LocalDateTime.now().plusYears(1)
        )
        val request = HttpRequest.PUT("/api/vulnerability-exceptions/$createdId", updateRequest)
            .bearerAuth(vulnToken)
        val response = client.toBlocking().exchange(request, VulnerabilityExceptionDto::class.java)

        // Assert
        assertEquals(HttpStatus.OK, response.status,
            "Should return 200 OK for successful update")
        assertNotNull(response.body())

        val updated = response.body()!!
        assertEquals(createdId, updated.id, "ID should remain unchanged")
        assertEquals("PRODUCT", updated.exceptionType)
        assertEquals("Apache 2.4.1", updated.targetValue, "Target value should be updated")
        assertEquals("Updated reason - version changed", updated.reason, "Reason should be updated")
        assertNotNull(updated.expirationDate, "Expiration date should be set")
    }

    // ============================================================================
    // T007: DELETE /api/vulnerability-exceptions/{id} tests
    // ============================================================================

    @Test
    fun `testDeleteExceptionRequiresVulnRole - should return 403 for USER role`() {
        // Arrange
        val userToken = authenticateAsUser()
        val exceptionId = 1L
        val request = HttpRequest.DELETE<Any>("/api/vulnerability-exceptions/$exceptionId")
            .bearerAuth(userToken)

        // Act & Assert
        val exception = assertThrows<HttpClientResponseException> {
            client.toBlocking().exchange(request, String::class.java)
        }

        assertEquals(HttpStatus.FORBIDDEN, exception.status,
            "USER role should not be able to delete exceptions, expected 403 FORBIDDEN")
    }

    @Test
    fun `testDeleteExceptionNotFound - should return 404 for non-existent ID`() {
        // Arrange
        val vulnToken = authenticateAsVuln()
        val nonExistentId = 99999L
        val request = HttpRequest.DELETE<Any>("/api/vulnerability-exceptions/$nonExistentId")
            .bearerAuth(vulnToken)

        // Act & Assert
        val exception = assertThrows<HttpClientResponseException> {
            client.toBlocking().exchange(request, String::class.java)
        }

        assertEquals(HttpStatus.NOT_FOUND, exception.status,
            "Should return 404 for non-existent exception ID")
    }

    @Test
    fun `testDeleteExceptionSucceeds - should return 204 on success`() {
        // Arrange - First create an exception to delete
        val vulnToken = authenticateAsVuln()
        val createRequest = CreateVulnerabilityExceptionRequest(
            exceptionType = "IP",
            targetValue = "10.0.0.5",
            reason = "Temporary exception for testing"
        )
        val createResponse = client.toBlocking().exchange(
            HttpRequest.POST("/api/vulnerability-exceptions", createRequest).bearerAuth(vulnToken),
            VulnerabilityExceptionDto::class.java
        )
        val createdId = createResponse.body()!!.id

        // Act - Delete the exception
        val request = HttpRequest.DELETE<Any>("/api/vulnerability-exceptions/$createdId")
            .bearerAuth(vulnToken)
        val response = client.toBlocking().exchange(request, String::class.java)

        // Assert
        assertEquals(HttpStatus.NO_CONTENT, response.status,
            "Should return 204 NO CONTENT on successful deletion")

        // Verify deletion - subsequent GET should return 404
        val getRequest = HttpRequest.GET<Any>("/api/vulnerability-exceptions/$createdId")
            .bearerAuth(vulnToken)
        val getException = assertThrows<HttpClientResponseException> {
            client.toBlocking().exchange(getRequest, String::class.java)
        }
        assertEquals(HttpStatus.NOT_FOUND, getException.status,
            "Deleted exception should not be retrievable")
    }

    // ============================================================================
    // Helper methods for authentication
    // ============================================================================

    private fun authenticateAsAdmin(): String {
        val credentials = UsernamePasswordCredentials("admin", "admin")
        val request = HttpRequest.POST("/login", credentials)
        val response = client.toBlocking().exchange(request, Map::class.java)
        return response.body()!!["access_token"] as String
    }

    private fun authenticateAsUser(): String {
        val credentials = UsernamePasswordCredentials("user", "user")
        val request = HttpRequest.POST("/login", credentials)
        val response = client.toBlocking().exchange(request, Map::class.java)
        return response.body()!!["access_token"] as String
    }

    private fun authenticateAsVuln(): String {
        val credentials = UsernamePasswordCredentials("vuln_user", "vuln_user")
        val request = HttpRequest.POST("/login", credentials)
        val response = client.toBlocking().exchange(request, Map::class.java)
        return response.body()!!["access_token"] as String
    }
}

// ============================================================================
// DTOs matching OpenAPI contracts
// ============================================================================

@Serdeable
data class VulnerabilityWithExceptionDto(
    val id: Long,
    val assetId: Long,
    val assetName: String,
    val assetIp: String?,
    val vulnerabilityId: String?,
    val cvssSeverity: String?,
    val vulnerableProductVersions: String?,
    val daysOpen: String?,
    val scanTimestamp: LocalDateTime,
    val hasException: Boolean,
    val exceptionReason: String?
)

@Serdeable
data class VulnerabilityExceptionDto(
    val id: Long,
    val exceptionType: String,
    val targetValue: String,
    val expirationDate: LocalDateTime?,
    val reason: String,
    val createdBy: String,
    val createdAt: LocalDateTime,
    val isActive: Boolean,
    val affectedVulnerabilityCount: Int?
)

@Serdeable
data class CreateVulnerabilityExceptionRequest(
    val exceptionType: String,
    val targetValue: String,
    val reason: String,
    val expirationDate: LocalDateTime? = null
)

@Serdeable
data class UpdateVulnerabilityExceptionRequest(
    val exceptionType: String,
    val targetValue: String,
    val reason: String,
    val expirationDate: LocalDateTime? = null
)
