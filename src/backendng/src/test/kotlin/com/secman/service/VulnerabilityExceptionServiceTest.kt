package com.secman.service

import com.secman.domain.Asset
import com.secman.domain.Vulnerability
import com.secman.domain.VulnerabilityException
import com.secman.repository.VulnerabilityExceptionRepository
import io.micronaut.test.extensions.junit5.annotation.MicronautTest
import io.mockk.every
import io.mockk.mockk
import io.mockk.verify
import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test
import java.time.LocalDateTime
import java.util.*

/**
 * Unit tests for VulnerabilityExceptionService
 *
 * Tests business logic for:
 * - Getting all exceptions with optional filtering (active/expired, type)
 * - Checking if a vulnerability is covered by an exception
 * - Creating, updating, and deleting exceptions
 *
 * Uses MockK to mock repository.
 *
 * All tests follow TDD approach - they will FAIL until service is implemented.
 *
 * Related to: Feature 004-i-want-to (VULN Role & Vulnerability Management UI)
 * Task: T009 (Unit Test VulnerabilityExceptionService)
 */
@MicronautTest
class VulnerabilityExceptionServiceTest {

    private lateinit var vulnerabilityExceptionRepository: VulnerabilityExceptionRepository
    private lateinit var vulnerabilityExceptionService: VulnerabilityExceptionService

    @BeforeEach
    fun setup() {
        vulnerabilityExceptionRepository = mockk()
        vulnerabilityExceptionService = VulnerabilityExceptionService(
            vulnerabilityExceptionRepository
        )
    }

    // ============================================================================
    // Tests for getActiveExceptions
    // ============================================================================

    /**
     * Test that getActiveExceptions filters out expired exceptions
     *
     * Business logic:
     * - Active exceptions: expirationDate is null OR expirationDate is in the future
     * - Expired exceptions: expirationDate is in the past
     */
    @Test
    fun `testGetActiveExceptionsFiltersExpired - should return only active (non-expired) exceptions`() {
        // Arrange
        val activeException1 = VulnerabilityException(
            id = 1L,
            exceptionType = VulnerabilityException.ExceptionType.IP,
            targetValue = "192.168.1.10",
            reason = "Test system",
            createdBy = "admin",
            expirationDate = LocalDateTime.now().plusMonths(6) // Future date
        )

        val activeException2 = VulnerabilityException(
            id = 2L,
            exceptionType = VulnerabilityException.ExceptionType.PRODUCT,
            targetValue = "OpenSSH 7.4",
            reason = "Compensating controls",
            createdBy = "admin",
            expirationDate = null // Permanent exception
        )

        val expiredException = VulnerabilityException(
            id = 3L,
            exceptionType = VulnerabilityException.ExceptionType.IP,
            targetValue = "192.168.1.20",
            reason = "Temporary exception",
            createdBy = "admin",
            expirationDate = LocalDateTime.now().minusDays(1) // Expired yesterday
        )

        val allExceptions = listOf(activeException1, activeException2, expiredException)

        every { vulnerabilityExceptionRepository.findAll() } returns allExceptions

        // Act
        val result = vulnerabilityExceptionService.getActiveExceptions()

        // Assert
        assertNotNull(result)
        assertEquals(2, result.size, "Should return only 2 active exceptions")
        assertTrue(result.any { it.id == 1L }, "Should include active exception 1")
        assertTrue(result.any { it.id == 2L }, "Should include active exception 2")
        assertFalse(result.any { it.id == 3L }, "Should NOT include expired exception")

        // Verify all returned exceptions are active
        result.forEach { exception ->
            assertTrue(exception.isActive(), "All returned exceptions should be active")
        }

        verify(exactly = 1) { vulnerabilityExceptionRepository.findAll() }
    }

    /**
     * Test that getAllExceptions returns all exceptions (including expired)
     */
    @Test
    fun `testGetAllExceptionsIncludesExpired - should return all exceptions without filtering`() {
        // Arrange
        val activeException = VulnerabilityException(
            id = 1L,
            exceptionType = VulnerabilityException.ExceptionType.IP,
            targetValue = "192.168.1.10",
            reason = "Test system",
            createdBy = "admin",
            expirationDate = LocalDateTime.now().plusMonths(6)
        )

        val expiredException = VulnerabilityException(
            id = 2L,
            exceptionType = VulnerabilityException.ExceptionType.PRODUCT,
            targetValue = "OpenSSH 7.4",
            reason = "Old exception",
            createdBy = "admin",
            expirationDate = LocalDateTime.now().minusDays(1)
        )

        val allExceptions = listOf(activeException, expiredException)

        every { vulnerabilityExceptionRepository.findAll() } returns allExceptions

        // Act
        val result = vulnerabilityExceptionService.getAllExceptions(activeOnly = false)

        // Assert
        assertNotNull(result)
        assertEquals(2, result.size, "Should return all 2 exceptions (active + expired)")
        assertTrue(result.any { it.id == 1L }, "Should include active exception")
        assertTrue(result.any { it.id == 2L }, "Should include expired exception")

        verify(exactly = 1) { vulnerabilityExceptionRepository.findAll() }
    }

    /**
     * Test filtering by type
     */
    @Test
    fun `testGetExceptionsByType - should filter exceptions by type`() {
        // Arrange
        val ipException1 = VulnerabilityException(
            id = 1L,
            exceptionType = VulnerabilityException.ExceptionType.IP,
            targetValue = "192.168.1.10",
            reason = "Test system 1",
            createdBy = "admin",
            expirationDate = null
        )

        val ipException2 = VulnerabilityException(
            id = 2L,
            exceptionType = VulnerabilityException.ExceptionType.IP,
            targetValue = "192.168.1.20",
            reason = "Test system 2",
            createdBy = "admin",
            expirationDate = null
        )

        val productException = VulnerabilityException(
            id = 3L,
            exceptionType = VulnerabilityException.ExceptionType.PRODUCT,
            targetValue = "OpenSSH 7.4",
            reason = "Product exception",
            createdBy = "admin",
            expirationDate = null
        )

        val allExceptions = listOf(ipException1, ipException2, productException)

        every { vulnerabilityExceptionRepository.findAll() } returns allExceptions

        // Act - Filter by IP type
        val result = vulnerabilityExceptionService.getAllExceptions(
            activeOnly = false,
            type = VulnerabilityException.ExceptionType.IP
        )

        // Assert
        assertNotNull(result)
        assertEquals(2, result.size, "Should return only IP exceptions")
        assertTrue(result.all { it.exceptionType == VulnerabilityException.ExceptionType.IP },
            "All returned exceptions should be IP type")
        assertTrue(result.any { it.id == 1L }, "Should include IP exception 1")
        assertTrue(result.any { it.id == 2L }, "Should include IP exception 2")
        assertFalse(result.any { it.id == 3L }, "Should NOT include PRODUCT exception")

        verify(exactly = 1) { vulnerabilityExceptionRepository.findAll() }
    }

    // ============================================================================
    // Tests for isVulnerabilityExcepted - IP matching
    // ============================================================================

    /**
     * Test IP-based exception matching
     *
     * Business logic:
     * - IP exception matches when asset.ip == exception.targetValue
     * - Match is exact (no wildcards or CIDR)
     */
    @Test
    fun `testIsVulnerabilityExceptedMatchesIP - should match vulnerability by IP address`() {
        // Arrange
        val asset = Asset(
            id = 1L,
            name = "web-server-01",
            type = "Server",
            owner = "IT Team",
            ip = "192.168.1.10"
        )

        val vulnerability = Vulnerability(
            id = 1L,
            asset = asset,
            vulnerabilityId = "CVE-2023-0001",
            cvssSeverity = "High",
            vulnerableProductVersions = "OpenSSH 7.4",
            daysOpen = "30 days",
            scanTimestamp = LocalDateTime.now()
        )

        val ipException = VulnerabilityException(
            id = 1L,
            exceptionType = VulnerabilityException.ExceptionType.IP,
            targetValue = "192.168.1.10", // Matches asset.ip
            reason = "Test system",
            createdBy = "admin",
            expirationDate = null
        )

        every { vulnerabilityExceptionRepository.findAll() } returns listOf(ipException)

        // Act
        val isExcepted = vulnerabilityExceptionService.isVulnerabilityExcepted(vulnerability, asset)

        // Assert
        assertTrue(isExcepted, "Vulnerability should be excepted (IP match)")

        verify(exactly = 1) { vulnerabilityExceptionRepository.findAll() }
    }

    /**
     * Test IP non-match
     */
    @Test
    fun `testIsVulnerabilityExceptedNoIPMatch - should not match when IP differs`() {
        // Arrange
        val asset = Asset(
            id = 1L,
            name = "web-server-01",
            type = "Server",
            owner = "IT Team",
            ip = "192.168.1.10"
        )

        val vulnerability = Vulnerability(
            id = 1L,
            asset = asset,
            vulnerabilityId = "CVE-2023-0001",
            cvssSeverity = "High",
            vulnerableProductVersions = "OpenSSH 7.4",
            daysOpen = "30 days",
            scanTimestamp = LocalDateTime.now()
        )

        val ipException = VulnerabilityException(
            id = 1L,
            exceptionType = VulnerabilityException.ExceptionType.IP,
            targetValue = "192.168.1.99", // Different IP
            reason = "Test system",
            createdBy = "admin",
            expirationDate = null
        )

        every { vulnerabilityExceptionRepository.findAll() } returns listOf(ipException)

        // Act
        val isExcepted = vulnerabilityExceptionService.isVulnerabilityExcepted(vulnerability, asset)

        // Assert
        assertFalse(isExcepted, "Vulnerability should NOT be excepted (IP mismatch)")

        verify(exactly = 1) { vulnerabilityExceptionRepository.findAll() }
    }

    // ============================================================================
    // Tests for isVulnerabilityExcepted - PRODUCT matching
    // ============================================================================

    /**
     * Test PRODUCT-based exception matching
     *
     * Business logic:
     * - PRODUCT exception matches when vulnerability.vulnerableProductVersions contains exception.targetValue
     * - Match uses substring matching (contains)
     */
    @Test
    fun `testIsVulnerabilityExceptedMatchesProduct - should match vulnerability by product version`() {
        // Arrange
        val asset = Asset(
            id = 1L,
            name = "web-server-01",
            type = "Server",
            owner = "IT Team",
            ip = "192.168.1.10"
        )

        val vulnerability = Vulnerability(
            id = 1L,
            asset = asset,
            vulnerabilityId = "CVE-2023-0001",
            cvssSeverity = "High",
            vulnerableProductVersions = "OpenSSH 7.4", // Contains "OpenSSH 7.4"
            daysOpen = "30 days",
            scanTimestamp = LocalDateTime.now()
        )

        val productException = VulnerabilityException(
            id = 1L,
            exceptionType = VulnerabilityException.ExceptionType.PRODUCT,
            targetValue = "OpenSSH 7.4", // Matches product version
            reason = "Compensating controls",
            createdBy = "admin",
            expirationDate = null
        )

        every { vulnerabilityExceptionRepository.findAll() } returns listOf(productException)

        // Act
        val isExcepted = vulnerabilityExceptionService.isVulnerabilityExcepted(vulnerability, asset)

        // Assert
        assertTrue(isExcepted, "Vulnerability should be excepted (PRODUCT match)")

        verify(exactly = 1) { vulnerabilityExceptionRepository.findAll() }
    }

    /**
     * Test PRODUCT partial matching (substring)
     */
    @Test
    fun `testIsVulnerabilityExceptedPartialProductMatch - should match product by substring`() {
        // Arrange
        val asset = Asset(
            id = 1L,
            name = "web-server-01",
            type = "Server",
            owner = "IT Team",
            ip = "192.168.1.10"
        )

        val vulnerability = Vulnerability(
            id = 1L,
            asset = asset,
            vulnerabilityId = "CVE-2023-0001",
            cvssSeverity = "High",
            vulnerableProductVersions = "Apache/2.4.0 (Ubuntu)", // Contains "Apache 2.4.0"
            daysOpen = "30 days",
            scanTimestamp = LocalDateTime.now()
        )

        val productException = VulnerabilityException(
            id = 1L,
            exceptionType = VulnerabilityException.ExceptionType.PRODUCT,
            targetValue = "Apache 2.4.0", // Partial match
            reason = "Compensating controls",
            createdBy = "admin",
            expirationDate = null
        )

        every { vulnerabilityExceptionRepository.findAll() } returns listOf(productException)

        // Act
        val isExcepted = vulnerabilityExceptionService.isVulnerabilityExcepted(vulnerability, asset)

        // Assert
        assertTrue(isExcepted, "Vulnerability should be excepted (PRODUCT partial match)")

        verify(exactly = 1) { vulnerabilityExceptionRepository.findAll() }
    }

    /**
     * Test PRODUCT non-match
     */
    @Test
    fun `testIsVulnerabilityExceptedNoProductMatch - should not match when product differs`() {
        // Arrange
        val asset = Asset(
            id = 1L,
            name = "web-server-01",
            type = "Server",
            owner = "IT Team",
            ip = "192.168.1.10"
        )

        val vulnerability = Vulnerability(
            id = 1L,
            asset = asset,
            vulnerabilityId = "CVE-2023-0001",
            cvssSeverity = "High",
            vulnerableProductVersions = "nginx 1.18.0", // Different product
            daysOpen = "30 days",
            scanTimestamp = LocalDateTime.now()
        )

        val productException = VulnerabilityException(
            id = 1L,
            exceptionType = VulnerabilityException.ExceptionType.PRODUCT,
            targetValue = "OpenSSH 7.4", // Different product
            reason = "Compensating controls",
            createdBy = "admin",
            expirationDate = null
        )

        every { vulnerabilityExceptionRepository.findAll() } returns listOf(productException)

        // Act
        val isExcepted = vulnerabilityExceptionService.isVulnerabilityExcepted(vulnerability, asset)

        // Assert
        assertFalse(isExcepted, "Vulnerability should NOT be excepted (PRODUCT mismatch)")

        verify(exactly = 1) { vulnerabilityExceptionRepository.findAll() }
    }

    // ============================================================================
    // Tests for expired exception handling
    // ============================================================================

    /**
     * Test that expired exceptions are ignored when checking if vulnerability is excepted
     */
    @Test
    fun `testIsVulnerabilityExceptedIgnoresExpired - should not match with expired exceptions`() {
        // Arrange
        val asset = Asset(
            id = 1L,
            name = "web-server-01",
            type = "Server",
            owner = "IT Team",
            ip = "192.168.1.10"
        )

        val vulnerability = Vulnerability(
            id = 1L,
            asset = asset,
            vulnerabilityId = "CVE-2023-0001",
            cvssSeverity = "High",
            vulnerableProductVersions = "OpenSSH 7.4",
            daysOpen = "30 days",
            scanTimestamp = LocalDateTime.now()
        )

        val expiredIpException = VulnerabilityException(
            id = 1L,
            exceptionType = VulnerabilityException.ExceptionType.IP,
            targetValue = "192.168.1.10", // Matches IP
            reason = "Temporary test system",
            createdBy = "admin",
            expirationDate = LocalDateTime.now().minusDays(1) // Expired yesterday
        )

        val expiredProductException = VulnerabilityException(
            id = 2L,
            exceptionType = VulnerabilityException.ExceptionType.PRODUCT,
            targetValue = "OpenSSH 7.4", // Matches product
            reason = "Temporary exception",
            createdBy = "admin",
            expirationDate = LocalDateTime.now().minusHours(1) // Expired 1 hour ago
        )

        every { vulnerabilityExceptionRepository.findAll() } returns listOf(expiredIpException, expiredProductException)

        // Act
        val isExcepted = vulnerabilityExceptionService.isVulnerabilityExcepted(vulnerability, asset)

        // Assert
        assertFalse(isExcepted, "Vulnerability should NOT be excepted (all matching exceptions are expired)")

        verify(exactly = 1) { vulnerabilityExceptionRepository.findAll() }
    }

    /**
     * Test that active exception takes precedence even if expired exceptions exist
     */
    @Test
    fun `testIsVulnerabilityExceptedActiveOverridesExpired - should match with active exception despite expired ones`() {
        // Arrange
        val asset = Asset(
            id = 1L,
            name = "web-server-01",
            type = "Server",
            owner = "IT Team",
            ip = "192.168.1.10"
        )

        val vulnerability = Vulnerability(
            id = 1L,
            asset = asset,
            vulnerabilityId = "CVE-2023-0001",
            cvssSeverity = "High",
            vulnerableProductVersions = "OpenSSH 7.4",
            daysOpen = "30 days",
            scanTimestamp = LocalDateTime.now()
        )

        val expiredException = VulnerabilityException(
            id = 1L,
            exceptionType = VulnerabilityException.ExceptionType.IP,
            targetValue = "192.168.1.10",
            reason = "Old exception",
            createdBy = "admin",
            expirationDate = LocalDateTime.now().minusDays(1)
        )

        val activeException = VulnerabilityException(
            id = 2L,
            exceptionType = VulnerabilityException.ExceptionType.IP,
            targetValue = "192.168.1.10",
            reason = "Current exception",
            createdBy = "admin",
            expirationDate = LocalDateTime.now().plusMonths(6)
        )

        every { vulnerabilityExceptionRepository.findAll() } returns listOf(expiredException, activeException)

        // Act
        val isExcepted = vulnerabilityExceptionService.isVulnerabilityExcepted(vulnerability, asset)

        // Assert
        assertTrue(isExcepted, "Vulnerability should be excepted (active exception exists)")

        verify(exactly = 1) { vulnerabilityExceptionRepository.findAll() }
    }

    // ============================================================================
    // Tests for CRUD operations
    // ============================================================================

    /**
     * Test creating a new exception
     */
    @Test
    fun `testCreateException - should create and save new exception`() {
        // Arrange
        val request = com.secman.dto.CreateVulnerabilityExceptionRequest(
            exceptionType = VulnerabilityException.ExceptionType.PRODUCT,
            targetValue = "OpenSSH 7.4",
            reason = "Compensating controls in place",
            expirationDate = LocalDateTime.now().plusMonths(6)
        )

        val savedException = VulnerabilityException(
            id = 1L,
            exceptionType = request.exceptionType,
            targetValue = request.targetValue,
            reason = request.reason,
            createdBy = "admin",
            expirationDate = request.expirationDate
        )

        every { vulnerabilityExceptionRepository.save(any()) } returns savedException

        // Act
        val result = vulnerabilityExceptionService.createException(request, "admin")

        // Assert
        assertNotNull(result)
        assertEquals(1L, result.id, "Saved exception should have ID assigned")
        assertEquals(VulnerabilityException.ExceptionType.PRODUCT, result.exceptionType)
        assertEquals("OpenSSH 7.4", result.targetValue)
        assertEquals("admin", result.createdBy)

        verify(exactly = 1) { vulnerabilityExceptionRepository.save(any()) }
    }

    /**
     * Test updating an existing exception
     */
    @Test
    fun `testUpdateException - should update and save existing exception`() {
        // Arrange
        val existingException = VulnerabilityException(
            id = 1L,
            exceptionType = VulnerabilityException.ExceptionType.PRODUCT,
            targetValue = "OpenSSH 7.4",
            reason = "Original reason",
            createdBy = "admin",
            expirationDate = null
        )

        val updateRequest = com.secman.dto.UpdateVulnerabilityExceptionRequest(
            exceptionType = VulnerabilityException.ExceptionType.PRODUCT,
            targetValue = "OpenSSH 7.5",
            reason = "Updated reason",
            expirationDate = null
        )

        val updatedException = existingException.copy(
            targetValue = updateRequest.targetValue,
            reason = updateRequest.reason
        )

        every { vulnerabilityExceptionRepository.findById(1L) } returns Optional.of(existingException)
        every { vulnerabilityExceptionRepository.update(any()) } returns updatedException

        // Act
        val result = vulnerabilityExceptionService.updateException(1L, updateRequest)

        // Assert
        assertNotNull(result)
        assertEquals(1L, result.id, "ID should remain unchanged")
        assertEquals("OpenSSH 7.5", result.targetValue, "Target value should be updated")
        assertEquals("Updated reason", result.reason, "Reason should be updated")

        verify(exactly = 1) { vulnerabilityExceptionRepository.findById(1L) }
        verify(exactly = 1) { vulnerabilityExceptionRepository.update(any()) }
    }

    /**
     * Test deleting an exception
     */
    @Test
    fun `testDeleteException - should delete existing exception`() {
        // Arrange
        val exception = VulnerabilityException(
            id = 1L,
            exceptionType = VulnerabilityException.ExceptionType.IP,
            targetValue = "192.168.1.10",
            reason = "Test system",
            createdBy = "admin",
            expirationDate = null
        )

        every { vulnerabilityExceptionRepository.findById(1L) } returns Optional.of(exception)
        every { vulnerabilityExceptionRepository.deleteById(1L) } returns Unit

        // Act
        vulnerabilityExceptionService.deleteException(1L)

        // Assert
        verify(exactly = 1) { vulnerabilityExceptionRepository.findById(1L) }
        verify(exactly = 1) { vulnerabilityExceptionRepository.deleteById(1L) }
    }

    /**
     * Test that findMatchingException returns the correct exception
     */
    @Test
    fun `testFindMatchingException - should return matching exception with reason`() {
        // Arrange
        val asset = Asset(
            id = 1L,
            name = "web-server-01",
            type = "Server",
            owner = "IT Team",
            ip = "192.168.1.10"
        )

        val vulnerability = Vulnerability(
            id = 1L,
            asset = asset,
            vulnerabilityId = "CVE-2023-0001",
            cvssSeverity = "High",
            vulnerableProductVersions = "OpenSSH 7.4",
            daysOpen = "30 days",
            scanTimestamp = LocalDateTime.now()
        )

        val ipException = VulnerabilityException(
            id = 1L,
            exceptionType = VulnerabilityException.ExceptionType.IP,
            targetValue = "192.168.1.10",
            reason = "This is a test system with compensating controls",
            createdBy = "admin",
            expirationDate = null
        )

        every { vulnerabilityExceptionRepository.findAll() } returns listOf(ipException)

        // Act
        val matchingException = vulnerabilityExceptionService.findMatchingException(vulnerability, asset)

        // Assert
        assertNotNull(matchingException, "Should find matching exception")
        assertEquals(1L, matchingException!!.id)
        assertEquals("This is a test system with compensating controls", matchingException.reason)

        verify(exactly = 1) { vulnerabilityExceptionRepository.findAll() }
    }

    /**
     * Test that findMatchingException returns null when no match
     */
    @Test
    fun `testFindMatchingExceptionNoMatch - should return null when no exception matches`() {
        // Arrange
        val asset = Asset(
            id = 1L,
            name = "web-server-01",
            type = "Server",
            owner = "IT Team",
            ip = "192.168.1.10"
        )

        val vulnerability = Vulnerability(
            id = 1L,
            asset = asset,
            vulnerabilityId = "CVE-2023-0001",
            cvssSeverity = "High",
            vulnerableProductVersions = "nginx 1.18.0",
            daysOpen = "30 days",
            scanTimestamp = LocalDateTime.now()
        )

        val productException = VulnerabilityException(
            id = 1L,
            exceptionType = VulnerabilityException.ExceptionType.PRODUCT,
            targetValue = "Apache 2.4.0", // Different product
            reason = "Compensating controls",
            createdBy = "admin",
            expirationDate = null
        )

        every { vulnerabilityExceptionRepository.findAll() } returns listOf(productException)

        // Act
        val matchingException = vulnerabilityExceptionService.findMatchingException(vulnerability, asset)

        // Assert
        assertNull(matchingException, "Should not find matching exception")

        verify(exactly = 1) { vulnerabilityExceptionRepository.findAll() }
    }
}
