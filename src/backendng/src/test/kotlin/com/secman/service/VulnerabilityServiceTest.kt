package com.secman.service

import com.secman.domain.Asset
import com.secman.domain.Vulnerability
import com.secman.dto.AddVulnerabilityRequestDto
import com.secman.repository.AssetRepository
import com.secman.repository.VulnerabilityExceptionRepository
import com.secman.repository.VulnerabilityRepository
import io.micronaut.data.model.Page
import io.mockk.*
import io.mockk.impl.annotations.MockK
import org.assertj.core.api.Assertions.assertThat
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.DisplayName
import org.junit.jupiter.api.Nested
import org.junit.jupiter.api.Test
import java.time.LocalDateTime
import java.time.temporal.ChronoUnit

/**
 * Unit tests for VulnerabilityService.addVulnerabilityFromCli()
 * Feature: 056-test-suite (User Story 1 - P1)
 *
 * Tests the upsert pattern:
 * - Asset creation when hostname doesn't exist
 * - Asset reuse when hostname exists
 * - Vulnerability creation and update logic
 * - Criticality mapping
 * - Days-open timestamp calculation
 */
@DisplayName("VulnerabilityService.addVulnerabilityFromCli")
class VulnerabilityServiceTest {

    @MockK
    private lateinit var assetRepository: AssetRepository

    @MockK
    private lateinit var vulnerabilityRepository: VulnerabilityRepository

    @MockK
    private lateinit var vulnerabilityExceptionRepository: VulnerabilityExceptionRepository

    @MockK
    private lateinit var vulnerabilityConfigService: VulnerabilityConfigService

    private lateinit var vulnerabilityService: VulnerabilityService

    @BeforeEach
    fun setup() {
        MockKAnnotations.init(this, relaxed = true)

        // Create service with mocked dependencies
        vulnerabilityService = spyk(
            VulnerabilityService(
                vulnerabilityRepository = vulnerabilityRepository,
                vulnerabilityExceptionRepository = vulnerabilityExceptionRepository,
                vulnerabilityConfigService = vulnerabilityConfigService,
                assetRepository = assetRepository
            )
        )

        // Default mock behaviors
        every { assetRepository.save(any()) } answers { firstArg<Asset>().apply { id = 1L } }
        every { assetRepository.update(any()) } answers { firstArg() }
        every { vulnerabilityRepository.save(any()) } answers { firstArg<Vulnerability>().apply { id = 1L } }
        every { vulnerabilityRepository.update(any()) } answers { firstArg() }
        every { vulnerabilityRepository.findByAssetId(any(), any()) } returns Page.empty()
    }

    @Nested
    @DisplayName("Asset Creation/Lookup")
    inner class AssetCreationTests {

        @Test
        @DisplayName("VS-001: Creates new asset when hostname doesn't exist")
        fun `addVulnerabilityFromCli_createsNewAsset`() {
            // Given: No existing asset
            every { assetRepository.findByNameIgnoreCase("new-system") } returns null
            every { vulnerabilityRepository.findByAssetAndVulnerabilityId(any(), any()) } returns null

            val request = AddVulnerabilityRequestDto(
                hostname = "new-system",
                cve = "CVE-2024-001",
                criticality = "HIGH",
                daysOpen = 60
            )

            // When
            val result = vulnerabilityService.addVulnerabilityFromCli(request)

            // Then
            assertThat(result.success).isTrue()
            assertThat(result.assetCreated).isTrue()
            assertThat(result.operation).isEqualTo("CREATED")

            // Verify asset was saved with correct defaults
            verify {
                assetRepository.save(match { asset ->
                    asset.name == "new-system" &&
                    asset.type == "SERVER" &&
                    asset.owner == "CLI-IMPORT"
                })
            }
        }

        @Test
        @DisplayName("VS-002: Uses existing asset when hostname exists")
        fun `addVulnerabilityFromCli_usesExistingAsset`() {
            // Given: Existing asset
            val existingAsset = Asset(
                id = 1L,
                name = "existing-system",
                type = "SERVER",
                owner = "Other-Owner"
            )
            every { assetRepository.findByNameIgnoreCase("existing-system") } returns existingAsset
            every { vulnerabilityRepository.findByAssetAndVulnerabilityId(existingAsset, any()) } returns null

            val request = AddVulnerabilityRequestDto(
                hostname = "existing-system",
                cve = "CVE-2024-002",
                criticality = "MEDIUM",
                daysOpen = 30
            )

            // When
            val result = vulnerabilityService.addVulnerabilityFromCli(request)

            // Then
            assertThat(result.success).isTrue()
            assertThat(result.assetCreated).isFalse()
            assertThat(result.operation).isEqualTo("CREATED")

            // Verify asset was updated (lastSeen), not saved (created)
            verify(exactly = 0) { assetRepository.save(any()) }
            verify { assetRepository.update(existingAsset) }
        }

        @Test
        @DisplayName("VS-003: Updates existing vulnerability when CVE already exists")
        fun `addVulnerabilityFromCli_updatesExistingVuln`() {
            // Given: Existing asset with existing vulnerability
            val existingAsset = Asset(id = 1L, name = "system-a", type = "SERVER", owner = "CLI-IMPORT")
            val existingVuln = Vulnerability(
                id = 1L,
                asset = existingAsset,
                vulnerabilityId = "CVE-2024-001",
                cvssSeverity = "Medium",
                scanTimestamp = LocalDateTime.now().minusDays(30)
            )

            every { assetRepository.findByNameIgnoreCase("system-a") } returns existingAsset
            every { vulnerabilityRepository.findByAssetAndVulnerabilityId(existingAsset, "CVE-2024-001") } returns existingVuln

            val request = AddVulnerabilityRequestDto(
                hostname = "system-a",
                cve = "CVE-2024-001",
                criticality = "CRITICAL",
                daysOpen = 90
            )

            // When
            val result = vulnerabilityService.addVulnerabilityFromCli(request)

            // Then
            assertThat(result.success).isTrue()
            assertThat(result.assetCreated).isFalse()
            assertThat(result.operation).isEqualTo("UPDATED")

            // Verify vulnerability was updated, not saved
            verify(exactly = 0) { vulnerabilityRepository.save(any()) }
            verify { vulnerabilityRepository.update(existingVuln) }
        }
    }

    @Nested
    @DisplayName("Criticality Mapping")
    inner class CriticalityMappingTests {

        @Test
        @DisplayName("VS-004: Maps HIGH to 'High'")
        fun `addVulnerabilityFromCli_mapsCriticality_HIGH`() {
            // Given
            every { assetRepository.findByNameIgnoreCase(any()) } returns null
            every { vulnerabilityRepository.findByAssetAndVulnerabilityId(any(), any()) } returns null

            val savedVulnSlot = slot<Vulnerability>()
            every { vulnerabilityRepository.save(capture(savedVulnSlot)) } answers {
                savedVulnSlot.captured.apply { id = 1L }
            }

            val request = AddVulnerabilityRequestDto(
                hostname = "test-host",
                cve = "CVE-2024-TEST",
                criticality = "HIGH",
                daysOpen = 1
            )

            // When
            vulnerabilityService.addVulnerabilityFromCli(request)

            // Then
            assertThat(savedVulnSlot.captured.cvssSeverity).isEqualTo("High")
        }

        @Test
        @DisplayName("VS-005: Maps LOW to 'Low'")
        fun `addVulnerabilityFromCli_mapsCriticalityLow`() {
            // Given
            every { assetRepository.findByNameIgnoreCase(any()) } returns null
            every { vulnerabilityRepository.findByAssetAndVulnerabilityId(any(), any()) } returns null

            val savedVulnSlot = slot<Vulnerability>()
            every { vulnerabilityRepository.save(capture(savedVulnSlot)) } answers {
                savedVulnSlot.captured.apply { id = 1L }
            }

            val request = AddVulnerabilityRequestDto(
                hostname = "test-host",
                cve = "CVE-2024-TEST",
                criticality = "LOW",
                daysOpen = 1
            )

            // When
            vulnerabilityService.addVulnerabilityFromCli(request)

            // Then
            assertThat(savedVulnSlot.captured.cvssSeverity).isEqualTo("Low")
        }
    }

    @Nested
    @DisplayName("Timestamp Calculation")
    inner class TimestampCalculationTests {

        @Test
        @DisplayName("VS-006: Calculates scanTimestamp 60 days in the past")
        fun `addVulnerabilityFromCli_calculatesScanTimestamp`() {
            // Given
            every { assetRepository.findByNameIgnoreCase(any()) } returns null
            every { vulnerabilityRepository.findByAssetAndVulnerabilityId(any(), any()) } returns null

            val savedVulnSlot = slot<Vulnerability>()
            every { vulnerabilityRepository.save(capture(savedVulnSlot)) } answers {
                savedVulnSlot.captured.apply { id = 1L }
            }

            val request = AddVulnerabilityRequestDto(
                hostname = "test-host",
                cve = "CVE-2024-TEST",
                criticality = "HIGH",
                daysOpen = 60
            )

            val beforeTest = LocalDateTime.now().minusDays(60)

            // When
            vulnerabilityService.addVulnerabilityFromCli(request)

            val afterTest = LocalDateTime.now().minusDays(60)

            // Then
            val scanTimestamp = savedVulnSlot.captured.scanTimestamp
            assertThat(scanTimestamp).isAfterOrEqualTo(beforeTest.truncatedTo(ChronoUnit.SECONDS))
            assertThat(scanTimestamp).isBeforeOrEqualTo(afterTest.plusSeconds(1))
        }

        @Test
        @DisplayName("VS-007: Handles daysOpen=0 (scanTimestamp equals now)")
        fun `addVulnerabilityFromCli_handlesDaysOpenZero`() {
            // Given
            every { assetRepository.findByNameIgnoreCase(any()) } returns null
            every { vulnerabilityRepository.findByAssetAndVulnerabilityId(any(), any()) } returns null

            val savedVulnSlot = slot<Vulnerability>()
            every { vulnerabilityRepository.save(capture(savedVulnSlot)) } answers {
                savedVulnSlot.captured.apply { id = 1L }
            }

            val request = AddVulnerabilityRequestDto(
                hostname = "test-host",
                cve = "CVE-2024-TEST",
                criticality = "HIGH",
                daysOpen = 0
            )

            val beforeTest = LocalDateTime.now()

            // When
            vulnerabilityService.addVulnerabilityFromCli(request)

            val afterTest = LocalDateTime.now()

            // Then
            val scanTimestamp = savedVulnSlot.captured.scanTimestamp
            assertThat(scanTimestamp).isAfterOrEqualTo(beforeTest.truncatedTo(ChronoUnit.SECONDS))
            assertThat(scanTimestamp).isBeforeOrEqualTo(afterTest.plusSeconds(1))
        }
    }

    @Nested
    @DisplayName("Days Open Text Formatting")
    inner class DaysOpenTextTests {

        @Test
        @DisplayName("VS-008: Formats daysOpen as '60 days' (plural)")
        fun `addVulnerabilityFromCli_formatsDaysOpenText`() {
            // Given
            every { assetRepository.findByNameIgnoreCase(any()) } returns null
            every { vulnerabilityRepository.findByAssetAndVulnerabilityId(any(), any()) } returns null

            val savedVulnSlot = slot<Vulnerability>()
            every { vulnerabilityRepository.save(capture(savedVulnSlot)) } answers {
                savedVulnSlot.captured.apply { id = 1L }
            }

            val request = AddVulnerabilityRequestDto(
                hostname = "test-host",
                cve = "CVE-2024-TEST",
                criticality = "HIGH",
                daysOpen = 60
            )

            // When
            vulnerabilityService.addVulnerabilityFromCli(request)

            // Then
            assertThat(savedVulnSlot.captured.daysOpen).isEqualTo("60 days")
        }

        @Test
        @DisplayName("VS-009: Formats daysOpen as '1 day' (singular)")
        fun `addVulnerabilityFromCli_formatsDaysOpenSingular`() {
            // Given
            every { assetRepository.findByNameIgnoreCase(any()) } returns null
            every { vulnerabilityRepository.findByAssetAndVulnerabilityId(any(), any()) } returns null

            val savedVulnSlot = slot<Vulnerability>()
            every { vulnerabilityRepository.save(capture(savedVulnSlot)) } answers {
                savedVulnSlot.captured.apply { id = 1L }
            }

            val request = AddVulnerabilityRequestDto(
                hostname = "test-host",
                cve = "CVE-2024-TEST",
                criticality = "HIGH",
                daysOpen = 1
            )

            // When
            vulnerabilityService.addVulnerabilityFromCli(request)

            // Then
            assertThat(savedVulnSlot.captured.daysOpen).isEqualTo("1 day")
        }
    }
}
