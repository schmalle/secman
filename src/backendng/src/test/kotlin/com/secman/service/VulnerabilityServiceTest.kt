package com.secman.service

import com.secman.domain.Asset
import com.secman.domain.Vulnerability
import com.secman.domain.VulnerabilityException
import com.secman.repository.VulnerabilityRepository
import com.secman.repository.VulnerabilityExceptionRepository
import io.micronaut.test.extensions.junit5.annotation.MicronautTest
import io.mockk.every
import io.mockk.mockk
import io.mockk.verify
import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test
import java.time.LocalDateTime

/**
 * Unit tests for VulnerabilityService
 *
 * Tests business logic for:
 * - Getting current vulnerabilities (latest scan per asset)
 * - Filtering by severity and exception status
 * - Applying exception matching logic
 *
 * Uses MockK to mock repositories.
 *
 * All tests follow TDD approach - they will FAIL until service is implemented.
 *
 * Related to: Feature 004-i-want-to (VULN Role & Vulnerability Management UI)
 * Task: T008 (Unit Test VulnerabilityService)
 */
@MicronautTest
class VulnerabilityServiceTest {

    private lateinit var vulnerabilityRepository: VulnerabilityRepository
    private lateinit var vulnerabilityExceptionRepository: VulnerabilityExceptionRepository
    private lateinit var vulnerabilityService: VulnerabilityService

    @BeforeEach
    fun setup() {
        vulnerabilityRepository = mockk()
        vulnerabilityExceptionRepository = mockk()
        vulnerabilityService = VulnerabilityService(
            vulnerabilityRepository,
            vulnerabilityExceptionRepository
        )
    }

    /**
     * Test that getCurrentVulnerabilities returns only the latest scan per asset
     *
     * Business logic:
     * - Group all vulnerabilities by asset
     * - For each asset, find the maximum (latest) scan timestamp
     * - Return only vulnerabilities matching that latest timestamp
     */
    @Test
    fun `testGetCurrentVulnerabilitiesReturnsLatestPerAsset - should group by asset and return latest scan only`() {
        // Arrange
        val asset1 = createTestAsset(1L, "web-server-01", "192.168.1.10")
        val asset2 = createTestAsset(2L, "db-server-01", "192.168.1.20")

        val olderScanTime = LocalDateTime.now().minusDays(7)
        val latestScanTime = LocalDateTime.now().minusDays(1)

        // Asset 1 has vulnerabilities from 2 scans (older and latest)
        val asset1VulnOld = createTestVulnerability(1L, asset1, "CVE-2023-0001", "High", olderScanTime)
        val asset1VulnLatest1 = createTestVulnerability(2L, asset1, "CVE-2023-0001", "High", latestScanTime)
        val asset1VulnLatest2 = createTestVulnerability(3L, asset1, "CVE-2023-0002", "Medium", latestScanTime)

        // Asset 2 has vulnerabilities from latest scan only
        val asset2VulnLatest = createTestVulnerability(4L, asset2, "CVE-2023-0003", "Critical", latestScanTime)

        val allVulnerabilities = listOf(
            asset1VulnOld,
            asset1VulnLatest1,
            asset1VulnLatest2,
            asset2VulnLatest
        )

        every { vulnerabilityRepository.findAll() } returns allVulnerabilities
        every { vulnerabilityExceptionRepository.findAll() } returns emptyList()

        // Act
        val result = vulnerabilityService.getCurrentVulnerabilities(
            severity = null,
            system = null,
            exceptionStatus = null
        )

        // Assert
        assertNotNull(result)
        assertEquals(3, result.size, "Should return 3 vulnerabilities (2 from asset1 latest, 1 from asset2 latest)")

        // Verify old scan is excluded
        assertFalse(result.any { it.id == 1L }, "Old scan vulnerability should not be included")

        // Verify latest scans are included
        assertTrue(result.any { it.id == 2L }, "Asset1 latest scan vuln1 should be included")
        assertTrue(result.any { it.id == 3L }, "Asset1 latest scan vuln2 should be included")
        assertTrue(result.any { it.id == 4L }, "Asset2 latest scan vuln should be included")

        // Verify all returned vulnerabilities are from the latest scan timestamp per asset
        val asset1Results = result.filter { it.assetId == 1L }
        val asset1Timestamps = asset1Results.map { it.scanTimestamp }.distinct()
        assertEquals(1, asset1Timestamps.size, "Asset1 should have vulnerabilities from only one timestamp")
        assertEquals(latestScanTime, asset1Timestamps.first(), "Asset1 timestamp should be the latest")

        verify(exactly = 1) { vulnerabilityRepository.findAll() }
    }

    /**
     * Test severity filtering
     *
     * Business logic:
     * - When severity parameter is provided, filter vulnerabilities by exact severity match
     * - Severity values: Critical, High, Medium, Low, Informational
     */
    @Test
    fun `testGetCurrentVulnerabilitiesWithSeverityFilter - should return only vulnerabilities matching severity`() {
        // Arrange
        val asset = createTestAsset(1L, "web-server-01", "192.168.1.10")
        val scanTime = LocalDateTime.now().minusDays(1)

        val criticalVuln = createTestVulnerability(1L, asset, "CVE-2023-0001", "Critical", scanTime)
        val highVuln = createTestVulnerability(2L, asset, "CVE-2023-0002", "High", scanTime)
        val mediumVuln = createTestVulnerability(3L, asset, "CVE-2023-0003", "Medium", scanTime)

        val allVulnerabilities = listOf(criticalVuln, highVuln, mediumVuln)

        every { vulnerabilityRepository.findAll() } returns allVulnerabilities
        every { vulnerabilityExceptionRepository.findAll() } returns emptyList()

        // Act - Filter by "High" severity
        val result = vulnerabilityService.getCurrentVulnerabilities(
            severity = "High",
            system = null,
            exceptionStatus = null
        )

        // Assert
        assertNotNull(result)
        assertEquals(1, result.size, "Should return only High severity vulnerability")
        assertEquals("High", result.first().cvssSeverity, "Returned vulnerability should have High severity")
        assertEquals(2L, result.first().id, "Should return the High severity vulnerability")

        verify(exactly = 1) { vulnerabilityRepository.findAll() }
    }

    /**
     * Test system (asset name) filtering
     *
     * Business logic:
     * - When system parameter is provided, filter by exact asset name match
     */
    @Test
    fun `testGetCurrentVulnerabilitiesWithSystemFilter - should return only vulnerabilities for specified asset`() {
        // Arrange
        val asset1 = createTestAsset(1L, "web-server-01", "192.168.1.10")
        val asset2 = createTestAsset(2L, "db-server-01", "192.168.1.20")
        val scanTime = LocalDateTime.now().minusDays(1)

        val asset1Vuln = createTestVulnerability(1L, asset1, "CVE-2023-0001", "High", scanTime)
        val asset2Vuln = createTestVulnerability(2L, asset2, "CVE-2023-0002", "Medium", scanTime)

        val allVulnerabilities = listOf(asset1Vuln, asset2Vuln)

        every { vulnerabilityRepository.findAll() } returns allVulnerabilities
        every { vulnerabilityExceptionRepository.findAll() } returns emptyList()

        // Act - Filter by "web-server-01" asset name
        val result = vulnerabilityService.getCurrentVulnerabilities(
            severity = null,
            system = "web-server-01",
            exceptionStatus = null
        )

        // Assert
        assertNotNull(result)
        assertEquals(1, result.size, "Should return only vulnerabilities for web-server-01")
        assertEquals("web-server-01", result.first().assetName, "Returned vulnerability should be for web-server-01")
        assertEquals(1L, result.first().id, "Should return the web-server-01 vulnerability")

        verify(exactly = 1) { vulnerabilityRepository.findAll() }
    }

    /**
     * Test exception status filtering and hasException field calculation
     *
     * Business logic:
     * - Match vulnerabilities against active exceptions (IP-based or PRODUCT-based)
     * - Set hasException=true if any active exception matches
     * - When exceptionStatus="excepted", return only vulnerabilities with hasException=true
     * - When exceptionStatus="not-excepted", return only vulnerabilities with hasException=false
     * - When exceptionStatus="all" or null, return all vulnerabilities with hasException calculated
     */
    @Test
    fun `testGetCurrentVulnerabilitiesAppliesExceptions - should set hasException field based on active exceptions`() {
        // Arrange
        val asset1 = createTestAsset(1L, "web-server-01", "192.168.1.10")
        val asset2 = createTestAsset(2L, "db-server-01", "192.168.1.20")
        val scanTime = LocalDateTime.now().minusDays(1)

        // Vulnerability that matches IP exception
        val vulnWithIpException = createTestVulnerability(
            1L, asset1, "CVE-2023-0001", "High", scanTime, "OpenSSH 7.4"
        )

        // Vulnerability that matches PRODUCT exception
        val vulnWithProductException = createTestVulnerability(
            2L, asset2, "CVE-2023-0002", "Medium", scanTime, "Apache 2.4.0"
        )

        // Vulnerability with no exception
        val vulnNoException = createTestVulnerability(
            3L, asset2, "CVE-2023-0003", "Low", scanTime, "nginx 1.18.0"
        )

        val allVulnerabilities = listOf(vulnWithIpException, vulnWithProductException, vulnNoException)

        // Create active exceptions
        val ipException = VulnerabilityException(
            id = 1L,
            exceptionType = VulnerabilityException.ExceptionType.IP,
            targetValue = "192.168.1.10",
            reason = "Test system",
            createdBy = "admin",
            expirationDate = LocalDateTime.now().plusMonths(6)
        )

        val productException = VulnerabilityException(
            id = 2L,
            exceptionType = VulnerabilityException.ExceptionType.PRODUCT,
            targetValue = "Apache 2.4.0",
            reason = "Compensating controls",
            createdBy = "admin",
            expirationDate = null // Permanent exception
        )

        val activeExceptions = listOf(ipException, productException)

        every { vulnerabilityRepository.findAll() } returns allVulnerabilities
        every { vulnerabilityExceptionRepository.findAll() } returns activeExceptions

        // Act
        val result = vulnerabilityService.getCurrentVulnerabilities(
            severity = null,
            system = null,
            exceptionStatus = null
        )

        // Assert
        assertNotNull(result)
        assertEquals(3, result.size, "Should return all 3 vulnerabilities")

        // Verify hasException field is correctly calculated
        val vuln1Dto = result.find { it.id == 1L }
        assertNotNull(vuln1Dto)
        assertTrue(vuln1Dto!!.hasException, "Vulnerability on 192.168.1.10 should have exception (IP match)")
        assertNotNull(vuln1Dto.exceptionReason, "Exception reason should be populated")

        val vuln2Dto = result.find { it.id == 2L }
        assertNotNull(vuln2Dto)
        assertTrue(vuln2Dto!!.hasException, "Vulnerability with Apache 2.4.0 should have exception (PRODUCT match)")

        val vuln3Dto = result.find { it.id == 3L }
        assertNotNull(vuln3Dto)
        assertFalse(vuln3Dto!!.hasException, "Vulnerability with nginx should not have exception")
        assertNull(vuln3Dto!!.exceptionReason, "Exception reason should be null for non-excepted")

        verify(exactly = 1) { vulnerabilityRepository.findAll() }
        verify(exactly = 1) { vulnerabilityExceptionRepository.findAll() }
    }

    /**
     * Test filtering by exception status = "excepted"
     */
    @Test
    fun `testGetCurrentVulnerabilitiesExceptedFilter - should return only excepted vulnerabilities`() {
        // Arrange
        val asset = createTestAsset(1L, "web-server-01", "192.168.1.10")
        val scanTime = LocalDateTime.now().minusDays(1)

        val exceptedVuln = createTestVulnerability(1L, asset, "CVE-2023-0001", "High", scanTime, "OpenSSH 7.4")
        val notExceptedVuln = createTestVulnerability(2L, asset, "CVE-2023-0002", "Medium", scanTime, "nginx 1.18.0")

        val allVulnerabilities = listOf(exceptedVuln, notExceptedVuln)

        val ipException = VulnerabilityException(
            id = 1L,
            exceptionType = VulnerabilityException.ExceptionType.IP,
            targetValue = "192.168.1.10",
            reason = "Test system",
            createdBy = "admin",
            expirationDate = null
        )

        every { vulnerabilityRepository.findAll() } returns allVulnerabilities
        every { vulnerabilityExceptionRepository.findAll() } returns listOf(ipException)

        // Act - Filter by exceptionStatus="excepted"
        val result = vulnerabilityService.getCurrentVulnerabilities(
            severity = null,
            system = null,
            exceptionStatus = "excepted"
        )

        // Assert
        assertNotNull(result)
        assertEquals(2, result.size, "Both vulnerabilities on this IP are excepted")
        assertTrue(result.all { it.hasException }, "All returned vulnerabilities should have hasException=true")

        verify(exactly = 1) { vulnerabilityRepository.findAll() }
    }

    /**
     * Test filtering by exception status = "not-excepted"
     */
    @Test
    fun `testGetCurrentVulnerabilitiesNotExceptedFilter - should return only non-excepted vulnerabilities`() {
        // Arrange
        val asset1 = createTestAsset(1L, "web-server-01", "192.168.1.10")
        val asset2 = createTestAsset(2L, "db-server-01", "192.168.1.20")
        val scanTime = LocalDateTime.now().minusDays(1)

        val exceptedVuln = createTestVulnerability(1L, asset1, "CVE-2023-0001", "High", scanTime, "OpenSSH 7.4")
        val notExceptedVuln = createTestVulnerability(2L, asset2, "CVE-2023-0002", "Medium", scanTime, "nginx 1.18.0")

        val allVulnerabilities = listOf(exceptedVuln, notExceptedVuln)

        val ipException = VulnerabilityException(
            id = 1L,
            exceptionType = VulnerabilityException.ExceptionType.IP,
            targetValue = "192.168.1.10",
            reason = "Test system",
            createdBy = "admin",
            expirationDate = null
        )

        every { vulnerabilityRepository.findAll() } returns allVulnerabilities
        every { vulnerabilityExceptionRepository.findAll() } returns listOf(ipException)

        // Act - Filter by exceptionStatus="not-excepted"
        val result = vulnerabilityService.getCurrentVulnerabilities(
            severity = null,
            system = null,
            exceptionStatus = "not-excepted"
        )

        // Assert
        assertNotNull(result)
        assertEquals(1, result.size, "Should return only non-excepted vulnerability")
        assertFalse(result.all { it.hasException }, "All returned vulnerabilities should have hasException=false")
        assertEquals(2L, result.first().id, "Should return the non-excepted vulnerability")

        verify(exactly = 1) { vulnerabilityRepository.findAll() }
    }

    /**
     * Test that expired exceptions are not applied
     */
    @Test
    fun `testGetCurrentVulnerabilitiesIgnoresExpiredExceptions - should not apply expired exceptions`() {
        // Arrange
        val asset = createTestAsset(1L, "web-server-01", "192.168.1.10")
        val scanTime = LocalDateTime.now().minusDays(1)

        val vuln = createTestVulnerability(1L, asset, "CVE-2023-0001", "High", scanTime, "OpenSSH 7.4")

        val expiredException = VulnerabilityException(
            id = 1L,
            exceptionType = VulnerabilityException.ExceptionType.IP,
            targetValue = "192.168.1.10",
            reason = "Temporary exception",
            createdBy = "admin",
            expirationDate = LocalDateTime.now().minusDays(1) // Expired yesterday
        )

        every { vulnerabilityRepository.findAll() } returns listOf(vuln)
        every { vulnerabilityExceptionRepository.findAll() } returns listOf(expiredException)

        // Act
        val result = vulnerabilityService.getCurrentVulnerabilities(
            severity = null,
            system = null,
            exceptionStatus = null
        )

        // Assert
        assertNotNull(result)
        assertEquals(1, result.size)
        assertFalse(result.first().hasException, "Vulnerability should NOT have exception (exception expired)")
        assertNull(result.first().exceptionReason, "Exception reason should be null for expired exception")

        verify(exactly = 1) { vulnerabilityRepository.findAll() }
        verify(exactly = 1) { vulnerabilityExceptionRepository.findAll() }
    }

    /**
     * Test combined filters (severity + exceptionStatus)
     */
    @Test
    fun `testGetCurrentVulnerabilitiesWithMultipleFilters - should apply all filters correctly`() {
        // Arrange
        val asset = createTestAsset(1L, "web-server-01", "192.168.1.10")
        val scanTime = LocalDateTime.now().minusDays(1)

        val highExceptedVuln = createTestVulnerability(1L, asset, "CVE-2023-0001", "High", scanTime, "OpenSSH 7.4")
        val highNotExceptedVuln = createTestVulnerability(2L, asset, "CVE-2023-0002", "High", scanTime, "nginx 1.18.0")
        val mediumExceptedVuln = createTestVulnerability(3L, asset, "CVE-2023-0003", "Medium", scanTime, "Apache 2.4.0")

        val allVulnerabilities = listOf(highExceptedVuln, highNotExceptedVuln, mediumExceptedVuln)

        val ipException = VulnerabilityException(
            id = 1L,
            exceptionType = VulnerabilityException.ExceptionType.IP,
            targetValue = "192.168.1.10",
            reason = "Test system",
            createdBy = "admin",
            expirationDate = null
        )

        every { vulnerabilityRepository.findAll() } returns allVulnerabilities
        every { vulnerabilityExceptionRepository.findAll() } returns listOf(ipException)

        // Act - Filter by severity=High AND exceptionStatus=excepted
        val result = vulnerabilityService.getCurrentVulnerabilities(
            severity = "High",
            system = null,
            exceptionStatus = "excepted"
        )

        // Assert
        assertNotNull(result)
        assertEquals(2, result.size, "Should return only High severity excepted vulnerabilities")
        assertTrue(result.all { it.cvssSeverity == "High" }, "All should be High severity")
        assertTrue(result.all { it.hasException }, "All should have exceptions")

        verify(exactly = 1) { vulnerabilityRepository.findAll() }
    }

    // ============================================================================
    // Helper methods for creating test data
    // ============================================================================

    private fun createTestAsset(id: Long, name: String, ip: String): Asset {
        return Asset(
            id = id,
            name = name,
            type = "Server",
            owner = "IT Team",
            ip = ip
        )
    }

    private fun createTestVulnerability(
        id: Long,
        asset: Asset,
        cveId: String,
        severity: String,
        scanTimestamp: LocalDateTime,
        productVersion: String? = null
    ): Vulnerability {
        return Vulnerability(
            id = id,
            asset = asset,
            vulnerabilityId = cveId,
            cvssSeverity = severity,
            vulnerableProductVersions = productVersion,
            daysOpen = "30 days",
            scanTimestamp = scanTimestamp
        )
    }
}
