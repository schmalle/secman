package com.secman.contract

import io.micronaut.http.HttpRequest
import io.micronaut.http.HttpStatus
import io.micronaut.http.client.HttpClient
import io.micronaut.http.client.annotation.Client
import io.micronaut.http.client.multipart.MultipartBody
import io.micronaut.test.extensions.junit5.annotation.MicronautTest
import jakarta.inject.Inject
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.DisplayName
import java.io.File
import java.nio.file.Files

/**
 * Contract test for POST /api/import/upload-vulnerability-xlsx endpoint
 *
 * Tests API contract compliance:
 * - Request: multipart/form-data with xlsxFile and scanDate
 * - Response: 200 OK with VulnerabilityImportResponse schema
 * - Error cases: 400 Bad Request, 401 Unauthorized
 *
 * CRITICAL: These tests MUST FAIL before implementation exists.
 * This validates the TDD approach - write tests first, then implement.
 */
@MicronautTest
class VulnerabilityImportContractTest {

    @Inject
    @field:Client("/")
    lateinit var client: HttpClient

    @Test
    @DisplayName("POST /api/import/upload-vulnerability-xlsx with valid file and scan date returns 200 OK")
    fun testUploadVulnerabilityXlsxSuccess() {
        // Arrange: Create a minimal valid .xlsx file
        val testFile = createTestExcelFile()
        val scanDate = "2025-10-03T14:30:00"

        val requestBody = MultipartBody.builder()
            .addPart("xlsxFile", testFile.name, testFile.readBytes())
            .addPart("scanDate", scanDate)
            .build()

        val request = HttpRequest.POST("/api/import/upload-vulnerability-xlsx", requestBody)
            .contentType("multipart/form-data")
            .header("Authorization", "Bearer ${getValidToken()}")

        // Act & Assert
        val response = client.toBlocking().exchange(request, Map::class.java)

        // Assert response status
        assertEquals(HttpStatus.OK, response.status)

        // Assert response schema
        val body = response.body() as Map<*, *>
        assertTrue(body.containsKey("message"), "Response must contain 'message' field")
        assertTrue(body.containsKey("imported"), "Response must contain 'imported' field")
        assertTrue(body.containsKey("skipped"), "Response must contain 'skipped' field")
        assertTrue(body.containsKey("assetsCreated"), "Response must contain 'assetsCreated' field")

        // Assert response types
        assertTrue(body["message"] is String, "'message' must be a String")
        assertTrue(body["imported"] is Number, "'imported' must be a Number")
        assertTrue(body["skipped"] is Number, "'skipped' must be a Number")
        assertTrue(body["assetsCreated"] is Number, "'assetsCreated' must be a Number")

        // Cleanup
        testFile.delete()
    }

    @Test
    @DisplayName("POST /api/import/upload-vulnerability-xlsx without scan date returns 400 Bad Request")
    fun testUploadVulnerabilityXlsxMissingScanDate() {
        // Arrange: Create file but omit scanDate
        val testFile = createTestExcelFile()

        val requestBody = MultipartBody.builder()
            .addPart("xlsxFile", testFile.name, testFile.readBytes())
            // Missing scanDate parameter
            .build()

        val request = HttpRequest.POST("/api/import/upload-vulnerability-xlsx", requestBody)
            .contentType("multipart/form-data")
            .header("Authorization", "Bearer ${getValidToken()}")

        // Act & Assert
        try {
            client.toBlocking().exchange(request, Map::class.java)
            fail("Expected 400 Bad Request when scanDate is missing")
        } catch (e: io.micronaut.http.client.exceptions.HttpClientResponseException) {
            assertEquals(HttpStatus.BAD_REQUEST, e.status)
        } finally {
            testFile.delete()
        }
    }

    @Test
    @DisplayName("POST /api/import/upload-vulnerability-xlsx with invalid file format returns 400 Bad Request")
    fun testUploadVulnerabilityXlsxInvalidFileFormat() {
        // Arrange: Create a text file instead of .xlsx
        val testFile = File.createTempFile("test", ".txt")
        testFile.writeText("This is not an Excel file")
        val scanDate = "2025-10-03T14:30:00"

        val requestBody = MultipartBody.builder()
            .addPart("xlsxFile", testFile.name, testFile.readBytes())
            .addPart("scanDate", scanDate)
            .build()

        val request = HttpRequest.POST("/api/import/upload-vulnerability-xlsx", requestBody)
            .contentType("multipart/form-data")
            .header("Authorization", "Bearer ${getValidToken()}")

        // Act & Assert
        try {
            client.toBlocking().exchange(request, Map::class.java)
            fail("Expected 400 Bad Request for invalid file format")
        } catch (e: io.micronaut.http.client.exceptions.HttpClientResponseException) {
            assertEquals(HttpStatus.BAD_REQUEST, e.status)
            val errorBody = e.response.getBody(Map::class.java).orElse(null)
            assertNotNull(errorBody, "Error response should have a body")
            assertTrue(errorBody!!.containsKey("error"), "Error response should contain 'error' field")
        } finally {
            testFile.delete()
        }
    }

    @Test
    @DisplayName("POST /api/import/upload-vulnerability-xlsx without authentication returns 401 Unauthorized")
    fun testUploadVulnerabilityXlsxUnauthorized() {
        // Arrange: Create file but don't send auth token
        val testFile = createTestExcelFile()
        val scanDate = "2025-10-03T14:30:00"

        val requestBody = MultipartBody.builder()
            .addPart("xlsxFile", testFile.name, testFile.readBytes())
            .addPart("scanDate", scanDate)
            .build()

        val request = HttpRequest.POST("/api/import/upload-vulnerability-xlsx", requestBody)
            .contentType("multipart/form-data")
        // No Authorization header

        // Act & Assert
        try {
            client.toBlocking().exchange(request, Map::class.java)
            fail("Expected 401 Unauthorized when no auth token provided")
        } catch (e: io.micronaut.http.client.exceptions.HttpClientResponseException) {
            assertEquals(HttpStatus.UNAUTHORIZED, e.status)
        } finally {
            testFile.delete()
        }
    }

    @Test
    @DisplayName("POST /api/import/upload-vulnerability-xlsx response includes skippedDetails array")
    fun testUploadVulnerabilityXlsxResponseIncludesSkippedDetails() {
        // Arrange: Create file with some invalid data
        val testFile = createTestExcelFile()
        val scanDate = "2025-10-03T14:30:00"

        val requestBody = MultipartBody.builder()
            .addPart("xlsxFile", testFile.name, testFile.readBytes())
            .addPart("scanDate", scanDate)
            .build()

        val request = HttpRequest.POST("/api/import/upload-vulnerability-xlsx", requestBody)
            .contentType("multipart/form-data")
            .header("Authorization", "Bearer ${getValidToken()}")

        // Act
        val response = client.toBlocking().exchange(request, Map::class.java)

        // Assert
        val body = response.body() as Map<*, *>

        // skippedDetails is optional but if present, must be an array
        if (body.containsKey("skippedDetails")) {
            assertTrue(body["skippedDetails"] is List<*>, "'skippedDetails' must be an array")

            val skippedDetails = body["skippedDetails"] as List<*>
            if (skippedDetails.isNotEmpty()) {
                val firstDetail = skippedDetails[0] as Map<*, *>
                assertTrue(firstDetail.containsKey("row"), "Skipped detail must contain 'row' field")
                assertTrue(firstDetail.containsKey("reason"), "Skipped detail must contain 'reason' field")
            }
        }

        // Cleanup
        testFile.delete()
    }

    // Helper Methods

    /**
     * Create a minimal valid .xlsx file for testing
     * This is a placeholder - actual implementation will use Apache POI
     */
    private fun createTestExcelFile(): File {
        val testFile = File.createTempFile("test-vulnerabilities", ".xlsx")
        // For now, create an empty file
        // TODO: Use Apache POI to create a valid .xlsx file with test data
        // This will be replaced when implementing the actual import functionality
        testFile.writeBytes(byteArrayOf())
        return testFile
    }

    /**
     * Get a valid JWT token for testing
     * This should use the existing auth system
     */
    private fun getValidToken(): String {
        // TODO: Replace with actual token generation from auth system
        // For now, return a placeholder that will fail until auth is integrated
        return "test-token-placeholder"
    }
}
