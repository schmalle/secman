package com.secman.contract

import io.micronaut.http.HttpRequest
import io.micronaut.http.HttpStatus
import io.micronaut.http.client.HttpClient
import io.micronaut.http.client.annotation.Client
import io.micronaut.test.extensions.junit5.annotation.MicronautTest
import jakarta.inject.Inject
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.DisplayName

/**
 * Contract test for POST /api/vulnerabilities/cleanup-duplicates endpoint
 *
 * Tests API contract compliance:
 * - Request: POST with no body (application/json)
 * - Response: 200 OK with VulnerabilityCleanupResult schema
 * - Access control: ADMIN role required (403 for non-ADMIN)
 * - Error cases: 401 Unauthorized, 403 Forbidden
 *
 * CRITICAL: These tests MUST FAIL before implementation exists.
 * This validates the TDD approach - write tests first, then implement.
 *
 * Feature: Vulnerability Duplicate Cleanup
 * User Story: As an ADMIN, I want to cleanup duplicate vulnerabilities
 *             so that the database remains clean and reporting is accurate
 */
@MicronautTest
class VulnerabilityCleanupContractTest {

    @Inject
    @field:Client("/")
    lateinit var client: HttpClient

    @Test
    @DisplayName("POST /api/vulnerabilities/cleanup-duplicates with ADMIN token returns 200 OK with cleanup statistics")
    fun testCleanupDuplicatesSuccess() {
        // Arrange: ADMIN user authentication
        val request = HttpRequest.POST<Unit>("/api/vulnerabilities/cleanup-duplicates", null)
            .header("Authorization", "Bearer ${getAdminToken()}")

        // Act
        val response = client.toBlocking().exchange(request, Map::class.java)

        // Assert response status
        assertEquals(HttpStatus.OK, response.status)

        // Assert response schema
        val body = response.body() as Map<*, *>
        assertTrue(body.containsKey("totalScanned"), "Response must contain 'totalScanned' field")
        assertTrue(body.containsKey("duplicatesFound"), "Response must contain 'duplicatesFound' field")
        assertTrue(body.containsKey("duplicatesRemoved"), "Response must contain 'duplicatesRemoved' field")
        assertTrue(body.containsKey("uniqueVulnerabilitiesRemaining"),
            "Response must contain 'uniqueVulnerabilitiesRemaining' field")
        assertTrue(body.containsKey("message"), "Response must contain 'message' field")

        // Assert response types
        assertTrue(body["totalScanned"] is Number, "'totalScanned' must be a Number")
        assertTrue(body["duplicatesFound"] is Number, "'duplicatesFound' must be a Number")
        assertTrue(body["duplicatesRemoved"] is Number, "'duplicatesRemoved' must be a Number")
        assertTrue(body["uniqueVulnerabilitiesRemaining"] is Number,
            "'uniqueVulnerabilitiesRemaining' must be a Number")
        assertTrue(body["message"] is String, "'message' must be a String")

        // Assert business logic constraints
        val totalScanned = (body["totalScanned"] as Number).toInt()
        val duplicatesRemoved = (body["duplicatesRemoved"] as Number).toInt()
        val uniqueRemaining = (body["uniqueVulnerabilitiesRemaining"] as Number).toInt()

        assertTrue(duplicatesRemoved >= 0, "duplicatesRemoved must be non-negative")
        assertTrue(uniqueRemaining >= 0, "uniqueVulnerabilitiesRemaining must be non-negative")
        assertTrue(totalScanned >= 0, "totalScanned must be non-negative")
        assertEquals(totalScanned - duplicatesRemoved, uniqueRemaining,
            "totalScanned - duplicatesRemoved should equal uniqueVulnerabilitiesRemaining")
    }

    @Test
    @DisplayName("POST /api/vulnerabilities/cleanup-duplicates without authentication returns 401 Unauthorized")
    fun testCleanupDuplicatesUnauthorized() {
        // Arrange: No auth token
        val request = HttpRequest.POST<Unit>("/api/vulnerabilities/cleanup-duplicates", null)
        // No Authorization header

        // Act & Assert
        try {
            client.toBlocking().exchange(request, Map::class.java)
            fail("Expected 401 Unauthorized when no auth token provided")
        } catch (e: io.micronaut.http.client.exceptions.HttpClientResponseException) {
            assertEquals(HttpStatus.UNAUTHORIZED, e.status)
        }
    }

    @Test
    @DisplayName("POST /api/vulnerabilities/cleanup-duplicates with non-ADMIN token returns 403 Forbidden")
    fun testCleanupDuplicatesForbidden() {
        // Arrange: Regular USER token (not ADMIN)
        val request = HttpRequest.POST<Unit>("/api/vulnerabilities/cleanup-duplicates", null)
            .header("Authorization", "Bearer ${getRegularUserToken()}")

        // Act & Assert
        try {
            client.toBlocking().exchange(request, Map::class.java)
            fail("Expected 403 Forbidden when non-ADMIN user attempts cleanup")
        } catch (e: io.micronaut.http.client.exceptions.HttpClientResponseException) {
            assertEquals(HttpStatus.FORBIDDEN, e.status)
        }
    }

    @Test
    @DisplayName("POST /api/vulnerabilities/cleanup-duplicates is idempotent (can be called multiple times safely)")
    fun testCleanupDuplicatesIdempotent() {
        // Arrange: ADMIN user authentication
        val request = HttpRequest.POST<Unit>("/api/vulnerabilities/cleanup-duplicates", null)
            .header("Authorization", "Bearer ${getAdminToken()}")

        // Act: Call cleanup twice
        val response1 = client.toBlocking().exchange(request, Map::class.java)
        val response2 = client.toBlocking().exchange(request, Map::class.java)

        // Assert: Both requests succeed
        assertEquals(HttpStatus.OK, response1.status)
        assertEquals(HttpStatus.OK, response2.status)

        // Assert: Second call removes 0 duplicates (already cleaned)
        val body2 = response2.body() as Map<*, *>
        val duplicatesRemoved2 = (body2["duplicatesRemoved"] as Number).toInt()
        assertEquals(0, duplicatesRemoved2,
            "Second cleanup call should remove 0 duplicates (database already clean)")
    }

    @Test
    @DisplayName("POST /api/vulnerabilities/cleanup-duplicates returns meaningful message when no duplicates found")
    fun testCleanupDuplicatesNoDuplicates() {
        // Arrange: ADMIN user authentication
        // First, cleanup any existing duplicates
        val cleanupRequest = HttpRequest.POST<Unit>("/api/vulnerabilities/cleanup-duplicates", null)
            .header("Authorization", "Bearer ${getAdminToken()}")
        client.toBlocking().exchange(cleanupRequest, Map::class.java)

        // Act: Call cleanup again (should find no duplicates)
        val request = HttpRequest.POST<Unit>("/api/vulnerabilities/cleanup-duplicates", null)
            .header("Authorization", "Bearer ${getAdminToken()}")
        val response = client.toBlocking().exchange(request, Map::class.java)

        // Assert
        assertEquals(HttpStatus.OK, response.status)
        val body = response.body() as Map<*, *>
        val duplicatesFound = (body["duplicatesFound"] as Number).toInt()
        val duplicatesRemoved = (body["duplicatesRemoved"] as Number).toInt()
        val message = body["message"] as String

        assertEquals(0, duplicatesFound, "Should find 0 duplicates after cleanup")
        assertEquals(0, duplicatesRemoved, "Should remove 0 duplicates after cleanup")
        assertTrue(message.contains("clean", ignoreCase = true) ||
                   message.contains("No duplicate", ignoreCase = true),
            "Message should indicate database is clean or no duplicates found")
    }

    // Helper Methods

    /**
     * Get a valid JWT token for ADMIN user for testing
     */
    private fun getAdminToken(): String {
        // TODO: Replace with actual token generation from auth system
        // For now, return a placeholder that will fail until auth is integrated
        return "admin-test-token-placeholder"
    }

    /**
     * Get a valid JWT token for regular (non-ADMIN) user for testing
     */
    private fun getRegularUserToken(): String {
        // TODO: Replace with actual token generation from auth system
        // For now, return a placeholder that will fail until auth is integrated
        return "user-test-token-placeholder"
    }
}
