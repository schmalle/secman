package com.secman.mcp.tools

import com.secman.domain.McpOperation
import com.secman.dto.AddVulnerabilityRequestDto
import com.secman.dto.mcp.McpExecutionContext
import com.secman.service.VulnerabilityService
import jakarta.inject.Inject
import jakarta.inject.Singleton

/**
 * MCP tool for adding a vulnerability to an asset.
 * Feature: 063-e2e-vuln-exception
 *
 * ADMIN or VULN role is required via User Delegation.
 * Creates the asset if it doesn't exist, then adds/updates the vulnerability.
 *
 * Input parameters:
 * - hostname (required): Asset hostname/name to add vulnerability to
 * - cve (required): CVE identifier (e.g., CVE-2024-1234)
 * - criticality (required): CRITICAL, HIGH, MEDIUM, or LOW
 * - daysOpen (optional): Number of days the vulnerability has been open (default: 0)
 * - owner (optional): Owner to assign to newly created asset (default: MCP-IMPORT)
 *
 * Output:
 * - vulnerabilityId: ID of created/updated vulnerability
 * - assetId: ID of the asset
 * - assetCreated: Whether the asset was newly created
 * - vulnerabilityCreated: Whether the vulnerability was newly created
 */
@Singleton
class AddVulnerabilityTool(
    @Inject private val vulnerabilityService: VulnerabilityService
) : McpTool {

    override val name = "add_vulnerability"
    override val description = "Add a vulnerability to an asset. Creates the asset if it doesn't exist. (ADMIN or VULN role required, requires User Delegation)"
    override val operation = McpOperation.WRITE

    override val inputSchema = mapOf(
        "type" to "object",
        "properties" to mapOf(
            "hostname" to mapOf(
                "type" to "string",
                "description" to "Hostname or asset name to add vulnerability to"
            ),
            "cve" to mapOf(
                "type" to "string",
                "description" to "CVE identifier (e.g., CVE-2024-1234)"
            ),
            "criticality" to mapOf(
                "type" to "string",
                "enum" to listOf("CRITICAL", "HIGH", "MEDIUM", "LOW"),
                "description" to "Vulnerability severity level"
            ),
            "daysOpen" to mapOf(
                "type" to "integer",
                "minimum" to 0,
                "description" to "Number of days the vulnerability has been open (default: 0, used for testing)"
            ),
            "owner" to mapOf(
                "type" to "string",
                "description" to "Owner to assign to newly created asset (default: MCP-IMPORT)"
            )
        ),
        "required" to listOf("hostname", "cve", "criticality")
    )

    override suspend fun execute(arguments: Map<String, Any>, context: McpExecutionContext): McpToolResult {
        // Require User Delegation for audit trail
        if (!context.hasDelegation()) {
            return McpToolResult.error(
                "DELEGATION_REQUIRED",
                "User Delegation must be enabled to use this tool"
            )
        }

        // Require ADMIN or VULN role
        val hasVulnRole = context.delegatedUserRoles?.contains("VULN") == true
        if (!context.isAdmin && !hasVulnRole) {
            return McpToolResult.error(
                "ROLE_REQUIRED",
                "ADMIN or VULN role required to add vulnerabilities"
            )
        }

        // Extract and validate required parameters
        val hostname = (arguments["hostname"] as? String)?.trim()
        val cve = (arguments["cve"] as? String)?.trim()
        val criticality = (arguments["criticality"] as? String)?.trim()?.uppercase()

        if (hostname.isNullOrBlank()) {
            return McpToolResult.error("VALIDATION_ERROR", "Hostname is required and cannot be blank")
        }

        if (cve.isNullOrBlank()) {
            return McpToolResult.error("VALIDATION_ERROR", "CVE is required and cannot be blank")
        }

        if (criticality.isNullOrBlank()) {
            return McpToolResult.error("VALIDATION_ERROR", "Criticality is required and cannot be blank")
        }

        // Validate criticality value
        val validCriticalities = listOf("CRITICAL", "HIGH", "MEDIUM", "LOW")
        if (criticality !in validCriticalities) {
            return McpToolResult.error(
                "VALIDATION_ERROR",
                "Invalid criticality: '$criticality'. Must be one of: ${validCriticalities.joinToString(", ")}"
            )
        }

        // Extract optional parameters
        val daysOpen = when (val rawDaysOpen = arguments["daysOpen"]) {
            is Number -> rawDaysOpen.toInt()
            is String -> rawDaysOpen.toIntOrNull() ?: 0
            else -> 0
        }

        if (daysOpen < 0) {
            return McpToolResult.error("VALIDATION_ERROR", "Days open must be a positive number or zero")
        }

        try {
            // Create request DTO
            val request = AddVulnerabilityRequestDto(
                hostname = hostname,
                cve = cve,
                criticality = criticality,
                daysOpen = daysOpen
            )

            // Call the service
            val response = vulnerabilityService.addVulnerabilityFromCli(request)

            val isNewVuln = response.operation == "CREATED"
            val result = mapOf(
                "success" to response.success,
                "vulnerabilityId" to response.vulnerabilityId,
                "assetId" to response.assetId,
                "assetName" to response.assetName,
                "assetCreated" to response.assetCreated,
                "vulnerabilityCreated" to isNewVuln,
                "cve" to cve,
                "criticality" to criticality,
                "daysOpen" to daysOpen,
                "message" to buildMessage(response.assetCreated, isNewVuln, hostname, cve)
            )

            return McpToolResult.success(result)

        } catch (e: Exception) {
            return McpToolResult.error("EXECUTION_ERROR", "Failed to add vulnerability: ${e.message}")
        }
    }

    private fun buildMessage(assetCreated: Boolean, vulnCreated: Boolean, hostname: String, cve: String): String {
        val assetMsg = if (assetCreated) "Created new asset '$hostname'" else "Found existing asset '$hostname'"
        val vulnMsg = if (vulnCreated) "added new vulnerability $cve" else "updated existing vulnerability $cve"
        return "$assetMsg, $vulnMsg"
    }
}
