package com.secman.mcp.tools

import com.secman.domain.McpOperation
import com.secman.service.RequirementService
import jakarta.inject.Inject
import jakarta.inject.Singleton

/**
 * MCP tool for creating new security requirements.
 */
@Singleton
class CreateRequirementTool(
    @Inject private val requirementService: RequirementService
) : McpTool {

    override val name = "create_requirement"
    override val description = "Create a new security requirement"
    override val operation = McpOperation.WRITE

    override val inputSchema = mapOf(
        "type" to "object",
        "properties" to mapOf(
            "title" to mapOf(
                "type" to "string",
                "description" to "Requirement title",
                "minLength" to 1,
                "maxLength" to 200
            ),
            "description" to mapOf(
                "type" to "string",
                "description" to "Detailed requirement description",
                "maxLength" to 5000
            ),
            "priority" to mapOf(
                "type" to "string",
                "enum" to listOf("LOW", "MEDIUM", "HIGH", "CRITICAL"),
                "description" to "Priority level",
                "default" to "MEDIUM"
            ),
            "tags" to mapOf(
                "type" to "array",
                "items" to mapOf("type" to "string"),
                "description" to "Tags to categorize the requirement",
                "maxItems" to 20
            ),
            "category" to mapOf(
                "type" to "string",
                "description" to "Requirement category",
                "maxLength" to 100
            ),
            "compliance_frameworks" to mapOf(
                "type" to "array",
                "items" to mapOf("type" to "string"),
                "description" to "Applicable compliance frameworks (e.g., GDPR, SOX, PCI-DSS)",
                "maxItems" to 10
            ),
            "acceptance_criteria" to mapOf(
                "type" to "string",
                "description" to "Criteria for requirement acceptance",
                "maxLength" to 2000
            )
        ),
        "required" to listOf("title", "description")
    )

    override suspend fun execute(arguments: Map<String, Any>): McpToolResult {
        val title = arguments["title"] as? String
        val description = arguments["description"] as? String

        if (title.isNullOrBlank()) {
            return McpToolResult.error("INVALID_PARAMETER", "Title is required and cannot be empty")
        }

        if (description.isNullOrBlank()) {
            return McpToolResult.error("INVALID_PARAMETER", "Description is required and cannot be empty")
        }

        if (title.length > 200) {
            return McpToolResult.error("INVALID_PARAMETER", "Title cannot exceed 200 characters")
        }

        if (description.length > 5000) {
            return McpToolResult.error("INVALID_PARAMETER", "Description cannot exceed 5000 characters")
        }

        val priority = arguments["priority"] as? String ?: "MEDIUM"
        val tags = (arguments["tags"] as? List<*>)?.filterIsInstance<String>() ?: emptyList()
        val category = arguments["category"] as? String
        val complianceFrameworks = (arguments["compliance_frameworks"] as? List<*>)?.filterIsInstance<String>() ?: emptyList()
        val acceptanceCriteria = arguments["acceptance_criteria"] as? String

        // Validate priority
        if (priority !in listOf("LOW", "MEDIUM", "HIGH", "CRITICAL")) {
            return McpToolResult.error("INVALID_PARAMETER", "Invalid priority. Must be one of: LOW, MEDIUM, HIGH, CRITICAL")
        }

        // Validate tag count
        if (tags.size > 20) {
            return McpToolResult.error("INVALID_PARAMETER", "Cannot have more than 20 tags")
        }

        // Validate compliance frameworks count
        if (complianceFrameworks.size > 10) {
            return McpToolResult.error("INVALID_PARAMETER", "Cannot have more than 10 compliance frameworks")
        }

        try {
            val createRequest = mapOf(
                "title" to title,
                "description" to description,
                "priority" to priority,
                "tags" to tags,
                "category" to category,
                "complianceFrameworks" to complianceFrameworks,
                "acceptanceCriteria" to acceptanceCriteria
            ).filterValues { it != null }

            val createdRequirement = requirementService.createRequirement(createRequest)

            val result = mapOf(
                "id" to createdRequirement.id,
                "title" to createdRequirement.title,
                "description" to createdRequirement.description,
                "status" to createdRequirement.status.name,
                "priority" to createdRequirement.priority.name,
                "tags" to createdRequirement.tags.map { it.name },
                "createdAt" to createdRequirement.createdAt.toString(),
                "createdBy" to createdRequirement.createdBy?.username
            )

            val metadata = mapOf(
                "operation" to "create",
                "resourceType" to "requirement",
                "success" to true,
                "timestamp" to System.currentTimeMillis()
            )

            return McpToolResult.success(result, metadata)

        } catch (e: IllegalArgumentException) {
            return McpToolResult.error("VALIDATION_ERROR", "Invalid requirement data: ${e.message}")
        } catch (e: Exception) {
            return McpToolResult.error("EXECUTION_ERROR", "Failed to create requirement: ${e.message}")
        }
    }
}