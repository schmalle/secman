package com.secman.mcp.tools

import com.secman.domain.McpOperation
import com.secman.service.RiskAssessmentService
import jakarta.inject.Inject
import jakarta.inject.Singleton

/**
 * MCP tool for retrieving risk assessments with filtering and pagination.
 */
@Singleton
class GetAssessmentsTool(
    @Inject private val riskAssessmentService: RiskAssessmentService
) : McpTool {

    override val name = "get_assessments"
    override val description = "Retrieve risk assessments with optional filtering and pagination"
    override val operation = McpOperation.READ

    override val inputSchema = mapOf(
        "type" to "object",
        "properties" to mapOf(
            "limit" to mapOf(
                "type" to "number",
                "description" to "Maximum number of assessments to return (max 100)",
                "default" to 20,
                "maximum" to 100
            ),
            "offset" to mapOf(
                "type" to "number",
                "description" to "Number of assessments to skip",
                "default" to 0,
                "minimum" to 0
            ),
            "status" to mapOf(
                "type" to "string",
                "enum" to listOf("DRAFT", "IN_PROGRESS", "COMPLETED", "ARCHIVED"),
                "description" to "Filter by assessment status"
            ),
            "risk_level" to mapOf(
                "type" to "string",
                "enum" to listOf("LOW", "MEDIUM", "HIGH", "CRITICAL"),
                "description" to "Filter by risk level"
            ),
            "assessment_type" to mapOf(
                "type" to "string",
                "enum" to listOf("SECURITY", "PRIVACY", "COMPLIANCE", "OPERATIONAL"),
                "description" to "Filter by assessment type"
            ),
            "tags" to mapOf(
                "type" to "array",
                "items" to mapOf("type" to "string"),
                "description" to "Filter by tags"
            ),
            "created_after" to mapOf(
                "type" to "string",
                "format" to "date-time",
                "description" to "Filter assessments created after this date (ISO 8601 format)"
            ),
            "created_before" to mapOf(
                "type" to "string",
                "format" to "date-time",
                "description" to "Filter assessments created before this date (ISO 8601 format)"
            ),
            "include_findings" to mapOf(
                "type" to "boolean",
                "description" to "Include detailed findings in the response",
                "default" to true
            )
        )
    )

    override suspend fun execute(arguments: Map<String, Any>): McpToolResult {
        val limit = (arguments["limit"] as? Number)?.toInt() ?: 20
        val offset = (arguments["offset"] as? Number)?.toInt() ?: 0
        val status = arguments["status"] as? String
        val riskLevel = arguments["risk_level"] as? String
        val assessmentType = arguments["assessment_type"] as? String
        val tags = (arguments["tags"] as? List<*>)?.filterIsInstance<String>()
        val createdAfter = arguments["created_after"] as? String
        val createdBefore = arguments["created_before"] as? String
        val includeFindings = arguments["include_findings"] as? Boolean ?: true

        // Validate limit
        if (limit > 100) {
            return McpToolResult.error("INVALID_PARAMETER", "Limit cannot exceed 100")
        }

        // Validate offset
        if (offset < 0) {
            return McpToolResult.error("INVALID_PARAMETER", "Offset cannot be negative")
        }

        // Validate enum values
        if (status != null && status !in listOf("DRAFT", "IN_PROGRESS", "COMPLETED", "ARCHIVED")) {
            return McpToolResult.error("INVALID_PARAMETER", "Invalid status value")
        }

        if (riskLevel != null && riskLevel !in listOf("LOW", "MEDIUM", "HIGH", "CRITICAL")) {
            return McpToolResult.error("INVALID_PARAMETER", "Invalid risk_level value")
        }

        if (assessmentType != null && assessmentType !in listOf("SECURITY", "PRIVACY", "COMPLIANCE", "OPERATIONAL")) {
            return McpToolResult.error("INVALID_PARAMETER", "Invalid assessment_type value")
        }

        try {
            val filterCriteria = mutableMapOf<String, Any>()
            status?.let { filterCriteria["status"] = it }
            riskLevel?.let { filterCriteria["riskLevel"] = it }
            assessmentType?.let { filterCriteria["assessmentType"] = it }
            tags?.let { filterCriteria["tags"] = it }
            createdAfter?.let { filterCriteria["createdAfter"] = it }
            createdBefore?.let { filterCriteria["createdBefore"] = it }

            val assessments = riskAssessmentService.getAssessments(
                limit = limit,
                offset = offset,
                filters = filterCriteria
            )

            val result = mapOf(
                "assessments" to assessments.map { assessment ->
                    val baseData = mapOf(
                        "id" to assessment.id,
                        "title" to assessment.title,
                        "description" to assessment.description,
                        "status" to assessment.status.name,
                        "riskLevel" to assessment.riskLevel.name,
                        "assessmentType" to assessment.assessmentType?.name,
                        "scope" to assessment.scope,
                        "methodology" to assessment.methodology,
                        "createdAt" to assessment.createdAt.toString(),
                        "updatedAt" to assessment.updatedAt?.toString(),
                        "createdBy" to assessment.createdBy?.username,
                        "completedAt" to assessment.completedAt?.toString(),
                        "reviewedBy" to assessment.reviewedBy?.username,
                        "reviewedAt" to assessment.reviewedAt?.toString()
                    )

                    if (includeFindings) {
                        baseData + mapOf(
                            "findings" to assessment.findings,
                            "recommendations" to assessment.recommendations,
                            "riskScore" to assessment.riskScore,
                            "mitigationStatus" to assessment.mitigationStatus?.name
                        )
                    } else {
                        baseData + mapOf(
                            "findingsSummary" to assessment.findings?.take(200) + "...",
                            "riskScore" to assessment.riskScore
                        )
                    }
                },
                "pagination" to mapOf(
                    "total" to assessments.size,
                    "limit" to limit,
                    "offset" to offset,
                    "hasMore" to (assessments.size == limit)
                ),
                "filters" to filterCriteria
            )

            val metadata = mapOf(
                "includeFindings" to includeFindings,
                "executionTime" to System.currentTimeMillis()
            )

            return McpToolResult.success(result, metadata)

        } catch (e: Exception) {
            return McpToolResult.error("EXECUTION_ERROR", "Failed to retrieve assessments: ${e.message}")
        }
    }
}