package com.secman.mcp.tools

import com.secman.domain.McpOperation
import com.secman.dto.mcp.McpExecutionContext
import com.secman.service.VulnerabilityStatisticsService
import jakarta.inject.Inject
import jakarta.inject.Singleton

/**
 * MCP tool for retrieving vulnerability statistics report.
 *
 * Returns aggregated vulnerability statistics including:
 * - Severity distribution (CRITICAL, HIGH, MEDIUM, LOW, UNKNOWN counts)
 * - Most common vulnerabilities (top 10 by occurrence)
 * - Most vulnerable products (top 10 by vulnerability count)
 * - Top assets by vulnerabilities (top 10 with severity breakdowns)
 * - Vulnerabilities by asset type (grouped statistics)
 * - Top 50 servers with most vulnerabilities
 *
 * Feature: 069-mcp-lense-reports
 * Task: T015
 * User Story: US3 - Vulnerability Statistics (P2)
 * Spec reference: FR-003, FR-005, FR-006, FR-007, FR-012
 *
 * Access Control:
 * - Uses context.authentication for access control via VulnerabilityStatisticsService
 * - ADMIN: sees all data
 * - Non-admin: sees only accessible assets based on workgroups, domain/AWS mappings
 */
@Singleton
class GetVulnerabilityStatisticsTool(
    @Inject private val vulnerabilityStatisticsService: VulnerabilityStatisticsService
) : McpTool {

    override val name = "get_vulnerability_statistics"
    override val description = "Retrieve vulnerability statistics report with severity distribution, most common vulnerabilities, vulnerable products, top assets, statistics by asset type, and top 50 servers"
    override val operation = McpOperation.READ

    override val inputSchema = mapOf(
        "type" to "object",
        "properties" to mapOf(
            "domain" to mapOf(
                "type" to "string",
                "description" to "Optional AD domain filter (case-insensitive)"
            )
        ),
        "required" to emptyList<String>()
    )

    override suspend fun execute(arguments: Map<String, Any>, context: McpExecutionContext): McpToolResult {
        // Extract optional domain filter
        val domain = arguments["domain"] as? String

        try {
            // Get accessible asset IDs for access control filtering
            val accessibleAssetIds = context.getFilterableAssetIds()

            // Get all statistics from service using pre-computed asset IDs
            val severityDistribution = vulnerabilityStatisticsService.getSeverityDistribution(accessibleAssetIds, domain)
            val mostCommonVulnerabilities = vulnerabilityStatisticsService.getMostCommonVulnerabilities(accessibleAssetIds, domain)
            val mostVulnerableProducts = vulnerabilityStatisticsService.getMostVulnerableProducts(accessibleAssetIds, domain)
            val topAssetsByVulnerabilities = vulnerabilityStatisticsService.getTopAssetsByVulnerabilities(accessibleAssetIds)
            val vulnerabilitiesByAssetType = vulnerabilityStatisticsService.getVulnerabilitiesByAssetType(accessibleAssetIds)
            val topServersByVulnerabilities = vulnerabilityStatisticsService.getTopServersByVulnerabilities(accessibleAssetIds, 50, domain)

            // Map to response format
            val result = mapOf(
                "severityDistribution" to mapOf(
                    "critical" to severityDistribution.critical,
                    "high" to severityDistribution.high,
                    "medium" to severityDistribution.medium,
                    "low" to severityDistribution.low,
                    "unknown" to severityDistribution.unknown,
                    "total" to severityDistribution.total,
                    "criticalPercentage" to severityDistribution.criticalPercentage,
                    "highPercentage" to severityDistribution.highPercentage,
                    "mediumPercentage" to severityDistribution.mediumPercentage,
                    "lowPercentage" to severityDistribution.lowPercentage
                ),
                "mostCommonVulnerabilities" to mostCommonVulnerabilities.map { vuln ->
                    mapOf(
                        "vulnerabilityId" to vuln.vulnerabilityId,
                        "cvssSeverity" to vuln.cvssSeverity,
                        "occurrenceCount" to vuln.occurrenceCount,
                        "affectedAssetCount" to vuln.affectedAssetCount
                    )
                },
                "mostVulnerableProducts" to mostVulnerableProducts.map { product ->
                    mapOf(
                        "product" to product.product,
                        "vulnerabilityCount" to product.vulnerabilityCount,
                        "affectedAssetCount" to product.affectedAssetCount,
                        "criticalCount" to product.criticalCount,
                        "highCount" to product.highCount
                    )
                },
                "topAssetsByVulnerabilities" to topAssetsByVulnerabilities.map { asset ->
                    mapOf(
                        "assetId" to asset.assetId,
                        "assetName" to asset.assetName,
                        "assetType" to asset.assetType,
                        "assetIp" to asset.assetIp,
                        "totalVulnerabilityCount" to asset.totalVulnerabilityCount,
                        "criticalCount" to asset.criticalCount,
                        "highCount" to asset.highCount,
                        "mediumCount" to asset.mediumCount,
                        "lowCount" to asset.lowCount
                    )
                },
                "vulnerabilitiesByAssetType" to vulnerabilitiesByAssetType.map { type ->
                    mapOf(
                        "assetType" to type.assetType,
                        "assetCount" to type.assetCount,
                        "totalVulnerabilityCount" to type.totalVulnerabilityCount,
                        "criticalCount" to type.criticalCount,
                        "highCount" to type.highCount,
                        "mediumCount" to type.mediumCount,
                        "lowCount" to type.lowCount,
                        "averageVulnerabilitiesPerAsset" to type.averageVulnerabilitiesPerAsset
                    )
                },
                "topServersByVulnerabilities" to topServersByVulnerabilities.map { server ->
                    mapOf(
                        "assetId" to server.assetId,
                        "serverName" to server.serverName,
                        "serverIp" to server.serverIp,
                        "totalVulnerabilityCount" to server.totalVulnerabilityCount,
                        "criticalCount" to server.criticalCount,
                        "highCount" to server.highCount
                    )
                }
            )

            return McpToolResult.success(result)

        } catch (e: Exception) {
            return McpToolResult.error("EXECUTION_ERROR", "Failed to retrieve vulnerability statistics: ${e.message}")
        }
    }
}
