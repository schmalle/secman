package com.secman.repository

import com.secman.domain.Vulnerability
import com.secman.repository.projection.MostCommonVulnerabilityRow
import io.micronaut.data.annotation.Repository
import io.micronaut.data.jpa.repository.JpaRepository
import io.micronaut.data.model.Page
import io.micronaut.data.model.Pageable
import io.micronaut.data.model.Sort
import java.time.LocalDateTime

/**
 * Repository for Vulnerability entity operations
 *
 * Related to: Feature 003-i-want-to (Vulnerability Management System)
 */
@Repository
interface VulnerabilityRepository : JpaRepository<Vulnerability, Long> {

    /**
     * Find all vulnerabilities for a specific asset with pagination support
     *
     * @param assetId The asset ID
     * @param pageable Pagination parameters
     * @return Page of vulnerabilities
     */
    fun findByAssetId(assetId: Long, pageable: Pageable): Page<Vulnerability>

    /**
     * Find vulnerabilities for an asset within a date range
     *
     * @param assetId The asset ID
     * @param startDate Start of scan timestamp range
     * @param endDate End of scan timestamp range
     * @param sort Sort order
     * @return List of vulnerabilities
     */
    fun findByAssetIdAndScanTimestampBetween(
        assetId: Long,
        startDate: LocalDateTime,
        endDate: LocalDateTime,
        sort: Sort
    ): List<Vulnerability>

    /**
     * Count vulnerabilities for a specific asset
     *
     * @param assetId The asset ID
     * @return Count of vulnerabilities
     */
    fun countByAssetId(assetId: Long): Long

    /**
     * Delete all vulnerabilities for a specific asset
     * Used for transactional replace pattern in server vulnerability imports
     *
     * Feature: 032-servers-query-import
     * Task: T025
     *
     * @param assetId The asset ID
     * @return Number of deleted vulnerabilities
     */
    fun deleteByAssetId(assetId: Long): Int

    /**
     * Check if a vulnerability with exact asset, CVE ID, and scan timestamp already exists
     * Prevents duplicate vulnerability records when importing from CrowdStrike
     * Related to: Feature 030 (CrowdStrike Asset Auto-Creation) - FR-011
     *
     * @param asset The asset entity
     * @param vulnerabilityId The CVE ID
     * @param scanTimestamp The scan timestamp
     * @return True if duplicate exists, false otherwise
     */
    fun existsByAssetAndVulnerabilityIdAndScanTimestamp(
        asset: com.secman.domain.Asset,
        vulnerabilityId: String,
        scanTimestamp: LocalDateTime
    ): Boolean

    // MCP Tool Support - Feature 006: Vulnerability queries with filtering

    /**
     * Find vulnerabilities by CVE ID (partial match, case-insensitive) with pagination
     * Used for: MCP get_vulnerabilities tool - searching by CVE identifier
     * Related to: Feature 006 (MCP Tools for Security Data)
     */
    fun findByVulnerabilityIdContainingIgnoreCase(cveId: String, pageable: Pageable): Page<Vulnerability>

    /**
     * Find vulnerabilities by exact CVSS severity with pagination
     * Used for: MCP get_vulnerabilities tool - filtering by single severity level
     * Related to: Feature 006 (MCP Tools for Security Data)
     */
    fun findByCvssSeverity(severity: String, pageable: Pageable): Page<Vulnerability>

    /**
     * Find vulnerabilities by CVSS severity (multiple values) with pagination
     * Used for: MCP get_vulnerabilities tool - filtering by severity array (e.g., ["Critical", "High"])
     * Related to: Feature 006 (MCP Tools for Security Data)
     */
    fun findByCvssSeverityIn(severities: List<String>, pageable: Pageable): Page<Vulnerability>

    /**
     * Find vulnerabilities within a scan timestamp range with pagination
     * Used for: MCP get_vulnerabilities tool - date range filtering
     * Related to: Feature 006 (MCP Tools for Security Data)
     */
    fun findByScanTimestampBetween(start: LocalDateTime, end: LocalDateTime, pageable: Pageable): Page<Vulnerability>

    // Workgroup-Based Access Control - Feature 008

    /**
     * Find vulnerabilities for assets accessible to a user
     * Returns vulnerabilities where the associated asset is:
     * 1. In workgroups the user belongs to
     * 2. Created manually by the user
     * 3. Discovered via scans uploaded by the user
     *
     * Related to: Feature 008 (Workgroup-Based Access Control) - FR-014, FR-018
     *
     * @param userId The user ID to filter by (workgroup membership)
     * @param manualCreatorId The user ID to filter by (manual creator)
     * @param scanUploaderId The user ID to filter by (scan uploader)
     * @return List of vulnerabilities for accessible assets
     */
    fun findByAssetWorkgroupsUsersIdOrAssetManualCreatorIdOrAssetScanUploaderIdOrderByScanTimestampDesc(
        userId: Long,
        manualCreatorId: Long,
        scanUploaderId: Long
    ): List<Vulnerability>

    /**
     * Find vulnerabilities for assets in specific workgroups
     * Used for admin workgroup management views
     *
     * Related to: Feature 008 (Workgroup-Based Access Control) - FR-014
     *
     * @param workgroupId The workgroup ID to filter by
     * @return List of vulnerabilities for assets in the workgroup
     */
    fun findByAssetWorkgroupsIdOrderByScanTimestampDesc(workgroupId: Long): List<Vulnerability>

    // Feature 021: Exception Impact Queries - Phase 3

    /**
     * Count vulnerabilities matching a product pattern (LIKE search)
     * Used for: Product exception affected count
     *
     * Related to: Feature 021 (Phase 3 - Product Exception Enhancement)
     *
     * @param productPattern Product name/version pattern (will be used in LIKE query)
     * @return Count of matching vulnerabilities
     */
    fun countByVulnerableProductVersionsContainingIgnoreCase(productPattern: String): Long

    /**
     * Count vulnerabilities for a specific asset (by asset ID)
     * Overload for exception impact calculation
     *
     * Related to: Feature 021 (Phase 3 - Product Exception Enhancement)
     *
     * @param assetId The asset ID
     * @return Count of vulnerabilities
     */
    // Already defined above: fun countByAssetId(assetId: Long): Long

    /**
     * Find vulnerabilities matching a product pattern with pagination
     * Used for: Impact preview when creating product exceptions
     *
     * Related to: Feature 021 (Phase 3 - Product Exception Enhancement)
     *
     * @param productPattern Product name/version pattern
     * @param pageable Pagination parameters
     * @return Page of matching vulnerabilities
     */
    fun findByVulnerableProductVersionsContainingIgnoreCase(
        productPattern: String,
        pageable: Pageable
    ): Page<Vulnerability>

    /**
     * Get distinct product versions from all vulnerabilities
     * Used for: Product autocomplete in exception form
     *
     * Related to: Feature 021 (Phase 3 - Product Exception Enhancement)
     *
     * Note: Since Micronaut Data doesn't directly support SELECT DISTINCT on non-entity fields,
     * we'll need to use @Query annotation
     *
     * @return List of unique product version strings (non-null, non-empty)
     */
    @io.micronaut.data.annotation.Query(
        """
        SELECT DISTINCT v.vulnerableProductVersions
        FROM Vulnerability v
        WHERE v.vulnerableProductVersions IS NOT NULL
        AND v.vulnerableProductVersions != ''
        ORDER BY v.vulnerableProductVersions
        """
    )
    fun findDistinctProductVersions(): List<String>

    // Feature 036: Vulnerability Statistics Lense - Most Common Vulnerabilities (US1)

    /**
     * Find most common vulnerabilities across ALL assets (ADMIN view)
     * Groups by CVE ID and severity, counts occurrences, returns top 10
     *
     * Feature: 036-vuln-stats-lense
     * Task: T011 [US1]
     * Spec reference: spec.md FR-001, FR-002
     *
     * @return List of most common vulnerabilities (max 10) with occurrence counts
     */
    @io.micronaut.data.annotation.Query(
        value = """
        SELECT v.vulnerability_id as vulnerabilityId,
               COALESCE(v.cvss_severity, 'UNKNOWN') as cvssSeverity,
               COUNT(*) as occurrenceCount,
               COUNT(DISTINCT v.asset_id) as affectedAssetCount
        FROM vulnerability v
        GROUP BY v.vulnerability_id, v.cvss_severity
        ORDER BY COUNT(*) DESC
        LIMIT 10
        """,
        nativeQuery = true
    )
    fun findMostCommonVulnerabilitiesForAll(): List<MostCommonVulnerabilityRow>

    /**
     * Find most common vulnerabilities for assets in specific workgroups (VULN user view)
     * Groups by CVE ID and severity, filters by workgroup access, counts occurrences, returns top 10
     *
     * Feature: 036-vuln-stats-lense
     * Task: T012 [US1]
     * Spec reference: spec.md FR-001, FR-002, FR-006
     *
     * @param workgroupIds Set of workgroup IDs the user has access to
     * @return List of most common vulnerabilities (max 10) with occurrence counts
     */
    @io.micronaut.data.annotation.Query(
        value = """
        SELECT v.vulnerability_id as vulnerabilityId,
               COALESCE(v.cvss_severity, 'UNKNOWN') as cvssSeverity,
               COUNT(*) as occurrenceCount,
               COUNT(DISTINCT v.asset_id) as affectedAssetCount
        FROM vulnerability v
        JOIN asset a ON v.asset_id = a.id
        JOIN asset_workgroups aw ON a.id = aw.asset_id
        WHERE aw.workgroup_id IN :workgroupIds
        GROUP BY v.vulnerability_id, v.cvss_severity
        ORDER BY COUNT(*) DESC
        LIMIT 10
        """,
        nativeQuery = true
    )
    fun findMostCommonVulnerabilitiesForWorkgroups(workgroupIds: Set<Long>): List<MostCommonVulnerabilityRow>

    // Feature 036: Vulnerability Statistics Lense - Severity Distribution (US2)

    /**
     * Get severity distribution for ALL vulnerabilities (ADMIN view)
     * Groups by severity level and counts occurrences
     *
     * Feature: 036-vuln-stats-lense
     * Task: T022 [US2]
     * Spec reference: spec.md FR-003, FR-004
     *
     * @return Map of severity level to count (CRITICAL, HIGH, MEDIUM, LOW, UNKNOWN)
     */
    @io.micronaut.data.annotation.Query(
        """
        SELECT COALESCE(v.cvssSeverity, 'UNKNOWN') as severity, COUNT(v) as count
        FROM Vulnerability v
        GROUP BY COALESCE(v.cvssSeverity, 'UNKNOWN')
        """
    )
    fun findSeverityDistributionForAll(): List<Map<String, Any>>

    /**
     * Get severity distribution for vulnerabilities in specific workgroups (VULN user view)
     * Groups by severity level, filters by workgroup access, counts occurrences
     *
     * Feature: 036-vuln-stats-lense
     * Task: T022 [US2]
     * Spec reference: spec.md FR-003, FR-004, FR-006
     *
     * @param workgroupIds Set of workgroup IDs the user has access to
     * @return Map of severity level to count (CRITICAL, HIGH, MEDIUM, LOW, UNKNOWN)
     */
    @io.micronaut.data.annotation.Query(
        """
        SELECT COALESCE(v.cvssSeverity, 'UNKNOWN') as severity, COUNT(v) as count
        FROM Vulnerability v
        JOIN v.asset a
        JOIN a.workgroups w
        WHERE w.id IN :workgroupIds
        GROUP BY COALESCE(v.cvssSeverity, 'UNKNOWN')
        """
    )
    fun findSeverityDistributionForWorkgroups(workgroupIds: Set<Long>): List<Map<String, Any>>

    // Feature 036: Vulnerability Statistics Lense - Top Assets by Vulnerabilities (US3)

    /**
     * Get top 10 assets ranked by total vulnerability count (ADMIN view)
     * Groups by asset, counts vulnerabilities with severity breakdowns
     *
     * Feature: 036-vuln-stats-lense
     * Task: T032 [US3]
     * Spec reference: spec.md FR-005, FR-006
     *
     * @return List of top 10 assets with vulnerability counts and severity breakdowns
     */
    @io.micronaut.data.annotation.Query(
        value = """
        SELECT a.id as asset_id, a.name as asset_name, a.type as asset_type, a.ip as asset_ip,
               COUNT(v.id) as total_vulnerability_count,
               SUM(CASE WHEN v.cvss_severity = 'CRITICAL' THEN 1 ELSE 0 END) as critical_count,
               SUM(CASE WHEN v.cvss_severity = 'HIGH' THEN 1 ELSE 0 END) as high_count,
               SUM(CASE WHEN v.cvss_severity = 'MEDIUM' THEN 1 ELSE 0 END) as medium_count,
               SUM(CASE WHEN v.cvss_severity = 'LOW' THEN 1 ELSE 0 END) as low_count
        FROM vulnerability v
        JOIN asset a ON v.asset_id = a.id
        GROUP BY a.id, a.name, a.type, a.ip
        ORDER BY COUNT(v.id) DESC
        LIMIT 10
        """,
        nativeQuery = true
    )
    fun findTopAssetsByVulnerabilitiesForAll(): List<Map<String, Any>>

    /**
     * Get top 10 assets ranked by total vulnerability count for specific workgroups (VULN user view)
     * Groups by asset, filters by workgroup access, counts vulnerabilities with severity breakdowns
     *
     * Feature: 036-vuln-stats-lense
     * Task: T032 [US3]
     * Spec reference: spec.md FR-005, FR-006
     *
     * @param workgroupIds Set of workgroup IDs the user has access to
     * @return List of top 10 assets with vulnerability counts and severity breakdowns
     */
    @io.micronaut.data.annotation.Query(
        value = """
        SELECT a.id as asset_id, a.name as asset_name, a.type as asset_type, a.ip as asset_ip,
               COUNT(v.id) as total_vulnerability_count,
               SUM(CASE WHEN v.cvss_severity = 'CRITICAL' THEN 1 ELSE 0 END) as critical_count,
               SUM(CASE WHEN v.cvss_severity = 'HIGH' THEN 1 ELSE 0 END) as high_count,
               SUM(CASE WHEN v.cvss_severity = 'MEDIUM' THEN 1 ELSE 0 END) as medium_count,
               SUM(CASE WHEN v.cvss_severity = 'LOW' THEN 1 ELSE 0 END) as low_count
        FROM vulnerability v
        JOIN asset a ON v.asset_id = a.id
        JOIN asset_workgroups aw ON a.id = aw.asset_id
        WHERE aw.workgroup_id IN :workgroupIds
        GROUP BY a.id, a.name, a.type, a.ip
        ORDER BY COUNT(v.id) DESC
        LIMIT 10
        """,
        nativeQuery = true
    )
    fun findTopAssetsByVulnerabilitiesForWorkgroups(workgroupIds: Set<Long>): List<Map<String, Any>>

    // Feature 036: Vulnerability Statistics Lense - Vulnerabilities by Asset Type (US3)

    /**
     * Get vulnerability statistics grouped by asset type (ADMIN view)
     * Groups by asset type, counts vulnerabilities with severity breakdowns and average calculation
     *
     * Feature: 036-vuln-stats-lense
     * Task: T036 [US3]
     * Spec reference: spec.md FR-007, FR-008
     *
     * @return List of asset types with vulnerability statistics
     */
    @io.micronaut.data.annotation.Query(
        """
        SELECT COALESCE(a.type, 'Unknown') as assetType,
               COUNT(DISTINCT a.id) as assetCount,
               COUNT(v) as totalVulnerabilityCount,
               SUM(CASE WHEN v.cvssSeverity = 'CRITICAL' THEN 1 ELSE 0 END) as criticalCount,
               SUM(CASE WHEN v.cvssSeverity = 'HIGH' THEN 1 ELSE 0 END) as highCount,
               SUM(CASE WHEN v.cvssSeverity = 'MEDIUM' THEN 1 ELSE 0 END) as mediumCount,
               SUM(CASE WHEN v.cvssSeverity = 'LOW' THEN 1 ELSE 0 END) as lowCount,
               CAST(COUNT(v) AS double) / COUNT(DISTINCT a.id) as avgVulnsPerAsset
        FROM Vulnerability v
        JOIN v.asset a
        GROUP BY COALESCE(a.type, 'Unknown')
        ORDER BY COUNT(v) DESC
        """
    )
    fun findVulnerabilitiesByAssetTypeForAll(): List<Map<String, Any>>

    /**
     * Get vulnerability statistics grouped by asset type for specific workgroups (VULN user view)
     * Groups by asset type, filters by workgroup access, counts vulnerabilities with severity breakdowns
     *
     * Feature: 036-vuln-stats-lense
     * Task: T036 [US3]
     * Spec reference: spec.md FR-007, FR-008
     *
     * @param workgroupIds Set of workgroup IDs the user has access to
     * @return List of asset types with vulnerability statistics
     */
    @io.micronaut.data.annotation.Query(
        """
        SELECT COALESCE(a.type, 'Unknown') as assetType,
               COUNT(DISTINCT a.id) as assetCount,
               COUNT(v) as totalVulnerabilityCount,
               SUM(CASE WHEN v.cvssSeverity = 'CRITICAL' THEN 1 ELSE 0 END) as criticalCount,
               SUM(CASE WHEN v.cvssSeverity = 'HIGH' THEN 1 ELSE 0 END) as highCount,
               SUM(CASE WHEN v.cvssSeverity = 'MEDIUM' THEN 1 ELSE 0 END) as mediumCount,
               SUM(CASE WHEN v.cvssSeverity = 'LOW' THEN 1 ELSE 0 END) as lowCount,
               CAST(COUNT(v) AS double) / COUNT(DISTINCT a.id) as avgVulnsPerAsset
        FROM Vulnerability v
        JOIN v.asset a
        JOIN a.workgroups w
        WHERE w.id IN :workgroupIds
        GROUP BY COALESCE(a.type, 'Unknown')
        ORDER BY COUNT(v) DESC
        """
    )
    fun findVulnerabilitiesByAssetTypeForWorkgroups(workgroupIds: Set<Long>): List<Map<String, Any>>

    // Feature 036: Vulnerability Statistics Lense - Temporal Trends (US4)

    /**
     * Get temporal vulnerability trends for all assets (ADMIN view)
     * Groups by date, counts vulnerabilities with severity breakdowns over specified time period
     *
     * Feature: 036-vuln-stats-lense
     * Task: T048 [US4]
     * Spec reference: spec.md FR-009, FR-010, FR-011
     *
     * @param startDate Start date for trend analysis (inclusive)
     * @return List of daily data points with vulnerability counts
     */
    @io.micronaut.data.annotation.Query(
        """
        SELECT DATE(v.scanTimestamp) as date,
               COUNT(v) as totalCount,
               SUM(CASE WHEN v.cvssSeverity = 'CRITICAL' THEN 1 ELSE 0 END) as criticalCount,
               SUM(CASE WHEN v.cvssSeverity = 'HIGH' THEN 1 ELSE 0 END) as highCount,
               SUM(CASE WHEN v.cvssSeverity = 'MEDIUM' THEN 1 ELSE 0 END) as mediumCount,
               SUM(CASE WHEN v.cvssSeverity = 'LOW' THEN 1 ELSE 0 END) as lowCount
        FROM Vulnerability v
        WHERE v.scanTimestamp >= :startDate
        GROUP BY DATE(v.scanTimestamp)
        ORDER BY DATE(v.scanTimestamp) ASC
        """
    )
    fun findTemporalTrendsForAll(startDate: LocalDateTime): List<Map<String, Any>>

    /**
     * Get temporal vulnerability trends for specific workgroups (VULN user view)
     * Groups by date, filters by workgroup access, counts vulnerabilities with severity breakdowns
     *
     * Feature: 036-vuln-stats-lense
     * Task: T048 [US4]
     * Spec reference: spec.md FR-009, FR-010, FR-011
     *
     * @param workgroupIds Set of workgroup IDs the user has access to
     * @param startDate Start date for trend analysis (inclusive)
     * @return List of daily data points with vulnerability counts
     */
    @io.micronaut.data.annotation.Query(
        """
        SELECT DATE(v.scanTimestamp) as date,
               COUNT(v) as totalCount,
               SUM(CASE WHEN v.cvssSeverity = 'CRITICAL' THEN 1 ELSE 0 END) as criticalCount,
               SUM(CASE WHEN v.cvssSeverity = 'HIGH' THEN 1 ELSE 0 END) as highCount,
               SUM(CASE WHEN v.cvssSeverity = 'MEDIUM' THEN 1 ELSE 0 END) as mediumCount,
               SUM(CASE WHEN v.cvssSeverity = 'LOW' THEN 1 ELSE 0 END) as lowCount
        FROM Vulnerability v
        JOIN v.asset a
        JOIN a.workgroups w
        WHERE w.id IN :workgroupIds
        AND v.scanTimestamp >= :startDate
        GROUP BY DATE(v.scanTimestamp)
        ORDER BY DATE(v.scanTimestamp) ASC
        """
    )
    fun findTemporalTrendsForWorkgroups(workgroupIds: Set<Long>, startDate: LocalDateTime): List<Map<String, Any>>
}
