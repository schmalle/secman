package com.secman.repository

import com.secman.domain.Vulnerability
import io.micronaut.data.annotation.Repository
import io.micronaut.data.jpa.repository.JpaRepository
import io.micronaut.data.model.Page
import io.micronaut.data.model.Pageable
import io.micronaut.data.model.Sort
import java.time.LocalDateTime

/**
 * Repository for Vulnerability entity operations
 *
 * Related to: Feature 003-i-want-to (Vulnerability Management System)
 */
@Repository
interface VulnerabilityRepository : JpaRepository<Vulnerability, Long> {

    /**
     * Find all vulnerabilities for a specific asset with pagination support
     *
     * @param assetId The asset ID
     * @param pageable Pagination parameters
     * @return Page of vulnerabilities
     */
    fun findByAssetId(assetId: Long, pageable: Pageable): Page<Vulnerability>

    /**
     * Find vulnerabilities for an asset within a date range
     *
     * @param assetId The asset ID
     * @param startDate Start of scan timestamp range
     * @param endDate End of scan timestamp range
     * @param sort Sort order
     * @return List of vulnerabilities
     */
    fun findByAssetIdAndScanTimestampBetween(
        assetId: Long,
        startDate: LocalDateTime,
        endDate: LocalDateTime,
        sort: Sort
    ): List<Vulnerability>

    /**
     * Count vulnerabilities for a specific asset
     *
     * @param assetId The asset ID
     * @return Count of vulnerabilities
     */
    fun countByAssetId(assetId: Long): Long

    /**
     * Delete all vulnerabilities for a specific asset
     * Used for transactional replace pattern in server vulnerability imports
     *
     * Feature: 032-servers-query-import
     * Task: T025
     *
     * @param assetId The asset ID
     * @return Number of deleted vulnerabilities
     */
    fun deleteByAssetId(assetId: Long): Int

    /**
     * Check if a vulnerability with exact asset, CVE ID, and scan timestamp already exists
     * Prevents duplicate vulnerability records when importing from CrowdStrike
     * Related to: Feature 030 (CrowdStrike Asset Auto-Creation) - FR-011
     *
     * @param asset The asset entity
     * @param vulnerabilityId The CVE ID
     * @param scanTimestamp The scan timestamp
     * @return True if duplicate exists, false otherwise
     */
    fun existsByAssetAndVulnerabilityIdAndScanTimestamp(
        asset: com.secman.domain.Asset,
        vulnerabilityId: String,
        scanTimestamp: LocalDateTime
    ): Boolean

    // MCP Tool Support - Feature 006: Vulnerability queries with filtering

    /**
     * Find vulnerabilities by CVE ID (partial match, case-insensitive) with pagination
     * Used for: MCP get_vulnerabilities tool - searching by CVE identifier
     * Related to: Feature 006 (MCP Tools for Security Data)
     */
    fun findByVulnerabilityIdContainingIgnoreCase(cveId: String, pageable: Pageable): Page<Vulnerability>

    /**
     * Find vulnerabilities by exact CVSS severity with pagination
     * Used for: MCP get_vulnerabilities tool - filtering by single severity level
     * Related to: Feature 006 (MCP Tools for Security Data)
     */
    fun findByCvssSeverity(severity: String, pageable: Pageable): Page<Vulnerability>

    /**
     * Find vulnerabilities by CVSS severity (multiple values) with pagination
     * Used for: MCP get_vulnerabilities tool - filtering by severity array (e.g., ["Critical", "High"])
     * Related to: Feature 006 (MCP Tools for Security Data)
     */
    fun findByCvssSeverityIn(severities: List<String>, pageable: Pageable): Page<Vulnerability>

    /**
     * Find vulnerabilities within a scan timestamp range with pagination
     * Used for: MCP get_vulnerabilities tool - date range filtering
     * Related to: Feature 006 (MCP Tools for Security Data)
     */
    fun findByScanTimestampBetween(start: LocalDateTime, end: LocalDateTime, pageable: Pageable): Page<Vulnerability>

    // Workgroup-Based Access Control - Feature 008

    /**
     * Find vulnerabilities for assets accessible to a user
     * Returns vulnerabilities where the associated asset is:
     * 1. In workgroups the user belongs to
     * 2. Created manually by the user
     * 3. Discovered via scans uploaded by the user
     *
     * Related to: Feature 008 (Workgroup-Based Access Control) - FR-014, FR-018
     *
     * @param userId The user ID to filter by (workgroup membership)
     * @param manualCreatorId The user ID to filter by (manual creator)
     * @param scanUploaderId The user ID to filter by (scan uploader)
     * @return List of vulnerabilities for accessible assets
     */
    fun findByAssetWorkgroupsUsersIdOrAssetManualCreatorIdOrAssetScanUploaderIdOrderByScanTimestampDesc(
        userId: Long,
        manualCreatorId: Long,
        scanUploaderId: Long
    ): List<Vulnerability>

    /**
     * Find vulnerabilities for assets in specific workgroups
     * Used for admin workgroup management views
     *
     * Related to: Feature 008 (Workgroup-Based Access Control) - FR-014
     *
     * @param workgroupId The workgroup ID to filter by
     * @return List of vulnerabilities for assets in the workgroup
     */
    fun findByAssetWorkgroupsIdOrderByScanTimestampDesc(workgroupId: Long): List<Vulnerability>

    // Feature 021: Exception Impact Queries - Phase 3

    /**
     * Count vulnerabilities matching a product pattern (LIKE search)
     * Used for: Product exception affected count
     *
     * Related to: Feature 021 (Phase 3 - Product Exception Enhancement)
     *
     * @param productPattern Product name/version pattern (will be used in LIKE query)
     * @return Count of matching vulnerabilities
     */
    fun countByVulnerableProductVersionsContainingIgnoreCase(productPattern: String): Long

    /**
     * Count vulnerabilities for a specific asset (by asset ID)
     * Overload for exception impact calculation
     *
     * Related to: Feature 021 (Phase 3 - Product Exception Enhancement)
     *
     * @param assetId The asset ID
     * @return Count of vulnerabilities
     */
    // Already defined above: fun countByAssetId(assetId: Long): Long

    /**
     * Find vulnerabilities matching a product pattern with pagination
     * Used for: Impact preview when creating product exceptions
     *
     * Related to: Feature 021 (Phase 3 - Product Exception Enhancement)
     *
     * @param productPattern Product name/version pattern
     * @param pageable Pagination parameters
     * @return Page of matching vulnerabilities
     */
    fun findByVulnerableProductVersionsContainingIgnoreCase(
        productPattern: String,
        pageable: Pageable
    ): Page<Vulnerability>

    /**
     * Get distinct product versions from all vulnerabilities
     * Used for: Product autocomplete in exception form
     *
     * Related to: Feature 021 (Phase 3 - Product Exception Enhancement)
     *
     * Note: Since Micronaut Data doesn't directly support SELECT DISTINCT on non-entity fields,
     * we'll need to use @Query annotation
     *
     * @return List of unique product version strings (non-null, non-empty)
     */
    @io.micronaut.data.annotation.Query(
        """
        SELECT DISTINCT v.vulnerableProductVersions 
        FROM Vulnerability v 
        WHERE v.vulnerableProductVersions IS NOT NULL 
        AND v.vulnerableProductVersions != '' 
        ORDER BY v.vulnerableProductVersions
        """
    )
    fun findDistinctProductVersions(): List<String>
}
