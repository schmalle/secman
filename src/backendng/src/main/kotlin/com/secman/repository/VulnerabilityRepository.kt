package com.secman.repository

import com.secman.domain.Vulnerability
import com.secman.repository.projection.MostCommonVulnerabilityRow
import com.secman.repository.projection.MostVulnerableProductRow
import com.secman.repository.projection.TopProductRow
import io.micronaut.data.annotation.Repository
import io.micronaut.data.jpa.repository.JpaRepository
import io.micronaut.data.model.Page
import io.micronaut.data.model.Pageable
import io.micronaut.data.model.Sort
import java.time.LocalDateTime

/**
 * Repository for Vulnerability entity operations
 *
 * Related to: Feature 003-i-want-to (Vulnerability Management System)
 */
@Repository
interface VulnerabilityRepository : JpaRepository<Vulnerability, Long> {

    /**
     * Find all vulnerabilities for a specific asset with pagination support
     *
     * @param assetId The asset ID
     * @param pageable Pagination parameters
     * @return Page of vulnerabilities
     */
    fun findByAssetId(assetId: Long, pageable: Pageable): Page<Vulnerability>

    /**
     * Find vulnerabilities for an asset within a date range
     *
     * @param assetId The asset ID
     * @param startDate Start of scan timestamp range
     * @param endDate End of scan timestamp range
     * @param sort Sort order
     * @return List of vulnerabilities
     */
    fun findByAssetIdAndScanTimestampBetween(
        assetId: Long,
        startDate: LocalDateTime,
        endDate: LocalDateTime,
        sort: Sort
    ): List<Vulnerability>

    /**
     * Count vulnerabilities for a specific asset
     *
     * @param assetId The asset ID
     * @return Count of vulnerabilities
     */
    fun countByAssetId(assetId: Long): Long

    /**
     * Delete all vulnerabilities for a specific asset
     * Used for transactional replace pattern in server vulnerability imports
     *
     * Feature: 032-servers-query-import
     * Task: T025
     *
     * @param assetId The asset ID
     * @return Number of deleted vulnerabilities
     */
    fun deleteByAssetId(assetId: Long): Int

    /**
     * Check if a vulnerability with exact asset, CVE ID, and scan timestamp already exists
     * Prevents duplicate vulnerability records when importing from CrowdStrike
     * Related to: Feature 030 (CrowdStrike Asset Auto-Creation) - FR-011
     *
     * @param asset The asset entity
     * @param vulnerabilityId The CVE ID
     * @param scanTimestamp The scan timestamp
     * @return True if duplicate exists, false otherwise
     */
    fun existsByAssetAndVulnerabilityIdAndScanTimestamp(
        asset: com.secman.domain.Asset,
        vulnerabilityId: String,
        scanTimestamp: LocalDateTime
    ): Boolean

    // MCP Tool Support - Feature 006: Vulnerability queries with filtering

    /**
     * Find vulnerabilities by CVE ID (partial match, case-insensitive) with pagination
     * Used for: MCP get_vulnerabilities tool - searching by CVE identifier
     * Related to: Feature 006 (MCP Tools for Security Data)
     */
    fun findByVulnerabilityIdContainingIgnoreCase(cveId: String, pageable: Pageable): Page<Vulnerability>

    /**
     * Find vulnerabilities by exact CVSS severity with pagination
     * Used for: MCP get_vulnerabilities tool - filtering by single severity level
     * Related to: Feature 006 (MCP Tools for Security Data)
     */
    fun findByCvssSeverity(severity: String, pageable: Pageable): Page<Vulnerability>

    /**
     * Find vulnerabilities by CVSS severity (multiple values) with pagination
     * Used for: MCP get_vulnerabilities tool - filtering by severity array (e.g., ["Critical", "High"])
     * Related to: Feature 006 (MCP Tools for Security Data)
     */
    fun findByCvssSeverityIn(severities: List<String>, pageable: Pageable): Page<Vulnerability>

    /**
     * Find vulnerabilities within a scan timestamp range with pagination
     * Used for: MCP get_vulnerabilities tool - date range filtering
     * Related to: Feature 006 (MCP Tools for Security Data)
     */
    fun findByScanTimestampBetween(start: LocalDateTime, end: LocalDateTime, pageable: Pageable): Page<Vulnerability>

    // Workgroup-Based Access Control - Feature 008

    /**
     * Find vulnerabilities for assets accessible to a user
     * Returns vulnerabilities where the associated asset is:
     * 1. In workgroups the user belongs to
     * 2. Created manually by the user
     * 3. Discovered via scans uploaded by the user
     *
     * Related to: Feature 008 (Workgroup-Based Access Control) - FR-014, FR-018
     *
     * @param userId The user ID to filter by (workgroup membership)
     * @param manualCreatorId The user ID to filter by (manual creator)
     * @param scanUploaderId The user ID to filter by (scan uploader)
     * @return List of vulnerabilities for accessible assets
     */
    fun findByAssetWorkgroupsUsersIdOrAssetManualCreatorIdOrAssetScanUploaderIdOrderByScanTimestampDesc(
        userId: Long,
        manualCreatorId: Long,
        scanUploaderId: Long
    ): List<Vulnerability>

    /**
     * Find vulnerabilities for assets in specific workgroups
     * Used for admin workgroup management views
     *
     * Related to: Feature 008 (Workgroup-Based Access Control) - FR-014
     *
     * @param workgroupId The workgroup ID to filter by
     * @return List of vulnerabilities for assets in the workgroup
     */
    fun findByAssetWorkgroupsIdOrderByScanTimestampDesc(workgroupId: Long): List<Vulnerability>

    // Feature 021: Exception Impact Queries - Phase 3

    /**
     * Count vulnerabilities matching a product pattern (LIKE search)
     * Used for: Product exception affected count
     *
     * Related to: Feature 021 (Phase 3 - Product Exception Enhancement)
     *
     * @param productPattern Product name/version pattern (will be used in LIKE query)
     * @return Count of matching vulnerabilities
     */
    fun countByVulnerableProductVersionsContainingIgnoreCase(productPattern: String): Long

    /**
     * Count vulnerabilities for a specific asset (by asset ID)
     * Overload for exception impact calculation
     *
     * Related to: Feature 021 (Phase 3 - Product Exception Enhancement)
     *
     * @param assetId The asset ID
     * @return Count of vulnerabilities
     */
    // Already defined above: fun countByAssetId(assetId: Long): Long

    /**
     * Find vulnerabilities matching a product pattern with pagination
     * Used for: Impact preview when creating product exceptions
     *
     * Related to: Feature 021 (Phase 3 - Product Exception Enhancement)
     *
     * @param productPattern Product name/version pattern
     * @param pageable Pagination parameters
     * @return Page of matching vulnerabilities
     */
    fun findByVulnerableProductVersionsContainingIgnoreCase(
        productPattern: String,
        pageable: Pageable
    ): Page<Vulnerability>

    /**
     * Get distinct product versions from all vulnerabilities
     * Used for: Product autocomplete in exception form
     *
     * Related to: Feature 021 (Phase 3 - Product Exception Enhancement)
     *
     * Note: Since Micronaut Data doesn't directly support SELECT DISTINCT on non-entity fields,
     * we'll need to use @Query annotation
     *
     * @return List of unique product version strings (non-null, non-empty)
     */
    @io.micronaut.data.annotation.Query(
        """
        SELECT DISTINCT v.vulnerableProductVersions
        FROM Vulnerability v
        WHERE v.vulnerableProductVersions IS NOT NULL
        AND v.vulnerableProductVersions != ''
        ORDER BY v.vulnerableProductVersions
        """
    )
    fun findDistinctProductVersions(): List<String>

    // CVE Exception Support - count vulnerabilities by CVE ID

    /**
     * Count vulnerabilities matching a specific CVE ID
     * Used for: CVE exception affected count (system-wide)
     *
     * @param vulnerabilityId The CVE identifier
     * @return Count of matching vulnerabilities
     */
    fun countByVulnerabilityId(vulnerabilityId: String): Long

    /**
     * Count vulnerabilities matching a specific CVE ID on a specific asset
     * Used for: CVE exception affected count (single-system scope)
     *
     * @param vulnerabilityId The CVE identifier
     * @param assetId The asset ID
     * @return Count of matching vulnerabilities
     */
    fun countByVulnerabilityIdAndAssetId(vulnerabilityId: String, assetId: Long): Long

    // Exception Impact Preview - SQL-level queries to avoid loading all vulnerabilities into memory

    /**
     * Count vulnerabilities on assets matching a specific IP address
     * Used for: IP exception affected count and preview
     *
     * @param ip The IP address
     * @return Count of matching vulnerabilities
     */
    fun countByAssetIp(ip: String): Long

    /**
     * Find vulnerabilities on assets matching a specific IP address with pagination
     * Used for: IP exception impact preview sample
     *
     * @param ip The IP address
     * @param pageable Pagination parameters
     * @return Page of matching vulnerabilities
     */
    fun findByAssetIp(ip: String, pageable: Pageable): Page<Vulnerability>

    /**
     * Find vulnerabilities matching any of the given CVE IDs with pagination
     * Used for: CVE exception impact preview sample (system-wide)
     *
     * @param ids Collection of CVE identifiers
     * @param pageable Pagination parameters
     * @return Page of matching vulnerabilities
     */
    fun findByVulnerabilityIdIn(ids: Collection<String>, pageable: Pageable): Page<Vulnerability>

    /**
     * Count vulnerabilities matching any of the given CVE IDs
     * Used for: CVE exception affected count (system-wide, multiple CVEs)
     *
     * @param ids Collection of CVE identifiers
     * @return Count of matching vulnerabilities
     */
    fun countByVulnerabilityIdIn(ids: Collection<String>): Long

    /**
     * Find vulnerabilities matching any of the given CVE IDs on a specific asset
     * Used for: CVE exception impact preview sample (single-system scope)
     *
     * @param ids Collection of CVE identifiers
     * @param assetId The asset ID
     * @param pageable Pagination parameters
     * @return Page of matching vulnerabilities
     */
    fun findByVulnerabilityIdInAndAssetId(ids: Collection<String>, assetId: Long, pageable: Pageable): Page<Vulnerability>

    /**
     * Count vulnerabilities matching any of the given CVE IDs on a specific asset
     * Used for: CVE exception affected count (single-system scope, multiple CVEs)
     *
     * @param ids Collection of CVE identifiers
     * @param assetId The asset ID
     * @return Count of matching vulnerabilities
     */
    fun countByVulnerabilityIdInAndAssetId(ids: Collection<String>, assetId: Long): Long

    // Feature 036: Vulnerability Statistics Lense - Most Common Vulnerabilities (US1)

    /**
     * Find most common vulnerabilities across ALL assets (ADMIN view)
     * Groups by CVE ID and severity, counts occurrences, returns top 10
     *
     * Feature: 036-vuln-stats-lense
     * Task: T011 [US1]
     * Spec reference: spec.md FR-001, FR-002
     *
     * @return List of most common vulnerabilities (max 10) with occurrence counts
     */
    @io.micronaut.data.annotation.Query(
        value = """
        SELECT v.vulnerability_id as vulnerabilityId,
               COALESCE(v.cvss_severity, 'UNKNOWN') as cvssSeverity,
               COUNT(*) as occurrenceCount,
               COUNT(DISTINCT v.asset_id) as affectedAssetCount
        FROM vulnerability v
        GROUP BY v.vulnerability_id, v.cvss_severity
        ORDER BY COUNT(*) DESC
        LIMIT 10
        """,
        nativeQuery = true
    )
    fun findMostCommonVulnerabilitiesForAll(): List<MostCommonVulnerabilityRow>

    /**
     * Find most common vulnerabilities for assets in specific workgroups (VULN user view)
     * Groups by CVE ID and severity, filters by workgroup access, counts occurrences, returns top 10
     *
     * Feature: 036-vuln-stats-lense
     * Task: T012 [US1]
     * Spec reference: spec.md FR-001, FR-002, FR-006
     *
     * @param workgroupIds Set of workgroup IDs the user has access to
     * @return List of most common vulnerabilities (max 10) with occurrence counts
     */
    @io.micronaut.data.annotation.Query(
        value = """
        SELECT v.vulnerability_id as vulnerabilityId,
               COALESCE(v.cvss_severity, 'UNKNOWN') as cvssSeverity,
               COUNT(*) as occurrenceCount,
               COUNT(DISTINCT v.asset_id) as affectedAssetCount
        FROM vulnerability v
        JOIN asset a ON v.asset_id = a.id
        JOIN asset_workgroups aw ON a.id = aw.asset_id
        WHERE aw.workgroup_id IN :workgroupIds
        GROUP BY v.vulnerability_id, v.cvss_severity
        ORDER BY COUNT(*) DESC
        LIMIT 10
        """,
        nativeQuery = true
    )
    fun findMostCommonVulnerabilitiesForWorkgroups(workgroupIds: Set<Long>): List<MostCommonVulnerabilityRow>

    /**
     * Find most common vulnerabilities for specific assets (unified access control)
     * Groups by CVE ID and severity, filters by asset IDs, counts occurrences, returns top 10
     *
     * Feature: 036-vuln-stats-lense, 043-crowdstrike-domain-import
     * Task: T012 [US1]
     * Spec reference: spec.md FR-001, FR-002, FR-006
     *
     * @param assetIds Set of asset IDs the user has access to
     * @return List of most common vulnerabilities (max 10) with occurrence counts
     */
    @io.micronaut.data.annotation.Query(
        value = """
        SELECT v.vulnerability_id as vulnerabilityId,
               COALESCE(v.cvss_severity, 'UNKNOWN') as cvssSeverity,
               COUNT(*) as occurrenceCount,
               COUNT(DISTINCT v.asset_id) as affectedAssetCount
        FROM vulnerability v
        WHERE v.asset_id IN :assetIds
        GROUP BY v.vulnerability_id, v.cvss_severity
        ORDER BY COUNT(*) DESC
        LIMIT 10
        """,
        nativeQuery = true
    )
    fun findMostCommonVulnerabilitiesForAssets(assetIds: Set<Long>): List<MostCommonVulnerabilityRow>

    // Feature 036: Vulnerability Statistics Lense - Most Vulnerable Products

    /**
     * Find most vulnerable products across ALL assets (ADMIN view)
     * Groups by product, counts distinct CVEs, returns top 10
     *
     * Feature: 036-vuln-stats-lense
     *
     * @return List of most vulnerable products (max 10) with vulnerability counts
     */
    @io.micronaut.data.annotation.Query(
        value = """
        SELECT v.vulnerable_product_versions as product,
               COUNT(DISTINCT v.vulnerability_id) as vulnerabilityCount,
               COUNT(DISTINCT v.asset_id) as affectedAssetCount,
               COUNT(DISTINCT CASE WHEN v.cvss_severity = 'CRITICAL' THEN v.vulnerability_id END) as criticalCount,
               COUNT(DISTINCT CASE WHEN v.cvss_severity = 'HIGH' THEN v.vulnerability_id END) as highCount
        FROM vulnerability v
        WHERE v.vulnerable_product_versions IS NOT NULL
          AND v.vulnerable_product_versions != ''
        GROUP BY v.vulnerable_product_versions
        ORDER BY COUNT(DISTINCT v.vulnerability_id) DESC
        LIMIT 10
        """,
        nativeQuery = true
    )
    fun findMostVulnerableProductsForAll(): List<MostVulnerableProductRow>

    /**
     * Find most vulnerable products for specific workgroups (VULN user view)
     * Groups by product, filters by workgroup access, counts distinct CVEs, returns top 10
     *
     * Feature: 036-vuln-stats-lense
     *
     * @param workgroupIds Set of workgroup IDs the user has access to
     * @return List of most vulnerable products (max 10) with vulnerability counts
     */
    @io.micronaut.data.annotation.Query(
        value = """
        SELECT v.vulnerable_product_versions as product,
               COUNT(DISTINCT v.vulnerability_id) as vulnerabilityCount,
               COUNT(DISTINCT v.asset_id) as affectedAssetCount,
               COUNT(DISTINCT CASE WHEN v.cvss_severity = 'CRITICAL' THEN v.vulnerability_id END) as criticalCount,
               COUNT(DISTINCT CASE WHEN v.cvss_severity = 'HIGH' THEN v.vulnerability_id END) as highCount
        FROM vulnerability v
        JOIN asset a ON v.asset_id = a.id
        JOIN asset_workgroups aw ON a.id = aw.asset_id
        WHERE aw.workgroup_id IN :workgroupIds
          AND v.vulnerable_product_versions IS NOT NULL
          AND v.vulnerable_product_versions != ''
        GROUP BY v.vulnerable_product_versions
        ORDER BY COUNT(DISTINCT v.vulnerability_id) DESC
        LIMIT 10
        """,
        nativeQuery = true
    )
    fun findMostVulnerableProductsForWorkgroups(workgroupIds: Set<Long>): List<MostVulnerableProductRow>

    /**
     * Find most vulnerable products for specific assets (unified access control)
     * Groups by product, filters by asset IDs, counts distinct CVEs, returns top 10
     *
     * Feature: 036-vuln-stats-lense
     *
     * @param assetIds Set of asset IDs the user has access to
     * @return List of most vulnerable products (max 10) with vulnerability counts
     */
    @io.micronaut.data.annotation.Query(
        value = """
        SELECT v.vulnerable_product_versions as product,
               COUNT(DISTINCT v.vulnerability_id) as vulnerabilityCount,
               COUNT(DISTINCT v.asset_id) as affectedAssetCount,
               COUNT(DISTINCT CASE WHEN v.cvss_severity = 'CRITICAL' THEN v.vulnerability_id END) as criticalCount,
               COUNT(DISTINCT CASE WHEN v.cvss_severity = 'HIGH' THEN v.vulnerability_id END) as highCount
        FROM vulnerability v
        WHERE v.asset_id IN :assetIds
          AND v.vulnerable_product_versions IS NOT NULL
          AND v.vulnerable_product_versions != ''
        GROUP BY v.vulnerable_product_versions
        ORDER BY COUNT(DISTINCT v.vulnerability_id) DESC
        LIMIT 10
        """,
        nativeQuery = true
    )
    fun findMostVulnerableProductsForAssets(assetIds: Set<Long>): List<MostVulnerableProductRow>

    // Feature 036: Vulnerability Statistics Lense - Severity Distribution (US2)

    /**
     * Get severity distribution for ALL vulnerabilities (ADMIN view)
     * Groups by severity level and counts occurrences
     *
     * Feature: 036-vuln-stats-lense
     * Task: T022 [US2]
     * Spec reference: spec.md FR-003, FR-004
     *
     * @return Map of severity level to count (CRITICAL, HIGH, MEDIUM, LOW, UNKNOWN)
     */
    @io.micronaut.data.annotation.Query(
        """
        SELECT COALESCE(v.cvssSeverity, 'UNKNOWN') as severity, COUNT(v) as count
        FROM Vulnerability v
        GROUP BY COALESCE(v.cvssSeverity, 'UNKNOWN')
        """
    )
    fun findSeverityDistributionForAll(): List<Map<String, Any>>

    /**
     * Get severity distribution for vulnerabilities in specific workgroups (VULN user view)
     * Groups by severity level, filters by workgroup access, counts occurrences
     *
     * Feature: 036-vuln-stats-lense
     * Task: T022 [US2]
     * Spec reference: spec.md FR-003, FR-004, FR-006
     *
     * @param workgroupIds Set of workgroup IDs the user has access to
     * @return Map of severity level to count (CRITICAL, HIGH, MEDIUM, LOW, UNKNOWN)
     */
    @io.micronaut.data.annotation.Query(
        """
        SELECT COALESCE(v.cvssSeverity, 'UNKNOWN') as severity, COUNT(v) as count
        FROM Vulnerability v
        JOIN v.asset a
        JOIN a.workgroups w
        WHERE w.id IN :workgroupIds
        GROUP BY COALESCE(v.cvssSeverity, 'UNKNOWN')
        """
    )
    fun findSeverityDistributionForWorkgroups(workgroupIds: Set<Long>): List<Map<String, Any>>

    /**
     * Get severity distribution for vulnerabilities in specific assets (unified access control)
     * Groups by severity level, filters by asset IDs, counts occurrences
     *
     * Feature: 036-vuln-stats-lense, 043-crowdstrike-domain-import
     * Task: T022 [US2]
     * Spec reference: spec.md FR-003, FR-004, FR-006
     *
     * @param assetIds Set of asset IDs the user has access to
     * @return Map of severity level to count (CRITICAL, HIGH, MEDIUM, LOW, UNKNOWN)
     */
    @io.micronaut.data.annotation.Query(
        """
        SELECT COALESCE(v.cvssSeverity, 'UNKNOWN') as severity, COUNT(v) as count
        FROM Vulnerability v
        WHERE v.asset.id IN :assetIds
        GROUP BY COALESCE(v.cvssSeverity, 'UNKNOWN')
        """
    )
    fun findSeverityDistributionForAssets(assetIds: Set<Long>): List<Map<String, Any>>

    // Feature 036: Vulnerability Statistics Lense - Top Assets by Vulnerabilities (US3)

    /**
     * Get top 50 assets ranked by total vulnerability count (ADMIN view)
     * Groups by asset, counts vulnerabilities with severity breakdowns
     *
     * Feature: 036-vuln-stats-lense
     * Task: T032 [US3]
     * Spec reference: spec.md FR-005, FR-006
     *
     * @return List of top 50 assets with vulnerability counts and severity breakdowns
     */
    @io.micronaut.data.annotation.Query(
        """
        SELECT a.id as assetId, a.name as assetName, a.type as assetType, a.ip as assetIp,
               COUNT(v) as totalVulnerabilityCount,
               SUM(CASE WHEN v.cvssSeverity = 'CRITICAL' THEN 1 ELSE 0 END) as criticalCount,
               SUM(CASE WHEN v.cvssSeverity = 'HIGH' THEN 1 ELSE 0 END) as highCount,
               SUM(CASE WHEN v.cvssSeverity = 'MEDIUM' THEN 1 ELSE 0 END) as mediumCount,
               SUM(CASE WHEN v.cvssSeverity = 'LOW' THEN 1 ELSE 0 END) as lowCount
        FROM Vulnerability v
        JOIN v.asset a
        GROUP BY a.id, a.name, a.type, a.ip
        ORDER BY COUNT(v) DESC
        LIMIT 50
        """
    )
    fun findTopAssetsByVulnerabilitiesForAll(): List<Map<String, Any>>

    /**
     * Get top 50 assets ranked by total vulnerability count for specific workgroups (VULN user view)
     * Groups by asset, filters by workgroup access, counts vulnerabilities with severity breakdowns
     *
     * Feature: 036-vuln-stats-lense
     * Task: T032 [US3]
     * Spec reference: spec.md FR-005, FR-006
     *
     * @param workgroupIds Set of workgroup IDs the user has access to
     * @return List of top 50 assets with vulnerability counts and severity breakdowns
     */
    @io.micronaut.data.annotation.Query(
        """
        SELECT a.id as assetId, a.name as assetName, a.type as assetType, a.ip as assetIp,
               COUNT(v) as totalVulnerabilityCount,
               SUM(CASE WHEN v.cvssSeverity = 'CRITICAL' THEN 1 ELSE 0 END) as criticalCount,
               SUM(CASE WHEN v.cvssSeverity = 'HIGH' THEN 1 ELSE 0 END) as highCount,
               SUM(CASE WHEN v.cvssSeverity = 'MEDIUM' THEN 1 ELSE 0 END) as mediumCount,
               SUM(CASE WHEN v.cvssSeverity = 'LOW' THEN 1 ELSE 0 END) as lowCount
        FROM Vulnerability v
        JOIN v.asset a
        JOIN a.workgroups w
        WHERE w.id IN :workgroupIds
        GROUP BY a.id, a.name, a.type, a.ip
        ORDER BY COUNT(v) DESC
        LIMIT 50
        """
    )
    fun findTopAssetsByVulnerabilitiesForWorkgroups(workgroupIds: Set<Long>): List<Map<String, Any>>

    /**
     * Get top 50 assets ranked by total vulnerability count for specific assets (unified access control)
     * Groups by asset, filters by asset IDs, counts vulnerabilities with severity breakdowns
     *
     * Feature: 036-vuln-stats-lense, 043-crowdstrike-domain-import
     * Task: T032 [US3]
     * Spec reference: spec.md FR-005, FR-006
     *
     * @param assetIds Set of asset IDs the user has access to
     * @return List of top 50 assets with vulnerability counts and severity breakdowns
     */
    @io.micronaut.data.annotation.Query(
        """
        SELECT a.id as assetId, a.name as assetName, a.type as assetType, a.ip as assetIp,
               COUNT(v) as totalVulnerabilityCount,
               SUM(CASE WHEN v.cvssSeverity = 'CRITICAL' THEN 1 ELSE 0 END) as criticalCount,
               SUM(CASE WHEN v.cvssSeverity = 'HIGH' THEN 1 ELSE 0 END) as highCount,
               SUM(CASE WHEN v.cvssSeverity = 'MEDIUM' THEN 1 ELSE 0 END) as mediumCount,
               SUM(CASE WHEN v.cvssSeverity = 'LOW' THEN 1 ELSE 0 END) as lowCount
        FROM Vulnerability v
        JOIN v.asset a
        WHERE a.id IN :assetIds
        GROUP BY a.id, a.name, a.type, a.ip
        ORDER BY COUNT(v) DESC
        LIMIT 50
        """
    )
    fun findTopAssetsByVulnerabilitiesForAssets(assetIds: Set<Long>): List<Map<String, Any>>

    // Feature 036: Vulnerability Statistics Lense - Vulnerabilities by Asset Type (US3)

    /**
     * Get vulnerability statistics grouped by asset type (ADMIN view)
     * Groups by asset type, counts vulnerabilities with severity breakdowns and average calculation
     *
     * Feature: 036-vuln-stats-lense
     * Task: T036 [US3]
     * Spec reference: spec.md FR-007, FR-008
     *
     * @return List of asset types with vulnerability statistics
     */
    @io.micronaut.data.annotation.Query(
        """
        SELECT COALESCE(a.type, 'Unknown') as assetType,
               COUNT(DISTINCT a.id) as assetCount,
               COUNT(v) as totalVulnerabilityCount,
               SUM(CASE WHEN v.cvssSeverity = 'CRITICAL' THEN 1 ELSE 0 END) as criticalCount,
               SUM(CASE WHEN v.cvssSeverity = 'HIGH' THEN 1 ELSE 0 END) as highCount,
               SUM(CASE WHEN v.cvssSeverity = 'MEDIUM' THEN 1 ELSE 0 END) as mediumCount,
               SUM(CASE WHEN v.cvssSeverity = 'LOW' THEN 1 ELSE 0 END) as lowCount,
               CAST(COUNT(v) AS double) / COUNT(DISTINCT a.id) as avgVulnsPerAsset
        FROM Vulnerability v
        JOIN v.asset a
        GROUP BY COALESCE(a.type, 'Unknown')
        ORDER BY COUNT(v) DESC
        """
    )
    fun findVulnerabilitiesByAssetTypeForAll(): List<Map<String, Any>>

    /**
     * Get vulnerability statistics grouped by asset type for specific workgroups (VULN user view)
     * Groups by asset type, filters by workgroup access, counts vulnerabilities with severity breakdowns
     *
     * Feature: 036-vuln-stats-lense
     * Task: T036 [US3]
     * Spec reference: spec.md FR-007, FR-008
     *
     * @param workgroupIds Set of workgroup IDs the user has access to
     * @return List of asset types with vulnerability statistics
     */
    @io.micronaut.data.annotation.Query(
        """
        SELECT COALESCE(a.type, 'Unknown') as assetType,
               COUNT(DISTINCT a.id) as assetCount,
               COUNT(v) as totalVulnerabilityCount,
               SUM(CASE WHEN v.cvssSeverity = 'CRITICAL' THEN 1 ELSE 0 END) as criticalCount,
               SUM(CASE WHEN v.cvssSeverity = 'HIGH' THEN 1 ELSE 0 END) as highCount,
               SUM(CASE WHEN v.cvssSeverity = 'MEDIUM' THEN 1 ELSE 0 END) as mediumCount,
               SUM(CASE WHEN v.cvssSeverity = 'LOW' THEN 1 ELSE 0 END) as lowCount,
               CAST(COUNT(v) AS double) / COUNT(DISTINCT a.id) as avgVulnsPerAsset
        FROM Vulnerability v
        JOIN v.asset a
        JOIN a.workgroups w
        WHERE w.id IN :workgroupIds
        GROUP BY COALESCE(a.type, 'Unknown')
        ORDER BY COUNT(v) DESC
        """
    )
    fun findVulnerabilitiesByAssetTypeForWorkgroups(workgroupIds: Set<Long>): List<Map<String, Any>>

    /**
     * Get vulnerability statistics grouped by asset type for specific assets (unified access control)
     * Groups by asset type, filters by asset IDs, counts vulnerabilities with severity breakdowns
     *
     * Feature: 036-vuln-stats-lense, 043-crowdstrike-domain-import
     * Task: T036 [US3]
     * Spec reference: spec.md FR-007, FR-008
     *
     * @param assetIds Set of asset IDs the user has access to
     * @return List of asset types with vulnerability statistics
     */
    @io.micronaut.data.annotation.Query(
        """
        SELECT COALESCE(a.type, 'Unknown') as assetType,
               COUNT(DISTINCT a.id) as assetCount,
               COUNT(v) as totalVulnerabilityCount,
               SUM(CASE WHEN v.cvssSeverity = 'CRITICAL' THEN 1 ELSE 0 END) as criticalCount,
               SUM(CASE WHEN v.cvssSeverity = 'HIGH' THEN 1 ELSE 0 END) as highCount,
               SUM(CASE WHEN v.cvssSeverity = 'MEDIUM' THEN 1 ELSE 0 END) as mediumCount,
               SUM(CASE WHEN v.cvssSeverity = 'LOW' THEN 1 ELSE 0 END) as lowCount,
               CAST(COUNT(v) AS double) / COUNT(DISTINCT a.id) as avgVulnsPerAsset
        FROM Vulnerability v
        JOIN v.asset a
        WHERE a.id IN :assetIds
        GROUP BY COALESCE(a.type, 'Unknown')
        ORDER BY COUNT(v) DESC
        """
    )
    fun findVulnerabilitiesByAssetTypeForAssets(assetIds: Set<Long>): List<Map<String, Any>>

    // Feature 036: Vulnerability Statistics Lense - Temporal Trends (US4)

    /**
     * Get temporal vulnerability trends for all assets (ADMIN view)
     * Groups by date, counts vulnerabilities with severity breakdowns over specified time period
     *
     * Feature: 036-vuln-stats-lense
     * Task: T048 [US4]
     * Spec reference: spec.md FR-009, FR-010, FR-011
     *
     * @param startDate Start date for trend analysis (inclusive)
     * @return List of daily data points with vulnerability counts
     */
    @io.micronaut.data.annotation.Query(
        """
        SELECT DATE(v.scanTimestamp) as date,
               COUNT(v) as totalCount,
               SUM(CASE WHEN v.cvssSeverity = 'CRITICAL' THEN 1 ELSE 0 END) as criticalCount,
               SUM(CASE WHEN v.cvssSeverity = 'HIGH' THEN 1 ELSE 0 END) as highCount,
               SUM(CASE WHEN v.cvssSeverity = 'MEDIUM' THEN 1 ELSE 0 END) as mediumCount,
               SUM(CASE WHEN v.cvssSeverity = 'LOW' THEN 1 ELSE 0 END) as lowCount
        FROM Vulnerability v
        WHERE v.scanTimestamp >= :startDate
        GROUP BY DATE(v.scanTimestamp)
        ORDER BY DATE(v.scanTimestamp) ASC
        """
    )
    fun findTemporalTrendsForAll(startDate: LocalDateTime): List<Map<String, Any>>

    /**
     * Get temporal vulnerability trends for specific workgroups (VULN user view)
     * Groups by date, filters by workgroup access, counts vulnerabilities with severity breakdowns
     *
     * Feature: 036-vuln-stats-lense
     * Task: T048 [US4]
     * Spec reference: spec.md FR-009, FR-010, FR-011
     *
     * @param workgroupIds Set of workgroup IDs the user has access to
     * @param startDate Start date for trend analysis (inclusive)
     * @return List of daily data points with vulnerability counts
     */
    @io.micronaut.data.annotation.Query(
        """
        SELECT DATE(v.scanTimestamp) as date,
               COUNT(v) as totalCount,
               SUM(CASE WHEN v.cvssSeverity = 'CRITICAL' THEN 1 ELSE 0 END) as criticalCount,
               SUM(CASE WHEN v.cvssSeverity = 'HIGH' THEN 1 ELSE 0 END) as highCount,
               SUM(CASE WHEN v.cvssSeverity = 'MEDIUM' THEN 1 ELSE 0 END) as mediumCount,
               SUM(CASE WHEN v.cvssSeverity = 'LOW' THEN 1 ELSE 0 END) as lowCount
        FROM Vulnerability v
        JOIN v.asset a
        JOIN a.workgroups w
        WHERE w.id IN :workgroupIds
        AND v.scanTimestamp >= :startDate
        GROUP BY DATE(v.scanTimestamp)
        ORDER BY DATE(v.scanTimestamp) ASC
        """
    )
    fun findTemporalTrendsForWorkgroups(workgroupIds: Set<Long>, startDate: LocalDateTime): List<Map<String, Any>>

    /**
     * Get temporal vulnerability trends for specific assets (unified access control)
     * Groups by date, filters by asset IDs, counts vulnerabilities with severity breakdowns
     *
     * Feature: 036-vuln-stats-lense, 043-crowdstrike-domain-import
     * Task: T048 [US4]
     * Spec reference: spec.md FR-009, FR-010, FR-011
     *
     * @param assetIds Set of asset IDs the user has access to
     * @param startDate Start date for trend analysis (inclusive)
     * @return List of daily data points with vulnerability counts
     */
    @io.micronaut.data.annotation.Query(
        """
        SELECT DATE(v.scanTimestamp) as date,
               COUNT(v) as totalCount,
               SUM(CASE WHEN v.cvssSeverity = 'CRITICAL' THEN 1 ELSE 0 END) as criticalCount,
               SUM(CASE WHEN v.cvssSeverity = 'HIGH' THEN 1 ELSE 0 END) as highCount,
               SUM(CASE WHEN v.cvssSeverity = 'MEDIUM' THEN 1 ELSE 0 END) as mediumCount,
               SUM(CASE WHEN v.cvssSeverity = 'LOW' THEN 1 ELSE 0 END) as lowCount
        FROM Vulnerability v
        WHERE v.asset.id IN :assetIds
        AND v.scanTimestamp >= :startDate
        GROUP BY DATE(v.scanTimestamp)
        ORDER BY DATE(v.scanTimestamp) ASC
        """
    )
    fun findTemporalTrendsForAssets(assetIds: Set<Long>, startDate: LocalDateTime): List<Map<String, Any>>

    // Database Optimization - Feature: Database Structure Optimization

    /**
     * Find latest vulnerabilities per asset (current vulnerabilities only)
     * Optimized database query that replaces in-memory filtering
     * Uses indexes: idx_vulnerability_asset, idx_vulnerability_scan_timestamp
     *
     * Feature: Database Structure Optimization
     *
     * This query finds vulnerabilities from the latest scan for each asset using a subquery.
     * Much more efficient than loading all vulnerabilities and filtering in memory.
     *
     * @return List of vulnerabilities from the latest scan per asset
     */
    @io.micronaut.data.annotation.Query(
        """
        SELECT v FROM Vulnerability v
        WHERE (v.asset.id, v.importTimestamp) IN (
            SELECT v2.asset.id, MAX(v2.importTimestamp)
            FROM Vulnerability v2
            GROUP BY v2.asset.id
        )
        ORDER BY v.importTimestamp DESC
        """
    )
    fun findLatestVulnerabilitiesPerAsset(): List<Vulnerability>

    /**
     * Find latest vulnerabilities per asset with pagination
     * Optimized for paginated views of current vulnerabilities
     * Uses indexes: idx_vulnerability_asset, idx_vulnerability_scan_timestamp
     *
     * Feature: Database Structure Optimization
     *
     * @param pageable Pagination parameters
     * @return Page of vulnerabilities from latest scan per asset
     */
    @io.micronaut.data.annotation.Query(
        value = """
        SELECT v FROM Vulnerability v
        WHERE (v.asset.id, v.importTimestamp) IN (
            SELECT v2.asset.id, MAX(v2.importTimestamp)
            FROM Vulnerability v2
            GROUP BY v2.asset.id
        )
        ORDER BY v.importTimestamp DESC
        """,
        countQuery = """
        SELECT COUNT(v) FROM Vulnerability v
        WHERE (v.asset.id, v.importTimestamp) IN (
            SELECT v2.asset.id, MAX(v2.importTimestamp)
            FROM Vulnerability v2
            GROUP BY v2.asset.id
        )
        """
    )
    fun findLatestVulnerabilitiesPerAsset(pageable: Pageable): Page<Vulnerability>

    /**
     * Find latest vulnerabilities per asset with filters
     * Optimized query for filtered current vulnerability views
     * Uses indexes: idx_vulnerability_asset, idx_vulnerability_severity, idx_vulnerability_scan_timestamp
     *
     * Feature: Database Structure Optimization
     *
     * @param severity Optional CVSS severity filter
     * @param assetName Optional asset name filter (case-insensitive)
     * @param productFilter Optional product version filter (case-insensitive)
     * @param domainFilter Optional AD domain filter (case-insensitive)
     * @param cloudAccountIdFilter Optional AWS cloud account ID filter (case-insensitive)
     * @param pageable Pagination parameters
     * @return Page of filtered current vulnerabilities
     */
    @io.micronaut.data.annotation.Query(
        value = """
        SELECT v FROM Vulnerability v
        JOIN FETCH v.asset a
        WHERE (:severity IS NULL OR v.cvssSeverity = :severity)
        AND (:assetName IS NULL OR LOWER(a.name) LIKE LOWER(CONCAT('%', :assetName, '%')))
        AND (:productFilter IS NULL OR LOWER(v.vulnerableProductVersions) LIKE LOWER(CONCAT('%', :productFilter, '%')))
        AND (:domainFilter IS NULL OR a.adDomain LIKE CONCAT('%', :domainFilter, '%'))
        AND (:cloudAccountIdFilter IS NULL OR a.cloudAccountId LIKE CONCAT('%', :cloudAccountIdFilter, '%'))
        ORDER BY v.importTimestamp DESC, a.name ASC, v.vulnerabilityId ASC
        """,
        countQuery = """
        SELECT COUNT(v) FROM Vulnerability v
        WHERE (:severity IS NULL OR v.cvssSeverity = :severity)
        AND (:assetName IS NULL OR LOWER(v.asset.name) LIKE LOWER(CONCAT('%', :assetName, '%')))
        AND (:productFilter IS NULL OR LOWER(v.vulnerableProductVersions) LIKE LOWER(CONCAT('%', :productFilter, '%')))
        AND (:domainFilter IS NULL OR v.asset.adDomain LIKE CONCAT('%', :domainFilter, '%'))
        AND (:cloudAccountIdFilter IS NULL OR v.asset.cloudAccountId LIKE CONCAT('%', :cloudAccountIdFilter, '%'))
        """
    )
    fun findLatestVulnerabilitiesPerAssetWithFilters(
        severity: String?,
        assetName: String?,
        productFilter: String?,
        domainFilter: String?,
        cloudAccountIdFilter: String?,
        pageable: Pageable
    ): Page<Vulnerability>

    // PERFORMANCE OPTIMIZATION: Batch queries for MaterializedViewRefreshService (Fix 3)

    /**
     * Find all vulnerabilities older than the threshold date
     * Returns full Vulnerability entities with eagerly fetched Asset for batch processing
     *
     * Feature: Outdated Assets Performance Optimization (Fix 3)
     * Replaces N+1 query pattern: Instead of querying per asset, get all overdue vulnerabilities at once
     *
     * @param thresholdDate Vulnerabilities with scanTimestamp before this date are considered overdue
     * @return List of all overdue vulnerabilities with their assets
     */
    @io.micronaut.data.annotation.Query(
        """
        SELECT v FROM Vulnerability v
        JOIN FETCH v.asset a
        LEFT JOIN FETCH a.workgroups
        WHERE v.scanTimestamp < :thresholdDate
        """
    )
    fun findOverdueVulnerabilitiesWithAssets(thresholdDate: LocalDateTime): List<Vulnerability>

    /**
     * Find the latest import timestamp across vulnerabilities for specific assets
     * Used for Domain Vulnerabilities "Last Synced" indicator
     *
     * Feature: Domain Vulnerability Sync
     *
     * @param assetIds Set of asset IDs to query
     * @return The most recent importTimestamp, or null if no vulnerabilities exist
     */
    @io.micronaut.data.annotation.Query(
        """
        SELECT MAX(v.importTimestamp) FROM Vulnerability v
        WHERE v.asset.id IN :assetIds
        """
    )
    fun findLatestImportTimestampByAssetIds(assetIds: Set<Long>): LocalDateTime?

    // PERFORMANCE OPTIMIZATION: Database-level access control queries

    /**
     * Find latest vulnerabilities per asset with filters AND access control
     * Pushes both filtering and access control to database level for true pagination
     *
     * Feature: Database Structure Optimization - Phase 2
     * Replaces: In-memory filtering by accessible asset IDs
     *
     * This query is for NON-ADMIN users - filters by accessible asset IDs
     * For ADMIN users, use findLatestVulnerabilitiesPerAssetWithFilters() instead
     *
     * @param accessibleAssetIds Set of asset IDs the user can access (from AssetFilterService)
     * @param severity Optional CVSS severity filter
     * @param assetName Optional asset name filter (case-insensitive)
     * @param productFilter Optional product version filter (case-insensitive)
     * @param domainFilter Optional AD domain filter (case-insensitive)
     * @param cloudAccountIdFilter Optional AWS cloud account ID filter (case-insensitive)
     * @param pageable Pagination parameters (NOT UNPAGED - use actual pagination!)
     * @return Page of filtered current vulnerabilities with access control applied
     */
    @io.micronaut.data.annotation.Query(
        value = """
        SELECT v FROM Vulnerability v
        JOIN FETCH v.asset a
        WHERE a.id IN :accessibleAssetIds
        AND (:severity IS NULL OR v.cvssSeverity = :severity)
        AND (:assetName IS NULL OR LOWER(a.name) LIKE LOWER(CONCAT('%', :assetName, '%')))
        AND (:productFilter IS NULL OR LOWER(v.vulnerableProductVersions) LIKE LOWER(CONCAT('%', :productFilter, '%')))
        AND (:domainFilter IS NULL OR a.adDomain LIKE CONCAT('%', :domainFilter, '%'))
        AND (:cloudAccountIdFilter IS NULL OR a.cloudAccountId LIKE CONCAT('%', :cloudAccountIdFilter, '%'))
        ORDER BY v.importTimestamp DESC, a.name ASC, v.vulnerabilityId ASC
        """,
        countQuery = """
        SELECT COUNT(v) FROM Vulnerability v
        WHERE v.asset.id IN :accessibleAssetIds
        AND (:severity IS NULL OR v.cvssSeverity = :severity)
        AND (:assetName IS NULL OR LOWER(v.asset.name) LIKE LOWER(CONCAT('%', :assetName, '%')))
        AND (:productFilter IS NULL OR LOWER(v.vulnerableProductVersions) LIKE LOWER(CONCAT('%', :productFilter, '%')))
        AND (:domainFilter IS NULL OR v.asset.adDomain LIKE CONCAT('%', :domainFilter, '%'))
        AND (:cloudAccountIdFilter IS NULL OR v.asset.cloudAccountId LIKE CONCAT('%', :cloudAccountIdFilter, '%'))
        """
    )
    fun findLatestVulnerabilitiesWithAccessControl(
        accessibleAssetIds: Set<Long>,
        severity: String?,
        assetName: String?,
        productFilter: String?,
        domainFilter: String?,
        cloudAccountIdFilter: String?,
        pageable: Pageable
    ): Page<Vulnerability>

    // Feature 052: CLI Add Vulnerability - Upsert Support

    /**
     * Find vulnerability by asset and CVE ID for upsert operation
     * Feature: 052-cli-add-vulnerability (FR-014)
     *
     * @param asset The asset entity
     * @param vulnerabilityId The CVE identifier
     * @return The vulnerability if found, null otherwise
     */
    fun findByAssetAndVulnerabilityId(asset: com.secman.domain.Asset, vulnerabilityId: String): Vulnerability?

    // Domain Vulnerabilities - Latest Import Only Filter

    /**
     * Find vulnerabilities from the latest import per asset
     * Used for Domain Vulnerabilities to match CrowdStrike Lookup counts
     *
     * Filters to only include vulnerabilities from the most recent importTimestamp
     * for each asset, eliminating historical/duplicate records.
     *
     * Uses ROW_NUMBER() window function for reliable filtering that handles:
     * - Timestamp precision issues (Java nanoseconds vs MariaDB microseconds)
     * - NULL import_timestamp values (treated as oldest, excluded)
     * - Multiple vulnerabilities with exact same timestamp (all included)
     *
     * Feature: 053-crowdstrike-import-cleanup
     *
     * @param assetIds Set of asset IDs to query
     * @return List of vulnerabilities from the latest import per asset
     */
    @io.micronaut.data.annotation.Query(
        value = """
        SELECT v.* FROM vulnerability v
        WHERE v.id IN (
            SELECT id FROM (
                SELECT id, asset_id, import_timestamp,
                       DENSE_RANK() OVER (PARTITION BY asset_id ORDER BY COALESCE(import_timestamp, '1970-01-01') DESC) as rnk
                FROM vulnerability
                WHERE asset_id IN :assetIds
            ) ranked
            WHERE rnk = 1
        )
        """,
        nativeQuery = true
    )
    fun findLatestVulnerabilitiesForAssetIds(assetIds: Set<Long>): List<Vulnerability>

    /**
     * Count vulnerabilities per asset for latest import only
     * Used for efficient count queries without loading all vulnerability data
     *
     * @param assetIds Set of asset IDs to query
     * @return Map-like result of asset_id to vulnerability count
     */
    @io.micronaut.data.annotation.Query(
        value = """
        SELECT v.asset_id, COUNT(*) as vuln_count
        FROM vulnerability v
        WHERE v.id IN (
            SELECT id FROM (
                SELECT id, asset_id, import_timestamp,
                       DENSE_RANK() OVER (PARTITION BY asset_id ORDER BY COALESCE(import_timestamp, '1970-01-01') DESC) as rnk
                FROM vulnerability
                WHERE asset_id IN :assetIds
            ) ranked
            WHERE rnk = 1
        )
        GROUP BY v.asset_id
        """,
        nativeQuery = true
    )
    fun countLatestVulnerabilitiesByAssetIds(assetIds: Set<Long>): List<Array<Any>>

    // Performance Optimization: SQL-level exception status filtering
    // Eliminates loading 358k rows into memory when filtering by overdue/excepted/ok status

    /**
     * Find vulnerabilities with OVERDUE status (admin, no asset restriction)
     * OVERDUE = age > threshold AND no matching active exception
     */
    @io.micronaut.data.annotation.Query(
        value = """
        SELECT v.* FROM vulnerability v
        JOIN asset a ON v.asset_id = a.id
        WHERE v.scan_timestamp < :thresholdDate
        AND (:severity IS NULL OR v.cvss_severity = :severity)
        AND (:assetName IS NULL OR LOWER(a.name) LIKE LOWER(CONCAT('%', :assetName, '%')))
        AND (:productFilter IS NULL OR LOWER(v.vulnerable_product_versions) LIKE LOWER(CONCAT('%', :productFilter, '%')))
        AND (:domainFilter IS NULL OR a.ad_domain LIKE CONCAT('%', :domainFilter, '%'))
        AND (:cloudAccountIdFilter IS NULL OR a.cloud_account_id LIKE CONCAT('%', :cloudAccountIdFilter, '%'))
        AND NOT EXISTS (
            SELECT 1 FROM vulnerability_exception e
            WHERE (e.expiration_date IS NULL OR e.expiration_date > NOW())
            AND (
                (e.exception_type = 'IP' AND e.target_value = a.ip)
                OR (e.exception_type = 'PRODUCT' AND (e.target_value = v.vulnerability_id OR LOCATE(e.target_value, v.vulnerable_product_versions) > 0))
                OR (e.exception_type = 'ASSET' AND e.asset_id = a.id)
                OR (e.exception_type = 'CVE' AND FIND_IN_SET(v.vulnerability_id, e.target_value) > 0 AND (e.asset_id IS NULL OR e.asset_id = a.id))
            )
        )
        ORDER BY v.import_timestamp DESC, a.name ASC, v.vulnerability_id ASC
        LIMIT :pageSize OFFSET :pageOffset
        """,
        nativeQuery = true
    )
    fun findOverdueVulnerabilitiesAdmin(
        thresholdDate: LocalDateTime,
        severity: String?,
        assetName: String?,
        productFilter: String?,
        domainFilter: String?,
        cloudAccountIdFilter: String?,
        pageSize: Int,
        pageOffset: Int
    ): List<Vulnerability>

    /**
     * Count vulnerabilities with OVERDUE status (admin)
     */
    @io.micronaut.data.annotation.Query(
        value = """
        SELECT COUNT(*) FROM vulnerability v
        JOIN asset a ON v.asset_id = a.id
        WHERE v.scan_timestamp < :thresholdDate
        AND (:severity IS NULL OR v.cvss_severity = :severity)
        AND (:assetName IS NULL OR LOWER(a.name) LIKE LOWER(CONCAT('%', :assetName, '%')))
        AND (:productFilter IS NULL OR LOWER(v.vulnerable_product_versions) LIKE LOWER(CONCAT('%', :productFilter, '%')))
        AND (:domainFilter IS NULL OR a.ad_domain LIKE CONCAT('%', :domainFilter, '%'))
        AND (:cloudAccountIdFilter IS NULL OR a.cloud_account_id LIKE CONCAT('%', :cloudAccountIdFilter, '%'))
        AND NOT EXISTS (
            SELECT 1 FROM vulnerability_exception e
            WHERE (e.expiration_date IS NULL OR e.expiration_date > NOW())
            AND (
                (e.exception_type = 'IP' AND e.target_value = a.ip)
                OR (e.exception_type = 'PRODUCT' AND (e.target_value = v.vulnerability_id OR LOCATE(e.target_value, v.vulnerable_product_versions) > 0))
                OR (e.exception_type = 'ASSET' AND e.asset_id = a.id)
                OR (e.exception_type = 'CVE' AND FIND_IN_SET(v.vulnerability_id, e.target_value) > 0 AND (e.asset_id IS NULL OR e.asset_id = a.id))
            )
        )
        """,
        nativeQuery = true
    )
    fun countOverdueVulnerabilitiesAdmin(
        thresholdDate: LocalDateTime,
        severity: String?,
        assetName: String?,
        productFilter: String?,
        domainFilter: String?,
        cloudAccountIdFilter: String?
    ): Long

    /**
     * Find vulnerabilities with EXCEPTED status (admin)
     * EXCEPTED = has a matching active exception
     */
    @io.micronaut.data.annotation.Query(
        value = """
        SELECT v.* FROM vulnerability v
        JOIN asset a ON v.asset_id = a.id
        WHERE (:severity IS NULL OR v.cvss_severity = :severity)
        AND (:assetName IS NULL OR LOWER(a.name) LIKE LOWER(CONCAT('%', :assetName, '%')))
        AND (:productFilter IS NULL OR LOWER(v.vulnerable_product_versions) LIKE LOWER(CONCAT('%', :productFilter, '%')))
        AND (:domainFilter IS NULL OR a.ad_domain LIKE CONCAT('%', :domainFilter, '%'))
        AND (:cloudAccountIdFilter IS NULL OR a.cloud_account_id LIKE CONCAT('%', :cloudAccountIdFilter, '%'))
        AND EXISTS (
            SELECT 1 FROM vulnerability_exception e
            WHERE (e.expiration_date IS NULL OR e.expiration_date > NOW())
            AND (
                (e.exception_type = 'IP' AND e.target_value = a.ip)
                OR (e.exception_type = 'PRODUCT' AND (e.target_value = v.vulnerability_id OR LOCATE(e.target_value, v.vulnerable_product_versions) > 0))
                OR (e.exception_type = 'ASSET' AND e.asset_id = a.id)
                OR (e.exception_type = 'CVE' AND FIND_IN_SET(v.vulnerability_id, e.target_value) > 0 AND (e.asset_id IS NULL OR e.asset_id = a.id))
            )
        )
        ORDER BY v.import_timestamp DESC, a.name ASC, v.vulnerability_id ASC
        LIMIT :pageSize OFFSET :pageOffset
        """,
        nativeQuery = true
    )
    fun findExceptedVulnerabilitiesAdmin(
        severity: String?,
        assetName: String?,
        productFilter: String?,
        domainFilter: String?,
        cloudAccountIdFilter: String?,
        pageSize: Int,
        pageOffset: Int
    ): List<Vulnerability>

    /**
     * Count vulnerabilities with EXCEPTED status (admin)
     */
    @io.micronaut.data.annotation.Query(
        value = """
        SELECT COUNT(*) FROM vulnerability v
        JOIN asset a ON v.asset_id = a.id
        WHERE (:severity IS NULL OR v.cvss_severity = :severity)
        AND (:assetName IS NULL OR LOWER(a.name) LIKE LOWER(CONCAT('%', :assetName, '%')))
        AND (:productFilter IS NULL OR LOWER(v.vulnerable_product_versions) LIKE LOWER(CONCAT('%', :productFilter, '%')))
        AND (:domainFilter IS NULL OR a.ad_domain LIKE CONCAT('%', :domainFilter, '%'))
        AND (:cloudAccountIdFilter IS NULL OR a.cloud_account_id LIKE CONCAT('%', :cloudAccountIdFilter, '%'))
        AND EXISTS (
            SELECT 1 FROM vulnerability_exception e
            WHERE (e.expiration_date IS NULL OR e.expiration_date > NOW())
            AND (
                (e.exception_type = 'IP' AND e.target_value = a.ip)
                OR (e.exception_type = 'PRODUCT' AND (e.target_value = v.vulnerability_id OR LOCATE(e.target_value, v.vulnerable_product_versions) > 0))
                OR (e.exception_type = 'ASSET' AND e.asset_id = a.id)
                OR (e.exception_type = 'CVE' AND FIND_IN_SET(v.vulnerability_id, e.target_value) > 0 AND (e.asset_id IS NULL OR e.asset_id = a.id))
            )
        )
        """,
        nativeQuery = true
    )
    fun countExceptedVulnerabilitiesAdmin(
        severity: String?,
        assetName: String?,
        productFilter: String?,
        domainFilter: String?,
        cloudAccountIdFilter: String?
    ): Long

    /**
     * Find vulnerabilities with OK status (admin)
     * OK = age <= threshold (not overdue)
     */
    @io.micronaut.data.annotation.Query(
        value = """
        SELECT v.* FROM vulnerability v
        JOIN asset a ON v.asset_id = a.id
        WHERE v.scan_timestamp >= :thresholdDate
        AND (:severity IS NULL OR v.cvss_severity = :severity)
        AND (:assetName IS NULL OR LOWER(a.name) LIKE LOWER(CONCAT('%', :assetName, '%')))
        AND (:productFilter IS NULL OR LOWER(v.vulnerable_product_versions) LIKE LOWER(CONCAT('%', :productFilter, '%')))
        AND (:domainFilter IS NULL OR a.ad_domain LIKE CONCAT('%', :domainFilter, '%'))
        AND (:cloudAccountIdFilter IS NULL OR a.cloud_account_id LIKE CONCAT('%', :cloudAccountIdFilter, '%'))
        ORDER BY v.import_timestamp DESC, a.name ASC, v.vulnerability_id ASC
        LIMIT :pageSize OFFSET :pageOffset
        """,
        nativeQuery = true
    )
    fun findOkVulnerabilitiesAdmin(
        thresholdDate: LocalDateTime,
        severity: String?,
        assetName: String?,
        productFilter: String?,
        domainFilter: String?,
        cloudAccountIdFilter: String?,
        pageSize: Int,
        pageOffset: Int
    ): List<Vulnerability>

    /**
     * Count vulnerabilities with OK status (admin)
     */
    @io.micronaut.data.annotation.Query(
        value = """
        SELECT COUNT(*) FROM vulnerability v
        JOIN asset a ON v.asset_id = a.id
        WHERE v.scan_timestamp >= :thresholdDate
        AND (:severity IS NULL OR v.cvss_severity = :severity)
        AND (:assetName IS NULL OR LOWER(a.name) LIKE LOWER(CONCAT('%', :assetName, '%')))
        AND (:productFilter IS NULL OR LOWER(v.vulnerable_product_versions) LIKE LOWER(CONCAT('%', :productFilter, '%')))
        AND (:domainFilter IS NULL OR a.ad_domain LIKE CONCAT('%', :domainFilter, '%'))
        AND (:cloudAccountIdFilter IS NULL OR a.cloud_account_id LIKE CONCAT('%', :cloudAccountIdFilter, '%'))
        """,
        nativeQuery = true
    )
    fun countOkVulnerabilitiesAdmin(
        thresholdDate: LocalDateTime,
        severity: String?,
        assetName: String?,
        productFilter: String?,
        domainFilter: String?,
        cloudAccountIdFilter: String?
    ): Long

    // Performance Optimization: Cached total count for unfiltered queries

    /**
     * Count total vulnerabilities (no filters)
     * Used by VulnerabilityService for cached count to avoid expensive COUNT on every page load
     *
     * @return Total count of all vulnerabilities
     */
    @io.micronaut.data.annotation.Query("SELECT COUNT(v) FROM Vulnerability v")
    fun countAll(): Long

    // Feature 054: Products Overview - Product query methods

    /**
     * Find distinct products for accessible assets (non-admin users)
     * Returns unique product names from vulnerabilities for assets the user can access
     *
     * Feature: 054-products-overview
     * Task: T004
     *
     * @param assetIds Set of asset IDs the user has access to
     * @return List of unique product names, sorted alphabetically
     */
    @io.micronaut.data.annotation.Query(
        """
        SELECT DISTINCT v.vulnerableProductVersions
        FROM Vulnerability v
        WHERE v.asset.id IN :assetIds
        AND v.vulnerableProductVersions IS NOT NULL
        AND v.vulnerableProductVersions != ''
        ORDER BY v.vulnerableProductVersions ASC
        """
    )
    fun findDistinctProductsForAssets(assetIds: Set<Long>): List<String>

    /**
     * Find distinct products for all assets (admin users)
     * Returns unique product names from all vulnerabilities
     *
     * Feature: 054-products-overview
     * Task: T005
     *
     * @return List of unique product names, sorted alphabetically
     */
    @io.micronaut.data.annotation.Query(
        """
        SELECT DISTINCT v.vulnerableProductVersions
        FROM Vulnerability v
        WHERE v.vulnerableProductVersions IS NOT NULL
        AND v.vulnerableProductVersions != ''
        ORDER BY v.vulnerableProductVersions ASC
        """
    )
    fun findDistinctProductsForAll(): List<String>

    /**
     * Find distinct products for accessible assets with search filter (non-admin users)
     * Returns unique product names matching the search term
     *
     * Feature: 054-products-overview
     * Task: T018
     *
     * @param assetIds Set of asset IDs the user has access to
     * @param search Search term for filtering products (case-insensitive)
     * @return List of unique product names matching search, sorted alphabetically
     */
    @io.micronaut.data.annotation.Query(
        """
        SELECT DISTINCT v.vulnerableProductVersions
        FROM Vulnerability v
        WHERE v.asset.id IN :assetIds
        AND v.vulnerableProductVersions IS NOT NULL
        AND v.vulnerableProductVersions != ''
        AND LOWER(v.vulnerableProductVersions) LIKE LOWER(CONCAT('%', :search, '%'))
        ORDER BY v.vulnerableProductVersions ASC
        """
    )
    fun findDistinctProductsForAssetsFiltered(assetIds: Set<Long>, search: String): List<String>

    /**
     * Find distinct products for all assets with search filter (admin users)
     * Returns unique product names matching the search term
     *
     * Feature: 054-products-overview
     * Task: T019
     *
     * @param search Search term for filtering products (case-insensitive)
     * @return List of unique product names matching search, sorted alphabetically
     */
    @io.micronaut.data.annotation.Query(
        """
        SELECT DISTINCT v.vulnerableProductVersions
        FROM Vulnerability v
        WHERE v.vulnerableProductVersions IS NOT NULL
        AND v.vulnerableProductVersions != ''
        AND LOWER(v.vulnerableProductVersions) LIKE LOWER(CONCAT('%', :search, '%'))
        ORDER BY v.vulnerableProductVersions ASC
        """
    )
    fun findDistinctProductsForAllFiltered(search: String): List<String>

    /**
     * Find top products by vulnerability count for all assets (admin users)
     * Returns products with their vulnerability counts, ordered by count descending
     *
     * Feature: 054-products-overview
     *
     * @param limit Maximum number of products to return
     * @return List of TopProductRow with product name and vulnerability count
     */
    @io.micronaut.data.annotation.Query(
        value = """
        SELECT v.vulnerable_product_versions as product, COUNT(*) as vulnerabilityCount
        FROM vulnerability v
        WHERE v.vulnerable_product_versions IS NOT NULL
        AND v.vulnerable_product_versions != ''
        GROUP BY v.vulnerable_product_versions
        ORDER BY vulnerabilityCount DESC
        LIMIT :limit
        """,
        nativeQuery = true
    )
    fun findTopProductsForAll(limit: Int): List<TopProductRow>

    /**
     * Find top products by vulnerability count for accessible assets (non-admin users)
     * Returns products with their vulnerability counts, ordered by count descending
     *
     * Feature: 054-products-overview
     *
     * @param assetIds Set of asset IDs the user has access to
     * @param limit Maximum number of products to return
     * @return List of TopProductRow with product name and vulnerability count
     */
    @io.micronaut.data.annotation.Query(
        value = """
        SELECT v.vulnerable_product_versions as product, COUNT(*) as vulnerabilityCount
        FROM vulnerability v
        WHERE v.asset_id IN (:assetIds)
        AND v.vulnerable_product_versions IS NOT NULL
        AND v.vulnerable_product_versions != ''
        GROUP BY v.vulnerable_product_versions
        ORDER BY vulnerabilityCount DESC
        LIMIT :limit
        """,
        nativeQuery = true
    )
    fun findTopProductsForAssets(assetIds: Set<Long>, limit: Int): List<TopProductRow>

    // Memory Optimization - Feature 073

    /**
     * Find duplicate vulnerability IDs using window function
     * Returns IDs of vulnerabilities that are duplicates (same asset, CVE, product)
     * Keeps only the most recent scan timestamp per unique combination
     *
     * Feature: 073-memory-optimization
     * Task: T008
     *
     * Uses batched processing to avoid loading all duplicates at once
     *
     * @param batchSize Maximum number of duplicate IDs to return per batch
     * @return List of vulnerability IDs to delete (duplicates)
     */
    @io.micronaut.data.annotation.Query(
        value = """
        SELECT id FROM (
            SELECT id, ROW_NUMBER() OVER (
                PARTITION BY asset_id, vulnerability_id, vulnerable_product_versions
                ORDER BY scan_timestamp DESC
            ) as rn
            FROM vulnerability
        ) ranked
        WHERE rn > 1
        LIMIT :batchSize
        """,
        nativeQuery = true
    )
    fun findDuplicateIds(batchSize: Int): List<Long>

    // SQL-level exception status filtering for non-admin users - Feature 073
    // These queries push access control AND exception status filtering to SQL

    /**
     * Find vulnerabilities with OVERDUE status (non-admin, with access control)
     * OVERDUE = age > threshold AND no matching active exception AND in accessible assets
     *
     * Feature: 073-memory-optimization
     * Task: T009
     */
    @io.micronaut.data.annotation.Query(
        value = """
        SELECT v.* FROM vulnerability v
        JOIN asset a ON v.asset_id = a.id
        WHERE a.id IN (:accessibleAssetIds)
        AND v.scan_timestamp < :thresholdDate
        AND (:severity IS NULL OR v.cvss_severity = :severity)
        AND (:assetName IS NULL OR LOWER(a.name) LIKE LOWER(CONCAT('%', :assetName, '%')))
        AND (:productFilter IS NULL OR LOWER(v.vulnerable_product_versions) LIKE LOWER(CONCAT('%', :productFilter, '%')))
        AND (:domainFilter IS NULL OR a.ad_domain LIKE CONCAT('%', :domainFilter, '%'))
        AND (:cloudAccountIdFilter IS NULL OR a.cloud_account_id LIKE CONCAT('%', :cloudAccountIdFilter, '%'))
        AND NOT EXISTS (
            SELECT 1 FROM vulnerability_exception e
            WHERE (e.expiration_date IS NULL OR e.expiration_date > NOW())
            AND (
                (e.exception_type = 'IP' AND e.target_value = a.ip)
                OR (e.exception_type = 'PRODUCT' AND (e.target_value = v.vulnerability_id OR LOCATE(e.target_value, v.vulnerable_product_versions) > 0))
                OR (e.exception_type = 'ASSET' AND e.asset_id = a.id)
                OR (e.exception_type = 'CVE' AND FIND_IN_SET(v.vulnerability_id, e.target_value) > 0 AND (e.asset_id IS NULL OR e.asset_id = a.id))
            )
        )
        ORDER BY v.import_timestamp DESC, a.name ASC, v.vulnerability_id ASC
        LIMIT :pageSize OFFSET :pageOffset
        """,
        nativeQuery = true
    )
    fun findOverdueVulnerabilitiesWithAccessControl(
        accessibleAssetIds: Set<Long>,
        thresholdDate: LocalDateTime,
        severity: String?,
        assetName: String?,
        productFilter: String?,
        domainFilter: String?,
        cloudAccountIdFilter: String?,
        pageSize: Int,
        pageOffset: Int
    ): List<Vulnerability>

    /**
     * Count vulnerabilities with OVERDUE status (non-admin, with access control)
     *
     * Feature: 073-memory-optimization
     * Task: T009
     */
    @io.micronaut.data.annotation.Query(
        value = """
        SELECT COUNT(*) FROM vulnerability v
        JOIN asset a ON v.asset_id = a.id
        WHERE a.id IN (:accessibleAssetIds)
        AND v.scan_timestamp < :thresholdDate
        AND (:severity IS NULL OR v.cvss_severity = :severity)
        AND (:assetName IS NULL OR LOWER(a.name) LIKE LOWER(CONCAT('%', :assetName, '%')))
        AND (:productFilter IS NULL OR LOWER(v.vulnerable_product_versions) LIKE LOWER(CONCAT('%', :productFilter, '%')))
        AND (:domainFilter IS NULL OR a.ad_domain LIKE CONCAT('%', :domainFilter, '%'))
        AND (:cloudAccountIdFilter IS NULL OR a.cloud_account_id LIKE CONCAT('%', :cloudAccountIdFilter, '%'))
        AND NOT EXISTS (
            SELECT 1 FROM vulnerability_exception e
            WHERE (e.expiration_date IS NULL OR e.expiration_date > NOW())
            AND (
                (e.exception_type = 'IP' AND e.target_value = a.ip)
                OR (e.exception_type = 'PRODUCT' AND (e.target_value = v.vulnerability_id OR LOCATE(e.target_value, v.vulnerable_product_versions) > 0))
                OR (e.exception_type = 'ASSET' AND e.asset_id = a.id)
                OR (e.exception_type = 'CVE' AND FIND_IN_SET(v.vulnerability_id, e.target_value) > 0 AND (e.asset_id IS NULL OR e.asset_id = a.id))
            )
        )
        """,
        nativeQuery = true
    )
    fun countOverdueVulnerabilitiesWithAccessControl(
        accessibleAssetIds: Set<Long>,
        thresholdDate: LocalDateTime,
        severity: String?,
        assetName: String?,
        productFilter: String?,
        domainFilter: String?,
        cloudAccountIdFilter: String?
    ): Long

    /**
     * Find vulnerabilities with EXCEPTED status (non-admin, with access control)
     * EXCEPTED = has a matching active exception AND in accessible assets
     *
     * Feature: 073-memory-optimization
     * Task: T009
     */
    @io.micronaut.data.annotation.Query(
        value = """
        SELECT v.* FROM vulnerability v
        JOIN asset a ON v.asset_id = a.id
        WHERE a.id IN (:accessibleAssetIds)
        AND (:severity IS NULL OR v.cvss_severity = :severity)
        AND (:assetName IS NULL OR LOWER(a.name) LIKE LOWER(CONCAT('%', :assetName, '%')))
        AND (:productFilter IS NULL OR LOWER(v.vulnerable_product_versions) LIKE LOWER(CONCAT('%', :productFilter, '%')))
        AND (:domainFilter IS NULL OR a.ad_domain LIKE CONCAT('%', :domainFilter, '%'))
        AND (:cloudAccountIdFilter IS NULL OR a.cloud_account_id LIKE CONCAT('%', :cloudAccountIdFilter, '%'))
        AND EXISTS (
            SELECT 1 FROM vulnerability_exception e
            WHERE (e.expiration_date IS NULL OR e.expiration_date > NOW())
            AND (
                (e.exception_type = 'IP' AND e.target_value = a.ip)
                OR (e.exception_type = 'PRODUCT' AND (e.target_value = v.vulnerability_id OR LOCATE(e.target_value, v.vulnerable_product_versions) > 0))
                OR (e.exception_type = 'ASSET' AND e.asset_id = a.id)
                OR (e.exception_type = 'CVE' AND FIND_IN_SET(v.vulnerability_id, e.target_value) > 0 AND (e.asset_id IS NULL OR e.asset_id = a.id))
            )
        )
        ORDER BY v.import_timestamp DESC, a.name ASC, v.vulnerability_id ASC
        LIMIT :pageSize OFFSET :pageOffset
        """,
        nativeQuery = true
    )
    fun findExceptedVulnerabilitiesWithAccessControl(
        accessibleAssetIds: Set<Long>,
        severity: String?,
        assetName: String?,
        productFilter: String?,
        domainFilter: String?,
        cloudAccountIdFilter: String?,
        pageSize: Int,
        pageOffset: Int
    ): List<Vulnerability>

    /**
     * Count vulnerabilities with EXCEPTED status (non-admin, with access control)
     *
     * Feature: 073-memory-optimization
     * Task: T009
     */
    @io.micronaut.data.annotation.Query(
        value = """
        SELECT COUNT(*) FROM vulnerability v
        JOIN asset a ON v.asset_id = a.id
        WHERE a.id IN (:accessibleAssetIds)
        AND (:severity IS NULL OR v.cvss_severity = :severity)
        AND (:assetName IS NULL OR LOWER(a.name) LIKE LOWER(CONCAT('%', :assetName, '%')))
        AND (:productFilter IS NULL OR LOWER(v.vulnerable_product_versions) LIKE LOWER(CONCAT('%', :productFilter, '%')))
        AND (:domainFilter IS NULL OR a.ad_domain LIKE CONCAT('%', :domainFilter, '%'))
        AND (:cloudAccountIdFilter IS NULL OR a.cloud_account_id LIKE CONCAT('%', :cloudAccountIdFilter, '%'))
        AND EXISTS (
            SELECT 1 FROM vulnerability_exception e
            WHERE (e.expiration_date IS NULL OR e.expiration_date > NOW())
            AND (
                (e.exception_type = 'IP' AND e.target_value = a.ip)
                OR (e.exception_type = 'PRODUCT' AND (e.target_value = v.vulnerability_id OR LOCATE(e.target_value, v.vulnerable_product_versions) > 0))
                OR (e.exception_type = 'ASSET' AND e.asset_id = a.id)
                OR (e.exception_type = 'CVE' AND FIND_IN_SET(v.vulnerability_id, e.target_value) > 0 AND (e.asset_id IS NULL OR e.asset_id = a.id))
            )
        )
        """,
        nativeQuery = true
    )
    fun countExceptedVulnerabilitiesWithAccessControl(
        accessibleAssetIds: Set<Long>,
        severity: String?,
        assetName: String?,
        productFilter: String?,
        domainFilter: String?,
        cloudAccountIdFilter: String?
    ): Long

    /**
     * Find vulnerabilities with OK status (non-admin, with access control)
     * OK = age <= threshold AND in accessible assets
     *
     * Feature: 073-memory-optimization
     * Task: T009
     */
    @io.micronaut.data.annotation.Query(
        value = """
        SELECT v.* FROM vulnerability v
        JOIN asset a ON v.asset_id = a.id
        WHERE a.id IN (:accessibleAssetIds)
        AND v.scan_timestamp >= :thresholdDate
        AND (:severity IS NULL OR v.cvss_severity = :severity)
        AND (:assetName IS NULL OR LOWER(a.name) LIKE LOWER(CONCAT('%', :assetName, '%')))
        AND (:productFilter IS NULL OR LOWER(v.vulnerable_product_versions) LIKE LOWER(CONCAT('%', :productFilter, '%')))
        AND (:domainFilter IS NULL OR a.ad_domain LIKE CONCAT('%', :domainFilter, '%'))
        AND (:cloudAccountIdFilter IS NULL OR a.cloud_account_id LIKE CONCAT('%', :cloudAccountIdFilter, '%'))
        ORDER BY v.import_timestamp DESC, a.name ASC, v.vulnerability_id ASC
        LIMIT :pageSize OFFSET :pageOffset
        """,
        nativeQuery = true
    )
    fun findOkVulnerabilitiesWithAccessControl(
        accessibleAssetIds: Set<Long>,
        thresholdDate: LocalDateTime,
        severity: String?,
        assetName: String?,
        productFilter: String?,
        domainFilter: String?,
        cloudAccountIdFilter: String?,
        pageSize: Int,
        pageOffset: Int
    ): List<Vulnerability>

    /**
     * Count vulnerabilities with OK status (non-admin, with access control)
     *
     * Feature: 073-memory-optimization
     * Task: T009
     */
    @io.micronaut.data.annotation.Query(
        value = """
        SELECT COUNT(*) FROM vulnerability v
        JOIN asset a ON v.asset_id = a.id
        WHERE a.id IN (:accessibleAssetIds)
        AND v.scan_timestamp >= :thresholdDate
        AND (:severity IS NULL OR v.cvss_severity = :severity)
        AND (:assetName IS NULL OR LOWER(a.name) LIKE LOWER(CONCAT('%', :assetName, '%')))
        AND (:productFilter IS NULL OR LOWER(v.vulnerable_product_versions) LIKE LOWER(CONCAT('%', :productFilter, '%')))
        AND (:domainFilter IS NULL OR a.ad_domain LIKE CONCAT('%', :domainFilter, '%'))
        AND (:cloudAccountIdFilter IS NULL OR a.cloud_account_id LIKE CONCAT('%', :cloudAccountIdFilter, '%'))
        """,
        nativeQuery = true
    )
    fun countOkVulnerabilitiesWithAccessControl(
        accessibleAssetIds: Set<Long>,
        thresholdDate: LocalDateTime,
        severity: String?,
        assetName: String?,
        productFilter: String?,
        domainFilter: String?,
        cloudAccountIdFilter: String?
    ): Long

}
