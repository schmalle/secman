package com.secman.domain

import com.fasterxml.jackson.annotation.JsonIgnore
import io.micronaut.serde.annotation.Serdeable
import jakarta.persistence.*
import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.NotNull
import jakarta.validation.constraints.Size
import org.hibernate.annotations.OnDelete
import org.hibernate.annotations.OnDeleteAction
import java.time.LocalDateTime

/**
 * VulnerabilityExceptionRequest entity representing a request to create an exception for a vulnerability.
 *
 * Workflow:
 * - Regular users create requests with PENDING status (requires approval)
 * - ADMIN/SECCHAMPION users get auto-approved requests (status immediately APPROVED)
 * - ADMIN/SECCHAMPION can approve or reject PENDING requests
 * - Approved requests create corresponding VulnerabilityException entries
 *
 * State machine:
 * - PENDING → APPROVED, REJECTED, CANCELLED
 * - APPROVED → EXPIRED
 * - REJECTED, CANCELLED, EXPIRED → (terminal states)
 *
 * Related to: Feature 031-vuln-exception-approval (Vulnerability Exception Request & Approval Workflow)
 *
 * @property id Unique identifier
 * @property vulnerability Vulnerability this request applies to
 * @property requestedByUser User who submitted the request (nullable for audit after user deletion)
 * @property requestedByUsername Username of requester (preserved for audit trail)
 * @property scope Exception scope (SINGLE_VULNERABILITY or CVE_PATTERN)
 * @property reason Business justification (50-2048 characters)
 * @property expirationDate When the exception should expire
 * @property status Current status (PENDING, APPROVED, REJECTED, EXPIRED, CANCELLED)
 * @property autoApproved True if ADMIN/SECCHAMPION auto-approved
 * @property reviewedByUser Reviewer who approved/rejected (nullable for audit after user deletion)
 * @property reviewedByUsername Username of reviewer (preserved for audit trail)
 * @property reviewDate When the request was reviewed
 * @property reviewComment Reviewer's notes/justification
 * @property createdAt When the request was created
 * @property updatedAt When the request was last modified
 * @property version Optimistic locking version for concurrency control
 */
@Entity
@Table(
    name = "vulnerability_exception_request",
    indexes = [
        Index(name = "idx_vuln_req_vulnerability", columnList = "vulnerability_id"),
        Index(name = "idx_vuln_req_status", columnList = "status"),
        Index(name = "idx_vuln_req_requester", columnList = "requested_by_user_id"),
        Index(name = "idx_vuln_req_reviewer", columnList = "reviewed_by_user_id"),
        Index(name = "idx_vuln_req_created", columnList = "created_at"),
        Index(name = "idx_vuln_req_expiration", columnList = "expiration_date")
    ]
)
@Serdeable
data class VulnerabilityExceptionRequest(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    var id: Long? = null,

    /**
     * Vulnerability this request applies to
     * ManyToOne relationship with nullable for orphaned requests (vulnerability deleted)
     *
     * FK constraint: ON DELETE SET NULL - Preserves exception requests for audit trail
     * when vulnerability is deleted (e.g., via asset cascade deletion)
     */
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "vulnerability_id", nullable = true)
    @OnDelete(action = OnDeleteAction.SET_NULL)
    @JsonIgnore // Prevent lazy loading errors during JSON serialization
    var vulnerability: Vulnerability? = null,

    /**
     * User who requested the exception
     * Nullable: If user deleted, preserve username for audit trail
     */
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "requested_by_user_id")
    @JsonIgnore
    var requestedByUser: User? = null,

    /**
     * Username of requester (denormalized for audit trail)
     * Preserved even if user account deleted
     */
    @Column(name = "requested_by_username", nullable = false, length = 255)
    @NotBlank
    @Size(max = 255)
    var requestedByUsername: String,

    /**
     * Exception scope: SINGLE_VULNERABILITY or CVE_PATTERN
     */
    @Enumerated(EnumType.STRING)
    @Column(name = "scope", nullable = false, length = 20)
    @NotNull
    var scope: ExceptionScope,

    /**
     * Business justification for the exception
     * Required: 50-2048 characters, plain text only (XSS sanitized)
     */
    @Column(name = "reason", nullable = false, length = 2048)
    @NotBlank
    @Size(min = 50, max = 2048)
    var reason: String,

    /**
     * When the exception should expire
     * Must be future date at creation
     */
    @Column(name = "expiration_date", nullable = false)
    @NotNull
    var expirationDate: LocalDateTime,

    /**
     * Current status: PENDING, APPROVED, REJECTED, EXPIRED, CANCELLED
     */
    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false, length = 20)
    @NotNull
    var status: ExceptionRequestStatus,

    /**
     * True if this was auto-approved (requester has ADMIN/SECCHAMPION role)
     */
    @Column(name = "auto_approved", nullable = false)
    var autoApproved: Boolean = false,

    /**
     * User who reviewed (approved or rejected) the request
     * Nullable: If reviewer deleted, preserve username for audit trail
     */
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "reviewed_by_user_id")
    @JsonIgnore
    var reviewedByUser: User? = null,

    /**
     * Username of reviewer (denormalized for audit trail)
     * Preserved even if reviewer account deleted
     */
    @Column(name = "reviewed_by_username", length = 255)
    @Size(max = 255)
    var reviewedByUsername: String? = null,

    /**
     * When the request was reviewed (approved or rejected)
     */
    @Column(name = "review_date")
    var reviewDate: LocalDateTime? = null,

    /**
     * Reviewer's comment/justification
     * Optional for approval, required for rejection (10-1024 characters)
     */
    @Column(name = "review_comment", length = 1024)
    @Size(max = 1024)
    var reviewComment: String? = null,

    @Column(name = "created_at", updatable = false)
    var createdAt: LocalDateTime? = null,

    @Column(name = "updated_at")
    var updatedAt: LocalDateTime? = null,

    /**
     * Optimistic locking version for concurrency control
     * Prevents race conditions when multiple users try to approve/reject simultaneously
     */
    @Version
    @Column(name = "version", nullable = false)
    var version: Long = 0
) {
    @PrePersist
    fun onCreate() {
        val now = LocalDateTime.now()
        createdAt = now
        updatedAt = now
    }

    @PreUpdate
    fun onUpdate() {
        updatedAt = LocalDateTime.now()
    }

    /**
     * Check if this request can transition to the given status
     */
    fun canTransitionTo(newStatus: ExceptionRequestStatus): Boolean {
        return status.canTransitionTo(newStatus)
    }

    /**
     * Check if this request is in a terminal state (cannot be modified)
     */
    fun isTerminal(): Boolean {
        return status.isTerminal()
    }

    override fun toString(): String {
        return "VulnerabilityExceptionRequest(id=$id, status=$status, " +
                "scope=$scope, requestedBy='$requestedByUsername', " +
                "autoApproved=$autoApproved, reviewedBy='$reviewedByUsername', " +
                "created=$createdAt)"
    }

    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other !is VulnerabilityExceptionRequest) return false
        return id != null && id == other.id
    }

    override fun hashCode(): Int {
        return id?.hashCode() ?: 0
    }
}
