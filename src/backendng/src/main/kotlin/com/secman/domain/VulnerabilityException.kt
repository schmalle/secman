package com.secman.domain

import io.micronaut.serde.annotation.Serdeable
import jakarta.persistence.*
import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.NotNull
import jakarta.validation.constraints.Size
import java.time.LocalDateTime

/**
 * VulnerabilityException entity representing an exception rule for vulnerabilities.
 *
 * Exceptions can be:
 * - IP-based: Applies to all vulnerabilities on a specific IP address
 * - PRODUCT-based: Applies to all vulnerabilities matching a product pattern
 * - ASSET-based: Applies to all vulnerabilities on a specific asset (by ID)
 * - CVE-based: Applies to a specific CVE ID, optionally scoped to one asset
 *   - targetValue = one or more comma-separated CVE IDs (e.g., "CVE-2023-29326,CVE-2024-1234")
 *   - assetId = null for system-wide, or asset ID for single-system scope
 *
 * All exceptions require an expiration date (Feature 021).
 * Time-limited exceptions enforce periodic review.
 *
 * Related to: Feature 004-i-want-to (VULN Role & Vulnerability Management UI)
 * Related to: Feature 021-vulnerability-overdue-exception-logic (Asset exceptions)
 */
@Entity
@Table(
    name = "vulnerability_exception",
    indexes = [
        Index(name = "idx_vuln_exception_type", columnList = "exception_type"),
        Index(name = "idx_vuln_exception_expiration", columnList = "expiration_date"),
        Index(name = "idx_vuln_exception_asset", columnList = "asset_id"),
        // PERFORMANCE: Composite indexes for faster exception matching queries
        Index(name = "idx_vuln_exception_type_target", columnList = "exception_type, target_value"),
        Index(name = "idx_vuln_exception_active", columnList = "expiration_date, exception_type")
    ]
)
@Serdeable
data class VulnerabilityException(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    var id: Long? = null,

    /**
     * Type of exception: IP, PRODUCT, ASSET, or CVE
     */
    @Enumerated(EnumType.STRING)
    @Column(name = "exception_type", nullable = false, length = 20)
    @NotNull
    var exceptionType: ExceptionType,

    /**
     * Target value for the exception:
     * - For IP: exact IP address (e.g., "192.168.1.10")
     * - For PRODUCT: product name/version pattern (e.g., "OpenSSH 7.4")
     * - For ASSET: not used (assetId field used instead)
     * - For CVE: one or more comma-separated CVE identifiers (e.g., "CVE-2023-29326,CVE-2024-1234")
     */
    @Column(name = "target_value", nullable = false, length = 512)
    @NotBlank
    @Size(max = 512)
    var targetValue: String,

    /**
     * Asset ID for ASSET-type and CVE-type exceptions
     * - For IP/PRODUCT exceptions: null
     * - For ASSET exceptions: ID of the specific asset
     * - For CVE exceptions: null (system-wide) or asset ID (single-system scope)
     */
    @Column(name = "asset_id")
    var assetId: Long? = null,

    /**
     * Expiration date for the exception
     * Feature 021: All exceptions now require an end date
     * - null = legacy exception (from before Feature 021)
     * - non-null = exception expires after this date (required going forward)
     */
    @Column(name = "expiration_date")
    var expirationDate: LocalDateTime? = null,

    /**
     * Reason/justification for the exception
     */
    @Column(name = "reason", nullable = false, length = 1024)
    @NotBlank
    @Size(max = 1024)
    var reason: String,

    /**
     * User who created the exception
     */
    @Column(name = "created_by", nullable = false, length = 255)
    @NotBlank
    @Size(max = 255)
    var createdBy: String,

    @Column(name = "created_at", updatable = false)
    var createdAt: LocalDateTime? = null,

    @Column(name = "updated_at")
    var updatedAt: LocalDateTime? = null
) {
    enum class ExceptionType {
        IP,      // Exception applies to specific IP address
        PRODUCT, // Exception applies to product name/version pattern
        ASSET,   // Exception applies to specific asset by ID (Feature 021)
        CVE      // Exception applies to specific CVE ID, optionally scoped to one asset
    }

    @PrePersist
    fun onCreate() {
        val now = LocalDateTime.now()
        createdAt = now
        updatedAt = now
    }

    @PreUpdate
    fun onUpdate() {
        updatedAt = LocalDateTime.now()
    }

    /**
     * Check if this exception is currently active
     */
    fun isActive(): Boolean {
        return expirationDate == null || expirationDate!!.isAfter(LocalDateTime.now())
    }

    /**
     * Check if this exception matches the given vulnerability and asset
     *
     * Feature 021: Added ASSET type matching by asset ID
     * Bug fix: PRODUCT type now also matches CVE ID patterns
     */
    fun matches(vulnerability: Vulnerability, asset: Asset): Boolean {
        if (!isActive()) return false

        return when (exceptionType) {
            ExceptionType.IP -> asset.ip == targetValue
            ExceptionType.PRODUCT -> {
                // Match either CVE ID (e.g., "CVE-2023-29326") or product version string
                vulnerability.vulnerabilityId == targetValue ||
                vulnerability.vulnerableProductVersions?.contains(targetValue) == true
            }
            ExceptionType.ASSET -> assetId != null && assetId == asset.id
            ExceptionType.CVE -> {
                val cveIds = targetValue.split(",").map { it.trim() }
                val cveMatches = vulnerability.vulnerabilityId in cveIds
                if (assetId != null) {
                    cveMatches && assetId == asset.id
                } else {
                    cveMatches
                }
            }
        }
    }

    override fun toString(): String {
        return "VulnerabilityException(id=$id, type=$exceptionType, target='$targetValue', " +
                "assetId=$assetId, expires=${expirationDate ?: "never"}, active=${isActive()})"
    }

    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other !is VulnerabilityException) return false
        return id != null && id == other.id
    }

    override fun hashCode(): Int {
        return id?.hashCode() ?: 0
    }
}
