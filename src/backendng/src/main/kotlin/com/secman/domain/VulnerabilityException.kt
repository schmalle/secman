package com.secman.domain

import io.micronaut.serde.annotation.Serdeable
import jakarta.persistence.*
import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.NotNull
import jakarta.validation.constraints.Size
import java.time.LocalDateTime

/**
 * VulnerabilityException entity representing an exception rule for vulnerabilities.
 *
 * Exceptions can be IP-based (applies to all vulnerabilities on a specific IP)
 * or product-based (applies to all vulnerabilities matching a product pattern).
 *
 * Exceptions can be time-limited (with expirationDate) or permanent (expirationDate = null).
 *
 * Related to: Feature 004-i-want-to (VULN Role & Vulnerability Management UI)
 */
@Entity
@Table(
    name = "vulnerability_exception",
    indexes = [
        Index(name = "idx_vuln_exception_type", columnList = "exception_type"),
        Index(name = "idx_vuln_exception_expiration", columnList = "expiration_date")
    ]
)
@Serdeable
data class VulnerabilityException(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    var id: Long? = null,

    /**
     * Type of exception: IP or PRODUCT
     */
    @Enumerated(EnumType.STRING)
    @Column(name = "exception_type", nullable = false, length = 20)
    @NotNull
    var exceptionType: ExceptionType,

    /**
     * Target value for the exception:
     * - For IP: exact IP address (e.g., "192.168.1.10")
     * - For PRODUCT: product name/version pattern (e.g., "OpenSSH 7.4")
     */
    @Column(name = "target_value", nullable = false, length = 512)
    @NotBlank
    @Size(max = 512)
    var targetValue: String,

    /**
     * Expiration date for the exception
     * - null = permanent exception (never expires)
     * - non-null = exception expires after this date
     */
    @Column(name = "expiration_date")
    var expirationDate: LocalDateTime? = null,

    /**
     * Reason/justification for the exception
     */
    @Column(name = "reason", nullable = false, length = 1024)
    @NotBlank
    @Size(max = 1024)
    var reason: String,

    /**
     * User who created the exception
     */
    @Column(name = "created_by", nullable = false, length = 255)
    @NotBlank
    @Size(max = 255)
    var createdBy: String,

    @Column(name = "created_at", updatable = false)
    var createdAt: LocalDateTime? = null,

    @Column(name = "updated_at")
    var updatedAt: LocalDateTime? = null
) {
    enum class ExceptionType {
        IP,      // Exception applies to specific IP address
        PRODUCT  // Exception applies to product name/version pattern
    }

    @PrePersist
    fun onCreate() {
        val now = LocalDateTime.now()
        createdAt = now
        updatedAt = now
    }

    @PreUpdate
    fun onUpdate() {
        updatedAt = LocalDateTime.now()
    }

    /**
     * Check if this exception is currently active
     */
    fun isActive(): Boolean {
        return expirationDate == null || expirationDate!!.isAfter(LocalDateTime.now())
    }

    /**
     * Check if this exception matches the given vulnerability and asset
     */
    fun matches(vulnerability: Vulnerability, asset: Asset): Boolean {
        if (!isActive()) return false

        return when (exceptionType) {
            ExceptionType.IP -> asset.ip == targetValue
            ExceptionType.PRODUCT -> vulnerability.vulnerableProductVersions?.contains(targetValue) == true
        }
    }

    override fun toString(): String {
        return "VulnerabilityException(id=$id, type=$exceptionType, target='$targetValue', " +
                "expires=${expirationDate ?: "never"}, active=${isActive()})"
    }

    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other !is VulnerabilityException) return false
        return id != null && id == other.id
    }

    override fun hashCode(): Int {
        return id?.hashCode() ?: 0
    }
}
