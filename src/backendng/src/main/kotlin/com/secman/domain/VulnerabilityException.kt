package com.secman.domain

import io.micronaut.serde.annotation.Serdeable
import jakarta.persistence.*
import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.NotNull
import jakarta.validation.constraints.Size
import java.time.LocalDateTime

/**
 * VulnerabilityException entity representing an exception rule for vulnerabilities.
 *
 * Exceptions can be:
 * - IP-based: Applies to all vulnerabilities on a specific IP address
 * - PRODUCT-based: Applies to all vulnerabilities matching a product pattern
 * - ASSET-based: Applies to all vulnerabilities on a specific asset (by ID)
 *
 * All exceptions require an expiration date (Feature 021).
 * Time-limited exceptions enforce periodic review.
 *
 * Related to: Feature 004-i-want-to (VULN Role & Vulnerability Management UI)
 * Related to: Feature 021-vulnerability-overdue-exception-logic (Asset exceptions)
 */
@Entity
@Table(
    name = "vulnerability_exception",
    indexes = [
        Index(name = "idx_vuln_exception_type", columnList = "exception_type"),
        Index(name = "idx_vuln_exception_expiration", columnList = "expiration_date"),
        Index(name = "idx_vuln_exception_asset", columnList = "asset_id")
    ]
)
@Serdeable
data class VulnerabilityException(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    var id: Long? = null,

    /**
     * Type of exception: IP, PRODUCT, or ASSET
     */
    @Enumerated(EnumType.STRING)
    @Column(name = "exception_type", nullable = false, length = 20)
    @NotNull
    var exceptionType: ExceptionType,

    /**
     * Target value for the exception:
     * - For IP: exact IP address (e.g., "192.168.1.10")
     * - For PRODUCT: product name/version pattern (e.g., "OpenSSH 7.4")
     * - For ASSET: not used (assetId field used instead)
     */
    @Column(name = "target_value", nullable = false, length = 512)
    @NotBlank
    @Size(max = 512)
    var targetValue: String,

    /**
     * Asset ID for ASSET-type exceptions (Feature 021)
     * - For IP/PRODUCT exceptions: null
     * - For ASSET exceptions: ID of the specific asset
     */
    @Column(name = "asset_id")
    var assetId: Long? = null,

    /**
     * Expiration date for the exception
     * Feature 021: All exceptions now require an end date
     * - null = legacy exception (from before Feature 021)
     * - non-null = exception expires after this date (required going forward)
     */
    @Column(name = "expiration_date")
    var expirationDate: LocalDateTime? = null,

    /**
     * Reason/justification for the exception
     */
    @Column(name = "reason", nullable = false, length = 1024)
    @NotBlank
    @Size(max = 1024)
    var reason: String,

    /**
     * User who created the exception
     */
    @Column(name = "created_by", nullable = false, length = 255)
    @NotBlank
    @Size(max = 255)
    var createdBy: String,

    @Column(name = "created_at", updatable = false)
    var createdAt: LocalDateTime? = null,

    @Column(name = "updated_at")
    var updatedAt: LocalDateTime? = null
) {
    enum class ExceptionType {
        IP,      // Exception applies to specific IP address
        PRODUCT, // Exception applies to product name/version pattern
        ASSET    // Exception applies to specific asset by ID (Feature 021)
    }

    @PrePersist
    fun onCreate() {
        val now = LocalDateTime.now()
        createdAt = now
        updatedAt = now
    }

    @PreUpdate
    fun onUpdate() {
        updatedAt = LocalDateTime.now()
    }

    /**
     * Check if this exception is currently active
     */
    fun isActive(): Boolean {
        return expirationDate == null || expirationDate!!.isAfter(LocalDateTime.now())
    }

    /**
     * Check if this exception matches the given vulnerability and asset
     *
     * Feature 021: Added ASSET type matching by asset ID
     */
    fun matches(vulnerability: Vulnerability, asset: Asset): Boolean {
        if (!isActive()) return false

        return when (exceptionType) {
            ExceptionType.IP -> asset.ip == targetValue
            ExceptionType.PRODUCT -> vulnerability.vulnerableProductVersions?.contains(targetValue) == true
            ExceptionType.ASSET -> assetId != null && assetId == asset.id
        }
    }

    override fun toString(): String {
        return "VulnerabilityException(id=$id, type=$exceptionType, target='$targetValue', " +
                "assetId=$assetId, expires=${expirationDate ?: "never"}, active=${isActive()})"
    }

    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other !is VulnerabilityException) return false
        return id != null && id == other.id
    }

    override fun hashCode(): Int {
        return id?.hashCode() ?: 0
    }
}
