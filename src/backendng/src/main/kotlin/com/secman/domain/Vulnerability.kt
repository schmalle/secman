package com.secman.domain

import com.fasterxml.jackson.annotation.JsonIgnore
import io.micronaut.serde.annotation.Serdeable
import jakarta.persistence.*
import jakarta.validation.constraints.NotNull
import java.time.LocalDateTime

/**
 * Vulnerability entity representing a security vulnerability discovered during a scan.
 *
 * Linked to an Asset entity via ManyToOne relationship.
 * Feature 048: Uses transactional replace pattern - each import deletes existing vulnerabilities
 * for an asset and inserts current ones, ensuring only the latest state is stored.
 *
 * Related to: Feature 003-i-want-to (Vulnerability Management System)
 * Related to: Feature 048-prevent-duplicate-vulnerabilities
 *
 * @property id Unique identifier
 * @property asset Asset this vulnerability affects (required)
 * @property vulnerabilityId CVE or vulnerability identifier (e.g., "CVE-2016-2183")
 * @property cvssSeverity CVSS severity level (e.g., "High", "Critical", "Medium", "Low", "Informational")
 * @property vulnerableProductVersions Affected product/version information
 * @property daysOpen Text representation of days open (e.g., "58 days") - display only
 * @property scanTimestamp Discovery date (calculated from daysOpen for accurate overdue calculation)
 * @property importTimestamp When this data was imported (same for all vulns in batch, for "current" query)
 * @property patchPublicationDate When the vendor published the patch/fix (optional, from CrowdStrike API)
 * @property createdAt When the record was first created in the database (auto-generated)
 */
@Entity
@Table(
    name = "vulnerability",
    indexes = [
        Index(name = "idx_vulnerability_asset", columnList = "asset_id"),
        Index(name = "idx_vulnerability_asset_scan", columnList = "asset_id,scan_timestamp"),
        Index(name = "idx_vulnerability_severity", columnList = "cvss_severity"),
        // Query optimization indexes (Feature: Database Structure Optimization)
        Index(name = "idx_vulnerability_cve", columnList = "vulnerability_id"),                    // CVE ID lookups
        Index(name = "idx_vulnerability_asset_cve", columnList = "asset_id,vulnerability_id"),     // Duplicate detection
        Index(name = "idx_vulnerability_product", columnList = "vulnerable_product_versions"),     // Product filtering
        Index(name = "idx_vulnerability_scan_timestamp", columnList = "scan_timestamp"),           // Temporal queries
        Index(name = "idx_vulnerability_import_ts", columnList = "asset_id,import_timestamp"),      // "Current" queries
        Index(name = "idx_vulnerability_sort_order", columnList = "import_timestamp DESC, vulnerability_id")  // ORDER BY optimization for paginated queries
    ]
)
@Serdeable
data class Vulnerability(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    var id: Long? = null,

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "asset_id", nullable = false)
    @JsonIgnore // Prevent lazy loading errors during JSON serialization
    @NotNull
    var asset: Asset,

    @Column(name = "vulnerability_id", length = 255)
    var vulnerabilityId: String? = null,

    @Column(name = "cvss_severity", length = 50)
    var cvssSeverity: String? = null,

    @Column(name = "vulnerable_product_versions", length = 512)
    var vulnerableProductVersions: String? = null,

    @Column(name = "days_open", length = 50)
    var daysOpen: String? = null,

    @Column(name = "scan_timestamp", nullable = false)
    @NotNull
    var scanTimestamp: LocalDateTime,

    @Column(name = "patch_publication_date")
    var patchPublicationDate: LocalDateTime? = null,

    @Column(name = "import_timestamp")
    var importTimestamp: LocalDateTime? = null,

    @Column(name = "created_at", updatable = false)
    var createdAt: LocalDateTime? = null
) {
    @PrePersist
    fun onCreate() {
        val now = LocalDateTime.now()
        createdAt = now
        // Default importTimestamp to createdAt if not explicitly set
        if (importTimestamp == null) {
            importTimestamp = now
        }
    }

    override fun toString(): String {
        return "Vulnerability(id=$id, vulnerabilityId='$vulnerabilityId', " +
                "cvssSeverity='$cvssSeverity', scanTimestamp=$scanTimestamp)"
    }

    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other !is Vulnerability) return false
        return id != null && id == other.id
    }

    override fun hashCode(): Int {
        return id?.hashCode() ?: 0
    }
}
