package com.secman.controller

import com.secman.domain.ExceptionRequestStatus
import com.secman.dto.*
import com.secman.exception.ConcurrentApprovalException
import com.secman.service.VulnerabilityExceptionRequestService
import com.secman.service.ExceptionRequestStatisticsService
import com.secman.service.ExceptionRequestExportService
import io.micronaut.core.annotation.Nullable
import io.micronaut.data.model.Page
import io.micronaut.data.model.Pageable
import io.micronaut.data.model.Sort
import io.micronaut.http.HttpRequest
import io.micronaut.http.HttpResponse
import io.micronaut.http.HttpStatus
import io.micronaut.http.annotation.*
import io.micronaut.scheduling.TaskExecutors
import io.micronaut.scheduling.annotation.ExecuteOn
import io.micronaut.security.annotation.Secured
import io.micronaut.security.authentication.Authentication
import io.micronaut.security.rules.SecurityRule
import io.micronaut.serde.annotation.Serdeable
import jakarta.validation.Valid
import org.slf4j.LoggerFactory

/**
 * REST API controller for vulnerability exception request workflow.
 *
 * Endpoints:
 * - POST /api/vulnerability-exception-requests - Create new request
 * - GET /api/vulnerability-exception-requests/my - Get user's own requests
 * - GET /api/vulnerability-exception-requests/my/summary - Get user's request statistics
 * - GET /api/vulnerability-exception-requests/{id} - Get request by ID
 * - POST /api/vulnerability-exception-requests/{id}/approve - Approve request (ADMIN/SECCHAMPION only)
 * - POST /api/vulnerability-exception-requests/{id}/reject - Reject request (ADMIN/SECCHAMPION only)
 * - DELETE /api/vulnerability-exception-requests/{id} - Cancel own pending request
 * - GET /api/vulnerability-exception-requests/pending - Get all pending requests (ADMIN/SECCHAMPION only)
 * - GET /api/vulnerability-exception-requests/pending/count - Get pending count for badge
 *
 * Concurrency Control: First-approver-wins using optimistic locking
 * Audit Logging: All state transitions logged asynchronously
 *
 * Feature: 031-vuln-exception-approval
 * Reference: contracts/exception-request-api.yaml, quickstart.md
 */
@Controller("/api/vulnerability-exception-requests")
@ExecuteOn(TaskExecutors.BLOCKING)
open class VulnerabilityExceptionRequestController(
    private val exceptionRequestService: VulnerabilityExceptionRequestService,
    private val statisticsService: ExceptionRequestStatisticsService,
    private val exportService: ExceptionRequestExportService
) {
    private val logger = LoggerFactory.getLogger(VulnerabilityExceptionRequestController::class.java)

    @Serdeable
    data class ErrorResponse(
        val error: String,
        val details: String? = null,
        val status: Int
    )

    @Serdeable
    data class PendingCountResponse(val count: Long)

    /**
     * TASK-016: Create a new exception request.
     *
     * POST /api/vulnerability-exception-requests
     * Auth: All authenticated users
     * Auto-approval: If user has ADMIN or SECCHAMPION role, status = APPROVED immediately
     *
     * @param dto Request creation data (vulnerabilityId, scope, reason, expirationDate)
     * @param authentication Current authenticated user
     * @param request HTTP request for IP address extraction
     * @return 201 Created with request DTO, 400 if validation fails, 409 if duplicate active request
     */
    @Post
    @Secured(SecurityRule.IS_AUTHENTICATED)
    open fun createRequest(
        @Valid @Body dto: CreateExceptionRequestDto,
        authentication: Authentication,
        request: HttpRequest<*>
    ): HttpResponse<*> {
        return try {
            val userId = getUserId(authentication)
            val clientIp = request.remoteAddress.address.hostAddress

            logger.debug(
                "Creating exception request: userId={}, vulnerabilityId={}, scope={}",
                userId, dto.vulnerabilityId, dto.scope
            )

            val createdRequest = exceptionRequestService.createRequest(dto, userId, clientIp)

            logger.info(
                "Exception request created: requestId={}, status={}, autoApproved={}",
                createdRequest.id, createdRequest.status, createdRequest.autoApproved
            )

            HttpResponse.created(createdRequest)

        } catch (e: IllegalArgumentException) {
            logger.warn("Invalid request: {}", e.message)
            HttpResponse.badRequest(ErrorResponse(
                error = e.message ?: "Invalid request",
                status = 400
            ))
        } catch (e: Exception) {
            logger.error("Failed to create exception request", e)
            HttpResponse.serverError<ErrorResponse>()
        }
    }

    /**
     * TASK-017: Get user's own exception requests with optional filtering and pagination.
     *
     * GET /api/vulnerability-exception-requests/my?status=PENDING&page=0&size=20
     * Auth: All authenticated users
     *
     * @param authentication Current authenticated user
     * @param status Optional status filter (PENDING, APPROVED, REJECTED, EXPIRED, CANCELLED)
     * @param page Page number (0-indexed, default: 0)
     * @param size Page size (default: 20, options: 20/50/100)
     * @return 200 OK with paginated requests
     */
    @Get("/my")
    @Secured(SecurityRule.IS_AUTHENTICATED)
    open fun getUserRequests(
        authentication: Authentication,
        @Nullable @QueryValue status: ExceptionRequestStatus?,
        @Nullable @QueryValue page: Int?,
        @Nullable @QueryValue size: Int?
    ): HttpResponse<Page<VulnerabilityExceptionRequestDto>> {
        return try {
            val userId = getUserId(authentication)
            val pageNumber = maxOf(page ?: 0, 0)
            val pageSize = when (size) {
                20, 50, 100 -> size
                else -> 20 // Default to 20
            }

            logger.debug(
                "Getting user requests: userId={}, status={}, page={}, size={}",
                userId, status, pageNumber, pageSize
            )

            val pageable = Pageable.from(pageNumber, pageSize, Sort.of(Sort.Order.desc("createdAt")))
            val requests = exceptionRequestService.getUserRequests(userId, status, pageable)

            HttpResponse.ok(requests)

        } catch (e: Exception) {
            logger.error("Failed to get user requests", e)
            HttpResponse.serverError<Page<VulnerabilityExceptionRequestDto>>()
        }
    }

    /**
     * TASK-018: Get summary statistics for user's exception requests.
     *
     * GET /api/vulnerability-exception-requests/my/summary
     * Auth: All authenticated users
     *
     * @param authentication Current authenticated user
     * @return 200 OK with summary statistics (total, approved, pending, rejected, expired, cancelled)
     */
    @Get("/my/summary")
    @Secured(SecurityRule.IS_AUTHENTICATED)
    open fun getUserRequestSummary(
        authentication: Authentication
    ): HttpResponse<ExceptionRequestSummaryDto> {
        return try {
            val userId = getUserId(authentication)

            logger.debug("Getting user request summary: userId={}", userId)

            val summary = exceptionRequestService.getUserRequestSummary(userId)

            HttpResponse.ok(summary)

        } catch (e: Exception) {
            logger.error("Failed to get user request summary", e)
            HttpResponse.serverError<ExceptionRequestSummaryDto>()
        }
    }

    /**
     * TASK-019: Get exception request by ID.
     *
     * GET /api/vulnerability-exception-requests/{id}
     * Auth: All authenticated users
     * Access control: Users can only view own requests, ADMIN/SECCHAMPION can view all
     *
     * @param id Request ID
     * @param authentication Current authenticated user
     * @return 200 OK with request DTO, 403 if not owner (unless ADMIN/SECCHAMPION), 404 if not found
     */
    @Get("/{id}")
    @Secured(SecurityRule.IS_AUTHENTICATED)
    open fun getRequestById(
        @PathVariable id: Long,
        authentication: Authentication
    ): HttpResponse<*> {
        return try {
            val userId = getUserId(authentication)
            val request = exceptionRequestService.getRequestById(id)

            // Access control: User must own request OR have ADMIN/SECCHAMPION role
            val isOwner = request.requestedByUsername == authentication.name
            val isAdminOrSecChampion = hasRole(authentication, "ADMIN") || hasRole(authentication, "SECCHAMPION")

            if (!isOwner && !isAdminOrSecChampion) {
                logger.warn("Access denied: userId={} attempted to view request {}", userId, id)
                return HttpResponse.status<ErrorResponse>(HttpStatus.FORBIDDEN).body(
                    ErrorResponse(
                        error = "Access denied",
                        details = "You can only view your own requests",
                        status = 403
                    )
                )
            }

            HttpResponse.ok(request)

        } catch (e: IllegalArgumentException) {
            logger.warn("Request not found: id={}", id)
            HttpResponse.notFound<VulnerabilityExceptionRequestDto>()
        } catch (e: Exception) {
            logger.error("Failed to get request by ID: id={}", id, e)
            HttpResponse.serverError<VulnerabilityExceptionRequestDto>()
        }
    }

    /**
     * TASK-020: Approve a pending exception request.
     *
     * POST /api/vulnerability-exception-requests/{id}/approve
     * Auth: ADMIN or SECCHAMPION only
     * Concurrency: First-approver-wins (optimistic locking)
     *
     * @param id Request ID
     * @param reviewDto Optional review comment
     * @param authentication Current authenticated user (reviewer)
     * @param request HTTP request for IP address extraction
     * @return 200 OK with updated request, 404 if not found, 409 if concurrent approval
     */
    @Post("/{id}/approve")
    @Secured("ADMIN", "SECCHAMPION")
    open fun approveRequest(
        @PathVariable id: Long,
        @Nullable @Body reviewDto: ReviewExceptionRequestDto?,
        authentication: Authentication,
        request: HttpRequest<*>
    ): HttpResponse<*> {
        return try {
            val reviewerId = getUserId(authentication)
            val clientIp = request.remoteAddress.address.hostAddress

            logger.debug("Approving request: requestId={}, reviewerId={}", id, reviewerId)

            val approvedRequest = exceptionRequestService.approveRequest(
                requestId = id,
                reviewerUserId = reviewerId,
                reviewDto = reviewDto,
                clientIp = clientIp
            )

            logger.info("Request approved: requestId={}, reviewerId={}", id, reviewerId)

            HttpResponse.ok(approvedRequest)

        } catch (e: ConcurrentApprovalException) {
            // TASK-025: Handle concurrent approval conflicts
            logger.warn("Concurrent approval conflict: requestId={}, {}", id, e.getDetailedMessage())
            HttpResponse.status<ErrorResponse>(HttpStatus.CONFLICT).body(
                ErrorResponse(
                    error = e.getUserMessage(),
                    details = e.getDetailedMessage(),
                    status = 409
                )
            )
        } catch (e: IllegalArgumentException) {
            logger.warn("Invalid approval request: requestId={}, error={}", id, e.message)
            HttpResponse.notFound<VulnerabilityExceptionRequestDto>()
        } catch (e: IllegalStateException) {
            // TASK-026: Handle invalid status transitions
            logger.warn("Invalid status transition: requestId={}, error={}", id, e.message)
            HttpResponse.badRequest(ErrorResponse(
                error = "Invalid status transition",
                details = e.message,
                status = 400
            ))
        } catch (e: Exception) {
            logger.error("Failed to approve request: requestId={}", id, e)
            HttpResponse.serverError<VulnerabilityExceptionRequestDto>()
        }
    }

    /**
     * TASK-021: Reject a pending exception request.
     *
     * POST /api/vulnerability-exception-requests/{id}/reject
     * Auth: ADMIN or SECCHAMPION only
     * Required: Review comment (minimum 10 characters)
     *
     * @param id Request ID
     * @param reviewDto Review comment (required, 10-1024 characters)
     * @param authentication Current authenticated user (reviewer)
     * @param request HTTP request for IP address extraction
     * @return 200 OK with updated request, 400 if comment missing, 404 if not found, 409 if concurrent rejection
     */
    @Post("/{id}/reject")
    @Secured("ADMIN", "SECCHAMPION")
    open fun rejectRequest(
        @PathVariable id: Long,
        @Valid @Body reviewDto: ReviewExceptionRequestDto,
        authentication: Authentication,
        request: HttpRequest<*>
    ): HttpResponse<*> {
        return try {
            val reviewerId = getUserId(authentication)
            val clientIp = request.remoteAddress.address.hostAddress

            logger.debug("Rejecting request: requestId={}, reviewerId={}", id, reviewerId)

            val rejectedRequest = exceptionRequestService.rejectRequest(
                requestId = id,
                reviewerUserId = reviewerId,
                reviewDto = reviewDto,
                clientIp = clientIp
            )

            logger.info("Request rejected: requestId={}, reviewerId={}", id, reviewerId)

            HttpResponse.ok(rejectedRequest)

        } catch (e: ConcurrentApprovalException) {
            // TASK-025: Handle concurrent review conflicts
            logger.warn("Concurrent rejection conflict: requestId={}, {}", id, e.getDetailedMessage())
            HttpResponse.status<ErrorResponse>(HttpStatus.CONFLICT).body(
                ErrorResponse(
                    error = e.getUserMessage(),
                    details = e.getDetailedMessage(),
                    status = 409
                )
            )
        } catch (e: IllegalArgumentException) {
            logger.warn("Invalid rejection request: requestId={}, error={}", id, e.message)
            HttpResponse.badRequest(ErrorResponse(
                error = "Validation failed",
                details = e.message,
                status = 400
            ))
        } catch (e: IllegalStateException) {
            // TASK-026: Handle invalid status transitions
            logger.warn("Invalid status transition: requestId={}, error={}", id, e.message)
            HttpResponse.badRequest(ErrorResponse(
                error = "Invalid status transition",
                details = e.message,
                status = 400
            ))
        } catch (e: Exception) {
            logger.error("Failed to reject request: requestId={}", id, e)
            HttpResponse.serverError<VulnerabilityExceptionRequestDto>()
        }
    }

    /**
     * TASK-022: Cancel own pending exception request.
     *
     * DELETE /api/vulnerability-exception-requests/{id}
     * Auth: All authenticated users
     * Access control: Only requester can cancel, only PENDING status can be cancelled
     *
     * @param id Request ID
     * @param authentication Current authenticated user
     * @param request HTTP request for IP address extraction
     * @return 204 No Content, 403 if not owner, 400 if not PENDING, 404 if not found
     */
    @Delete("/{id}")
    @Secured(SecurityRule.IS_AUTHENTICATED)
    @Status(HttpStatus.NO_CONTENT)
    open fun cancelRequest(
        @PathVariable id: Long,
        authentication: Authentication,
        request: HttpRequest<*>
    ): HttpResponse<*> {
        return try {
            val userId = getUserId(authentication)
            val clientIp = request.remoteAddress.address.hostAddress

            logger.debug("Cancelling request: requestId={}, userId={}", id, userId)

            exceptionRequestService.cancelRequest(
                requestId = id,
                requesterUserId = userId,
                clientIp = clientIp
            )

            logger.info("Request cancelled: requestId={}, userId={}", id, userId)

            HttpResponse.noContent<Void>()

        } catch (e: IllegalArgumentException) {
            logger.warn("Cannot cancel request: requestId={}, userId={}, error={}", id, getUserId(authentication), e.message)
            if (e.message?.contains("original requester") == true) {
                HttpResponse.status<ErrorResponse>(HttpStatus.FORBIDDEN).body(
                    ErrorResponse(
                        error = "Access denied",
                        details = "Only the original requester can cancel this request",
                        status = 403
                    )
                )
            } else {
                HttpResponse.notFound<ErrorResponse>()
            }
        } catch (e: IllegalStateException) {
            // TASK-026: Handle invalid status transitions
            logger.warn("Invalid cancellation: requestId={}, error={}", id, e.message)
            HttpResponse.badRequest(ErrorResponse(
                error = "Cannot cancel this request",
                details = e.message,
                status = 400
            ))
        } catch (e: Exception) {
            logger.error("Failed to cancel request: requestId={}", id, e)
            HttpResponse.serverError<ErrorResponse>()
        }
    }

    /**
     * TASK-023: Get all pending exception requests (for approval dashboard).
     *
     * GET /api/vulnerability-exception-requests/pending?page=0&size=20
     * Auth: ADMIN or SECCHAMPION only
     * Sorted by: created_at ASC (oldest first)
     *
     * @param authentication Current authenticated user
     * @param page Page number (0-indexed, default: 0)
     * @param size Page size (default: 20, options: 20/50/100)
     * @return 200 OK with paginated pending requests
     */
    @Get("/pending")
    @Secured("ADMIN", "SECCHAMPION")
    open fun getPendingRequests(
        authentication: Authentication,
        @Nullable @QueryValue page: Int?,
        @Nullable @QueryValue size: Int?
    ): HttpResponse<Page<VulnerabilityExceptionRequestDto>> {
        return try {
            val pageNumber = maxOf(page ?: 0, 0)
            val pageSize = when (size) {
                20, 50, 100 -> size
                else -> 20 // Default to 20
            }

            logger.debug("Getting pending requests: page={}, size={}", pageNumber, pageSize)

            // Sort by created_at ASC (oldest first) per FR-020
            val pageable = Pageable.from(pageNumber, pageSize, Sort.of(Sort.Order.asc("createdAt")))
            val pendingRequests = exceptionRequestService.getPendingRequests(pageable)

            logger.info("Returning {} pending requests (page {}, total {})",
                pendingRequests.content.size, pageNumber, pendingRequests.totalSize)

            HttpResponse.ok(pendingRequests)

        } catch (e: Exception) {
            logger.error("Failed to get pending requests", e)
            HttpResponse.serverError<Page<VulnerabilityExceptionRequestDto>>()
        }
    }

    /**
     * TASK-024: Get count of pending exception requests (for badge display).
     *
     * GET /api/vulnerability-exception-requests/pending/count
     * Auth: ADMIN or SECCHAMPION only
     * Used for: Real-time badge updates (SSE will call this periodically)
     *
     * @param authentication Current authenticated user
     * @return 200 OK with { "count": number }
     */
    @Get("/pending/count")
    @Secured("ADMIN", "SECCHAMPION")
    open fun getPendingCount(
        authentication: Authentication
    ): HttpResponse<PendingCountResponse> {
        return try {
            val count = exceptionRequestService.getPendingCount()

            logger.debug("Pending count requested: count={}", count)

            HttpResponse.ok(PendingCountResponse(count = count))

        } catch (e: Exception) {
            logger.error("Failed to get pending count", e)
            HttpResponse.serverError<PendingCountResponse>()
        }
    }

    /**
     * GET /api/vulnerability-exception-requests/statistics
     *
     * Get statistical metrics for exception requests.
     *
     * **Access Control**: ADMIN and SECCHAMPION roles only
     *
     * **Query Parameters**:
     * - dateRange: Optional (7days, 30days, 90days, alltime), default 30days
     *
     * **Response**: 200 OK with ExceptionStatisticsDto containing:
     * - totalRequests: Total count in date range
     * - approvalRatePercent: Approval percentage (null if no reviewed requests)
     * - averageApprovalTimeHours: Median approval time in hours (null if no approved requests)
     * - requestsByStatus: Map of status → count
     * - topRequesters: Top 10 requesters with counts
     * - topCVEs: Top 10 CVEs with counts
     *
     * Feature: 031-vuln-exception-approval
     * User Story 8: Analytics & Reporting (P3)
     * Phase 11: Analytics & Reporting
     * Reference: spec.md acceptance scenario US8-1
     */
    @Get("/statistics")
    @Secured("ADMIN", "SECCHAMPION")
    open fun getStatistics(
        authentication: Authentication,
        @QueryValue @Nullable dateRange: String?
    ): HttpResponse<ExceptionStatisticsDto> {
        return try {
            val effectiveDateRange = dateRange ?: "30days"

            logger.info("Statistics requested: dateRange={}, user={}", effectiveDateRange, authentication.name)

            // Get metrics from statistics service
            val approvalRate = statisticsService.getApprovalRate(effectiveDateRange)
            val averageApprovalTime = statisticsService.getAverageApprovalTime(effectiveDateRange)
            val requestsByStatus = statisticsService.getRequestsByStatus(effectiveDateRange)
            val topRequesters = statisticsService.getTopRequesters(10, effectiveDateRange)
            val topCVEs = statisticsService.getTopCVEs(10, effectiveDateRange)

            // Calculate total requests
            val totalRequests = requestsByStatus.values.sum()

            // Convert status map to string keys for JSON serialization
            val statusMap = requestsByStatus.mapKeys { it.key.name }

            // Convert to DTOs
            val topRequesterDtos = topRequesters.map { (username, count) ->
                TopRequesterDto(username, count)
            }
            val topCVEDtos = topCVEs.map { (cveId, count) ->
                TopCVEDto(cveId, count)
            }

            val statistics = ExceptionStatisticsDto(
                totalRequests = totalRequests,
                approvalRatePercent = approvalRate,
                averageApprovalTimeHours = averageApprovalTime,
                requestsByStatus = statusMap,
                topRequesters = topRequesterDtos,
                topCVEs = topCVEDtos
            )

            logger.debug("Statistics computed: totalRequests={}, approvalRate={}, avgTime={}h",
                totalRequests, approvalRate, averageApprovalTime)

            HttpResponse.ok(statistics)

        } catch (e: Exception) {
            logger.error("Failed to get statistics: dateRange={}", dateRange, e)
            HttpResponse.serverError<ExceptionStatisticsDto>()
        }
    }

    /**
     * GET /api/vulnerability-exception-requests/export
     *
     * Export exception requests to Excel with optional filtering.
     *
     * **Access Control**: ADMIN and SECCHAMPION roles only
     *
     * **Query Parameters**:
     * - status: Optional status filter (PENDING, APPROVED, REJECTED, EXPIRED, CANCELLED)
     * - dateRange: Optional (7days, 30days, 90days, alltime)
     * - requesterId: Optional requester user ID filter
     * - reviewerId: Optional reviewer user ID filter
     *
     * **Response**: 200 OK with Excel file
     * - Content-Type: application/vnd.openxmlformats-officedocument.spreadsheetml.sheet
     * - Filename: exception-requests-{timestamp}.xlsx
     * - Columns: Request ID, CVE ID, Asset Name, Asset IP, Requester, Submission Date,
     *   Status, Reviewer, Review Date, Reason, Review Comment, Expiration Date, Auto-Approved
     *
     * Feature: 031-vuln-exception-approval
     * User Story 8: Analytics & Reporting (P3)
     * Phase 11: Analytics & Reporting
     * Reference: spec.md FR-026, acceptance scenario US8-3
     */
    @Get("/export")
    @Secured("ADMIN", "SECCHAMPION")
    @Produces("application/vnd.openxmlformats-officedocument.spreadsheetml.sheet")
    open fun exportToExcel(
        authentication: Authentication,
        @QueryValue @Nullable status: String?,
        @QueryValue @Nullable dateRange: String?,
        @QueryValue @Nullable requesterId: Long?,
        @QueryValue @Nullable reviewerId: Long?
    ): HttpResponse<ByteArray> {
        return try {
            logger.info("Excel export requested: status={}, dateRange={}, requesterId={}, reviewerId={}, user={}",
                status, dateRange, requesterId, reviewerId, authentication.name)

            // Parse status if provided
            val statusEnum = status?.let {
                try {
                    ExceptionRequestStatus.valueOf(it.uppercase())
                } catch (e: IllegalArgumentException) {
                    logger.warn("Invalid status parameter: {}", it)
                    null
                }
            }

            // Generate Excel export
            val excelData = exportService.exportToExcel(
                status = statusEnum,
                dateRange = dateRange,
                requesterId = requesterId,
                reviewerId = reviewerId
            )

            // Generate filename with timestamp
            val timestamp = java.time.LocalDateTime.now().format(
                java.time.format.DateTimeFormatter.ofPattern("yyyyMMdd-HHmmss")
            )
            val filename = "exception-requests-$timestamp.xlsx"

            logger.info("Excel export completed: filename={}, size={} bytes", filename, excelData.size())

            HttpResponse.ok(excelData.toByteArray())
                .header("Content-Disposition", "attachment; filename=\"$filename\"")

        } catch (e: Exception) {
            logger.error("Failed to export Excel: status={}, dateRange={}", status, dateRange, e)
            HttpResponse.serverError<ByteArray>()
        }
    }

    /**
     * Extract user ID from authentication object.
     *
     * @param authentication Current authenticated user
     * @return User ID as Long
     * @throws IllegalStateException if user ID not found in attributes
     */
    private fun getUserId(authentication: Authentication): Long {
        return authentication.attributes["userId"]?.toString()?.toLong()
            ?: throw IllegalStateException("User ID not found in authentication context")
    }

    /**
     * Check if authentication has a specific role.
     *
     * @param authentication Current authenticated user
     * @param role Role name to check
     * @return True if user has the role
     */
    private fun hasRole(authentication: Authentication, role: String): Boolean {
        return authentication.roles.contains(role)
    }
}
