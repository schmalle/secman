package com.secman.controller

import com.secman.domain.VulnerabilityException.ExceptionType
import com.secman.dto.CreateVulnerabilityExceptionRequest
import com.secman.dto.UpdateVulnerabilityExceptionRequest
import com.secman.dto.VulnerabilityExceptionDto
import com.secman.dto.VulnerabilityWithExceptionDto
import com.secman.service.VulnerabilityExceptionService
import com.secman.service.VulnerabilityService
import io.micronaut.core.annotation.Nullable
import io.micronaut.http.HttpResponse
import io.micronaut.http.HttpStatus
import io.micronaut.http.annotation.*
import io.micronaut.scheduling.TaskExecutors
import io.micronaut.scheduling.annotation.ExecuteOn
import io.micronaut.security.annotation.Secured
import io.micronaut.security.authentication.Authentication
import io.micronaut.serde.annotation.Serdeable
import jakarta.validation.Valid
import org.slf4j.LoggerFactory

/**
 * Controller for vulnerability management and exception operations
 *
 * Endpoints:
 * - GET /api/vulnerabilities/current - List current vulnerabilities with filters
 * - GET /api/vulnerability-exceptions - List vulnerability exceptions
 * - POST /api/vulnerability-exceptions - Create new exception
 * - PUT /api/vulnerability-exceptions/{id} - Update exception
 * - DELETE /api/vulnerability-exceptions/{id} - Delete exception
 *
 * Access: ADMIN and VULN roles only
 *
 * Related to: Feature 004-i-want-to (VULN Role & Vulnerability Management UI)
 */
@Controller
@Secured("ADMIN", "VULN")
@ExecuteOn(TaskExecutors.BLOCKING)
open class VulnerabilityManagementController(
    private val vulnerabilityService: VulnerabilityService,
    private val vulnerabilityExceptionService: VulnerabilityExceptionService
) {
    private val log = LoggerFactory.getLogger(VulnerabilityManagementController::class.java)

    @Serdeable
    data class ErrorResponse(val error: String)

    /**
     * Get current vulnerabilities (latest scan per asset) with exception status
     *
     * GET /api/vulnerabilities/current?severity=Critical&system=server&exceptionStatus=not_excepted
     * Auth: ADMIN or VULN role
     * Response: List<VulnerabilityWithExceptionDto>
     *
     * Query Parameters:
     * - severity: Optional CVSS severity filter (e.g., "Critical", "High", "Medium", "Low")
     * - system: Optional system/asset name filter (substring match, case-insensitive)
     * - exceptionStatus: Optional filter - "excepted", "not_excepted", or omit for all
     */
    @Get("/api/vulnerabilities/current")
    open fun getCurrentVulnerabilities(
        @Nullable @QueryValue severity: String?,
        @Nullable @QueryValue system: String?,
        @Nullable @QueryValue exceptionStatus: String?
    ): HttpResponse<List<VulnerabilityWithExceptionDto>> {
        return try {
            log.debug("Getting current vulnerabilities - severity: {}, system: {}, exceptionStatus: {}",
                severity, system, exceptionStatus)

            val vulnerabilities = vulnerabilityService.getCurrentVulnerabilities(
                severity = severity,
                system = system,
                exceptionStatus = exceptionStatus
            )

            log.info("Returning {} current vulnerabilities", vulnerabilities.size)
            HttpResponse.ok(vulnerabilities)

        } catch (e: Exception) {
            log.error("Error fetching current vulnerabilities", e)
            HttpResponse.serverError()
        }
    }

    /**
     * Get all vulnerability exceptions
     *
     * GET /api/vulnerability-exceptions?activeOnly=true&type=IP
     * Auth: ADMIN or VULN role
     * Response: List<VulnerabilityExceptionDto>
     *
     * Query Parameters:
     * - activeOnly: If true, only return non-expired exceptions (default: false)
     * - type: Optional filter by exception type (IP or PRODUCT)
     */
    @Get("/api/vulnerability-exceptions")
    open fun getAllExceptions(
        @Nullable @QueryValue activeOnly: Boolean?,
        @Nullable @QueryValue type: ExceptionType?
    ): HttpResponse<List<VulnerabilityExceptionDto>> {
        return try {
            log.debug("Getting exceptions - activeOnly: {}, type: {}", activeOnly, type)

            val exceptions = vulnerabilityExceptionService.getAllExceptions(
                activeOnly = activeOnly ?: false,
                type = type
            )

            log.info("Returning {} exceptions", exceptions.size)
            HttpResponse.ok(exceptions)

        } catch (e: Exception) {
            log.error("Error fetching vulnerability exceptions", e)
            HttpResponse.serverError()
        }
    }

    /**
     * Create a new vulnerability exception
     *
     * POST /api/vulnerability-exceptions
     * Auth: ADMIN or VULN role
     * Request: CreateVulnerabilityExceptionRequest
     * Response: VulnerabilityExceptionDto (201 Created)
     */
    @Post("/api/vulnerability-exceptions")
    open fun createException(
        @Valid @Body request: CreateVulnerabilityExceptionRequest,
        authentication: Authentication
    ): HttpResponse<*> {
        return try {
            val username = authentication.name
            log.info("Creating exception - type: {}, target: {}, by: {}",
                request.exceptionType, request.targetValue, username)

            val created = vulnerabilityExceptionService.createException(request, username)

            log.info("Created exception with id: {}", created.id)
            HttpResponse.status<VulnerabilityExceptionDto>(HttpStatus.CREATED).body(created)

        } catch (e: IllegalArgumentException) {
            log.warn("Invalid exception creation request: {}", e.message)
            HttpResponse.badRequest(ErrorResponse(e.message ?: "Invalid request"))
        } catch (e: Exception) {
            log.error("Error creating vulnerability exception", e)
            HttpResponse.serverError<ErrorResponse>().body(ErrorResponse("Error creating exception: ${e.message}"))
        }
    }

    /**
     * Update an existing vulnerability exception
     *
     * PUT /api/vulnerability-exceptions/{id}
     * Auth: ADMIN or VULN role
     * Request: UpdateVulnerabilityExceptionRequest
     * Response: VulnerabilityExceptionDto (200 OK)
     */
    @Put("/api/vulnerability-exceptions/{id}")
    open fun updateException(
        id: Long,
        @Valid @Body request: UpdateVulnerabilityExceptionRequest
    ): HttpResponse<*> {
        return try {
            log.info("Updating exception id: {}", id)

            val updated = vulnerabilityExceptionService.updateException(id, request)

            log.info("Updated exception id: {}", id)
            HttpResponse.ok(updated)

        } catch (e: IllegalArgumentException) {
            log.warn("Exception not found or invalid update request: {}", e.message)
            HttpResponse.notFound(ErrorResponse(e.message ?: "Exception not found"))
        } catch (e: Exception) {
            log.error("Error updating vulnerability exception id: {}", id, e)
            HttpResponse.serverError<ErrorResponse>().body(ErrorResponse("Error updating exception: ${e.message}"))
        }
    }

    /**
     * Delete a vulnerability exception
     *
     * DELETE /api/vulnerability-exceptions/{id}
     * Auth: ADMIN or VULN role
     * Response: 204 NO CONTENT on success
     */
    @Delete("/api/vulnerability-exceptions/{id}")
    open fun deleteException(id: Long): HttpResponse<*> {
        return try {
            log.info("Deleting exception id: {}", id)

            vulnerabilityExceptionService.deleteException(id)

            log.info("Deleted exception id: {}", id)
            HttpResponse.noContent<Any>()

        } catch (e: IllegalArgumentException) {
            log.warn("Exception not found for deletion: {}", e.message)
            HttpResponse.notFound(ErrorResponse(e.message ?: "Exception not found"))
        } catch (e: Exception) {
            log.error("Error deleting vulnerability exception id: {}", id, e)
            HttpResponse.serverError<ErrorResponse>().body(ErrorResponse("Error deleting exception: ${e.message}"))
        }
    }
}
