package com.secman.controller

import com.secman.domain.VulnerabilityException.ExceptionType
import com.secman.dto.AddVulnerabilityRequestDto
import com.secman.dto.AddVulnerabilityResponseDto
import com.secman.dto.CreateVulnerabilityExceptionRequest
import com.secman.dto.UpdateVulnerabilityExceptionRequest
import com.secman.dto.VulnerabilityExceptionDto
import com.secman.dto.VulnerabilityWithExceptionDto
import com.secman.dto.PaginatedVulnerabilitiesResponse
import com.secman.service.AssetFilterService
import com.secman.service.VulnerabilityExceptionService
import com.secman.service.VulnerabilityService
import io.micronaut.core.annotation.Nullable
import io.micronaut.http.HttpResponse
import io.micronaut.http.HttpStatus
import io.micronaut.http.annotation.*
import io.micronaut.scheduling.TaskExecutors
import io.micronaut.scheduling.annotation.ExecuteOn
import io.micronaut.security.annotation.Secured
import io.micronaut.security.authentication.Authentication
import io.micronaut.security.rules.SecurityRule
import io.micronaut.serde.annotation.Serdeable
import jakarta.validation.Valid
import org.slf4j.LoggerFactory
import kotlin.math.ceil

/**
 * Controller for vulnerability management and exception operations
 *
 * Endpoints:
 * - GET /api/vulnerabilities/current - List current vulnerabilities with filters
 * - GET /api/vulnerability-exceptions - List vulnerability exceptions
 * - POST /api/vulnerability-exceptions - Create new exception
 * - PUT /api/vulnerability-exceptions/{id} - Update exception
 * - DELETE /api/vulnerability-exceptions/{id} - Delete exception
 *
 * Access: ADMIN, VULN, and SECCHAMPION roles only
 * Feature: 025-role-based-access-control
 *
 * Related to: Feature 004-i-want-to (VULN Role & Vulnerability Management UI)
 */
@Controller
@Secured("ADMIN", "VULN", "SECCHAMPION")
@ExecuteOn(TaskExecutors.BLOCKING)
open class VulnerabilityManagementController(
    private val vulnerabilityService: VulnerabilityService,
    private val vulnerabilityExceptionService: VulnerabilityExceptionService,
    private val assetFilterService: AssetFilterService,
    private val vulnerabilityTimestampMigrationService: com.secman.service.VulnerabilityTimestampMigrationService
) {
    private val log = LoggerFactory.getLogger(VulnerabilityManagementController::class.java)

    @Serdeable
    data class ErrorResponse(val error: String)

    /**
     * Get current vulnerabilities (latest scan per asset) with exception status
     * Feature: 008-create-an-additional (Workgroup-Based Access Control)
     *
     * GET /api/vulnerabilities/current?severity=Critical&system=server&exceptionStatus=not_excepted&product=zlib&adDomain=CONTOSO&cloudAccountId=123456789012&page=0&size=50
     * Auth: ADMIN or VULN role
     * Response: PaginatedVulnerabilitiesResponse
     *
     * FR-014, FR-016, FR-018: ADMIN sees all, VULN role respects workgroup restrictions
     *
     * Query Parameters:
     * - severity: Optional CVSS severity filter (e.g., "Critical", "High", "Medium", "Low")
     * - system: Optional system/asset name filter (substring match, case-insensitive)
     * - exceptionStatus: Optional filter - "excepted", "not_excepted", or omit for all
     * - product: Optional product/version filter (substring match, case-insensitive)
     * - adDomain: Optional AD domain filter (substring match, case-insensitive)
     * - cloudAccountId: Optional AWS cloud account ID filter (substring match, case-insensitive)
     * - page: Page number (0-indexed, default: 0)
     * - size: Page size (default: 50, max: 500)
     * - sort: Sort field (e.g., "assetName", "cvssSeverity", "scanTimestamp", "vulnerabilityId", "vulnerableProductVersions", "daysOpen")
     * - sortDir: Sort direction ("asc" or "desc", default: "desc")
     */
    @Get("/api/vulnerabilities/current")
    @Secured("ADMIN", "SECCHAMPION")  // Restricted to ADMIN and SECCHAMPION only
    open fun getCurrentVulnerabilities(
        authentication: Authentication,
        @Nullable @QueryValue severity: String?,
        @Nullable @QueryValue system: String?,
        @Nullable @QueryValue exceptionStatus: String?,
        @Nullable @QueryValue product: String?,
        @Nullable @QueryValue adDomain: String?,
        @Nullable @QueryValue cloudAccountId: String?,
        @Nullable @QueryValue page: Int?,
        @Nullable @QueryValue size: Int?,
        @Nullable @QueryValue sort: String?,
        @Nullable @QueryValue sortDir: String?
    ): HttpResponse<PaginatedVulnerabilitiesResponse> {
        return try {
            // Validate and sanitize pagination parameters
            val pageNumber = maxOf(page ?: 0, 0)
            val pageSize = minOf(maxOf(size ?: 50, 1), 500)

            log.debug("Getting current vulnerabilities for user: {} - severity: {}, system: {}, exceptionStatus: {}, product: {}, adDomain: {}, cloudAccountId: {}, page: {}, size: {}",
                authentication.name, severity, system, exceptionStatus, product, adDomain, cloudAccountId, pageNumber, pageSize)

            // Check if user is ADMIN (universal access)
            val isAdmin = authentication.roles.contains("ADMIN")

            // Get accessible asset IDs (only needed for non-ADMIN users)
            // PERFORMANCE: For ADMIN users, we skip this query entirely
            val accessibleAssetIds = if (isAdmin) {
                emptySet()  // Not used for ADMIN
            } else {
                assetFilterService.getAccessibleAssets(authentication)
                    .mapNotNull { it.id }
                    .toSet()
            }

            // PERFORMANCE OPTIMIZED: Use database-level pagination and access control
            // This replaces the old pattern of loading all data and filtering in-memory
            val response = vulnerabilityService.getCurrentVulnerabilitiesOptimized(
                accessibleAssetIds = accessibleAssetIds,
                isAdmin = isAdmin,
                severity = severity,
                system = system,
                exceptionStatus = exceptionStatus,
                product = product,
                adDomain = adDomain,
                cloudAccountId = cloudAccountId,
                page = pageNumber,
                size = pageSize,
                sort = sort,
                sortDir = sortDir
            )

            log.info("Returning {} current vulnerabilities for user {} (page {}/{}, total {})",
                response.content.size, authentication.name, response.currentPage + 1, response.totalPages, response.totalElements)
            HttpResponse.ok(response)

        } catch (e: Exception) {
            log.error("Error fetching current vulnerabilities for user: {}", authentication.name, e)
            HttpResponse.serverError()
        }
    }

    /**
     * Get all vulnerability exceptions
     *
     * GET /api/vulnerability-exceptions?activeOnly=true&type=IP
     * Auth: ADMIN or VULN role
     * Response: List<VulnerabilityExceptionDto>
     *
     * Query Parameters:
     * - activeOnly: If true, only return non-expired exceptions (default: false)
     * - type: Optional filter by exception type (IP or PRODUCT)
     */
    @Get("/api/vulnerability-exceptions")
    open fun getAllExceptions(
        @Nullable @QueryValue activeOnly: Boolean?,
        @Nullable @QueryValue type: ExceptionType?
    ): HttpResponse<List<VulnerabilityExceptionDto>> {
        return try {
            log.debug("Getting exceptions - activeOnly: {}, type: {}", activeOnly, type)

            val exceptions = vulnerabilityExceptionService.getAllExceptions(
                activeOnly = activeOnly ?: false,
                type = type
            )

            log.info("Returning {} exceptions", exceptions.size)
            HttpResponse.ok(exceptions)

        } catch (e: Exception) {
            log.error("Error fetching vulnerability exceptions", e)
            HttpResponse.serverError()
        }
    }

    /**
     * Create a new vulnerability exception
     *
     * POST /api/vulnerability-exceptions
     * Auth: ADMIN or VULN role
     * Request: CreateVulnerabilityExceptionRequest
     * Response: VulnerabilityExceptionDto (201 Created)
     */
    @Post("/api/vulnerability-exceptions")
    open fun createException(
        @Valid @Body request: CreateVulnerabilityExceptionRequest,
        authentication: Authentication
    ): HttpResponse<*> {
        return try {
            val username = authentication.name
            log.info("Creating exception - type: {}, target: {}, by: {}",
                request.exceptionType, request.targetValue, username)

            val created = vulnerabilityExceptionService.createException(request, username)

            log.info("Created exception with id: {}", created.id)
            HttpResponse.status<VulnerabilityExceptionDto>(HttpStatus.CREATED).body(created)

        } catch (e: IllegalArgumentException) {
            log.warn("Invalid exception creation request: {}", e.message)
            HttpResponse.badRequest(ErrorResponse(e.message ?: "Invalid request"))
        } catch (e: Exception) {
            log.error("Error creating vulnerability exception", e)
            HttpResponse.serverError<ErrorResponse>().body(ErrorResponse("Error creating exception: ${e.message}"))
        }
    }

    /**
     * Update an existing vulnerability exception
     *
     * PUT /api/vulnerability-exceptions/{id}
     * Auth: ADMIN or VULN role
     * Request: UpdateVulnerabilityExceptionRequest
     * Response: VulnerabilityExceptionDto (200 OK)
     */
    @Put("/api/vulnerability-exceptions/{id}")
    open fun updateException(
        id: Long,
        @Valid @Body request: UpdateVulnerabilityExceptionRequest
    ): HttpResponse<*> {
        return try {
            log.info("Updating exception id: {}", id)

            val updated = vulnerabilityExceptionService.updateException(id, request)

            log.info("Updated exception id: {}", id)
            HttpResponse.ok(updated)

        } catch (e: IllegalArgumentException) {
            log.warn("Exception not found or invalid update request: {}", e.message)
            HttpResponse.notFound(ErrorResponse(e.message ?: "Exception not found"))
        } catch (e: Exception) {
            log.error("Error updating vulnerability exception id: {}", id, e)
            HttpResponse.serverError<ErrorResponse>().body(ErrorResponse("Error updating exception: ${e.message}"))
        }
    }

    /**
     * Delete a vulnerability exception
     *
     * DELETE /api/vulnerability-exceptions/{id}
     * Auth: ADMIN or VULN role
     * Response: 204 NO CONTENT on success
     */
    @Delete("/api/vulnerability-exceptions/{id}")
    open fun deleteException(id: Long): HttpResponse<*> {
        return try {
            log.info("Deleting exception id: {}", id)

            vulnerabilityExceptionService.deleteException(id)

            log.info("Deleted exception id: {}", id)
            HttpResponse.noContent<Any>()

        } catch (e: IllegalArgumentException) {
            log.warn("Exception not found for deletion: {}", e.message)
            HttpResponse.notFound(ErrorResponse(e.message ?: "Exception not found"))
        } catch (e: Exception) {
            log.error("Error deleting vulnerability exception id: {}", id, e)
            HttpResponse.serverError<ErrorResponse>().body(ErrorResponse("Error deleting exception: ${e.message}"))
        }
    }

    /**
     * Get distinct product versions for autocomplete
     * Feature 021 Phase 3: Product Exception Enhancement
     *
     * GET /api/vulnerability-products?search=apache&limit=50
     * Auth: ADMIN or VULN role
     * Response: List<String> of product names
     *
     * Query Parameters:
     * - search: Optional search term to filter products
     * - limit: Maximum number of results (default: 50, max: 100)
     */
    @Get("/api/vulnerability-products")
    open fun getDistinctProducts(
        @Nullable @QueryValue search: String?,
        @Nullable @QueryValue limit: Int?
    ): HttpResponse<List<String>> {
        return try {
            val resultLimit = minOf(maxOf(limit ?: 50, 1), 100)
            log.debug("Getting distinct products - search: {}, limit: {}", search, resultLimit)

            val products = vulnerabilityService.getDistinctProducts(search, resultLimit)

            log.info("Returning {} distinct products", products.size)
            HttpResponse.ok(products)

        } catch (e: Exception) {
            log.error("Error fetching distinct products", e)
            HttpResponse.serverError()
        }
    }

    /**
     * Get distinct AD domains from assets
     * Used for filter dropdown population in Current Vulnerabilities view
     *
     * Endpoint: GET /api/vulnerability-ad-domains
     * Response: List<String> of AD domain names
     */
    @Get("/api/vulnerability-ad-domains")
    @Secured(SecurityRule.IS_AUTHENTICATED)
    open fun getDistinctAdDomains(): HttpResponse<List<String>> {
        return try {
            log.debug("Getting distinct AD domains")

            val domains = vulnerabilityService.getDistinctAdDomains()

            log.info("Returning {} distinct AD domains", domains.size)
            HttpResponse.ok(domains)

        } catch (e: Exception) {
            log.error("Error fetching distinct AD domains", e)
            HttpResponse.serverError()
        }
    }

    /**
     * Get distinct AWS cloud account IDs from assets
     * Used for filter dropdown population in Current Vulnerabilities view
     *
     * Endpoint: GET /api/vulnerability-cloud-account-ids
     * Response: List<String> of AWS cloud account IDs
     */
    @Get("/api/vulnerability-cloud-account-ids")
    @Secured(SecurityRule.IS_AUTHENTICATED)
    open fun getDistinctCloudAccountIds(): HttpResponse<List<String>> {
        return try {
            log.debug("Getting distinct AWS cloud account IDs")

            val accountIds = vulnerabilityService.getDistinctCloudAccountIds()

            log.info("Returning {} distinct AWS cloud account IDs", accountIds.size)
            HttpResponse.ok(accountIds)

        } catch (e: Exception) {
            log.error("Error fetching distinct AWS cloud account IDs", e)
            HttpResponse.serverError()
        }
    }

    /**
     * DTO for exception impact preview request
     * Feature 021 Phase 3
     */
    @Serdeable
    data class PreviewExceptionImpactRequest(
        val exceptionType: ExceptionType,
        val targetValue: String,
        val assetId: Long? = null
    )

    /**
     * DTO for exception impact preview response
     * Feature 021 Phase 3
     */
    @Serdeable
    data class ExceptionImpactPreview(
        val affectedVulnerabilities: List<VulnerabilityWithExceptionDto>,
        val totalCount: Int,
        val sampleSize: Int,
        val countBySeverity: Map<String, Int>
    )

    /**
     * Preview the impact of creating an exception
     * Feature 021 Phase 3: Product Exception Enhancement
     *
     * POST /api/vulnerability-exceptions/preview
     * Auth: ADMIN or VULN role
     * Request: PreviewExceptionImpactRequest
     * Response: ExceptionImpactPreview
     *
     * Shows a sample of vulnerabilities that would be affected by the exception
     * along with total count and severity breakdown
     */
    @Post("/api/vulnerability-exceptions/preview")
    open fun previewExceptionImpact(
        @Valid @Body request: PreviewExceptionImpactRequest
    ): HttpResponse<*> {
        return try {
            log.debug("Previewing exception impact - type: {}, target: {}, assetId: {}",
                request.exceptionType, request.targetValue, request.assetId)

            val (sample, totalCount) = vulnerabilityService.previewExceptionImpact(
                exceptionType = request.exceptionType,
                targetValue = request.targetValue,
                assetId = request.assetId,
                limit = 10  // Show first 10 as sample
            )

            // Count by severity
            val severityCounts = sample.groupingBy { it.cvssSeverity ?: "Unknown" }.eachCount()

            val preview = ExceptionImpactPreview(
                affectedVulnerabilities = sample,
                totalCount = totalCount,
                sampleSize = sample.size,
                countBySeverity = severityCounts
            )

            log.info("Exception would affect {} total vulnerabilities (showing {} sample)",
                totalCount, sample.size)
            HttpResponse.ok(preview)

        } catch (e: IllegalArgumentException) {
            log.warn("Invalid preview request: {}", e.message)
            HttpResponse.badRequest(ErrorResponse(e.message ?: "Invalid request"))
        } catch (e: Exception) {
            log.error("Error previewing exception impact", e)
            HttpResponse.serverError<ErrorResponse>()
                .body(ErrorResponse("Error previewing impact: ${e.message}"))
        }
    }

    /**
     * Cleanup duplicate vulnerabilities
     *
     * POST /api/vulnerabilities/cleanup-duplicates
     * Auth: ADMIN role ONLY
     * Response: VulnerabilityCleanupResult with statistics
     *
     * Removes duplicate vulnerabilities from the database. A duplicate is defined as:
     * - Same asset ID
     * - Same vulnerability ID (CVE)
     * - Same scan timestamp
     *
     * Keeps the oldest record (lowest ID) and deletes the rest.
     * The operation is idempotent and can be safely called multiple times.
     *
     * Feature: Vulnerability Duplicate Cleanup
     * User Story: As an ADMIN, I want to cleanup duplicate vulnerabilities
     *             so that the database remains clean and reporting is accurate
     */
    @Post("/api/vulnerabilities/cleanup-duplicates")
    @Secured("ADMIN")  // ADMIN only
    open fun cleanupDuplicates(authentication: Authentication): HttpResponse<*> {
        return try {
            log.info("Cleanup duplicates requested by user: {}", authentication.name)

            val result = vulnerabilityService.cleanupDuplicates()

            log.info("Cleanup completed: duplicatesRemoved={}, uniqueRemaining={}",
                result.duplicatesRemoved, result.uniqueVulnerabilitiesRemaining)

            HttpResponse.ok(result)

        } catch (e: Exception) {
            log.error("Error during vulnerability cleanup", e)
            HttpResponse.serverError<ErrorResponse>()
                .body(ErrorResponse("Error during cleanup: ${e.message}"))
        }
    }

    /**
     * Migrate vulnerability timestamps from import time to discovery date
     *
     * POST /api/vulnerabilities/migrate-timestamps?dryRun=true
     * Auth: ADMIN role ONLY
     * Response: MigrationResult with statistics
     *
     * Fixes the Feature 048 bug where scanTimestamp was set to import execution time
     * instead of vulnerability discovery date. This caused overdue status calculation errors
     * (e.g., 901-day-old vulnerabilities showing as "OK" because age was calculated from
     * last import time, not discovery date).
     *
     * The migration:
     * 1. Fetches all vulnerabilities
     * 2. Parses daysOpen field (e.g., "901 days" â†’ 901)
     * 3. Calculates discovery timestamp: currentTime - daysOpen
     * 4. Updates scanTimestamp to the calculated discovery date
     * 5. Handles patchPublicationDate if available (Feature 041)
     *
     * Query Parameters:
     * - dryRun: If true, only logs what would be changed without saving (default: false)
     *
     * Feature: 048 Fix - Prevent Duplicate Vulnerabilities (Timestamp Correction)
     * User Story: As an ADMIN, I want to fix existing vulnerability timestamps
     *             so that overdue status calculations are accurate
     */
    @Post("/api/vulnerabilities/migrate-timestamps")
    @Secured("ADMIN")  // ADMIN only
    open fun migrateTimestamps(
        authentication: Authentication,
        @QueryValue(defaultValue = "false") dryRun: Boolean
    ): HttpResponse<*> {
        return try {
            log.info("Timestamp migration requested by user: {} (dryRun={})", authentication.name, dryRun)

            val result = vulnerabilityTimestampMigrationService.migrateVulnerabilityTimestamps(dryRun)

            log.info("Migration completed: totalProcessed={}, migrated={}, skipped={}, errors={}",
                result.totalProcessed, result.migrated, result.skipped, result.errors)

            HttpResponse.ok(result)

        } catch (e: Exception) {
            log.error("Error during vulnerability timestamp migration", e)
            HttpResponse.serverError<ErrorResponse>()
                .body(ErrorResponse("Error during migration: ${e.message}"))
        }
    }

    /**
     * Migrate import timestamp for existing vulnerabilities
     *
     * Endpoint: POST /api/vulnerabilities/migrate-import-timestamp?dryRun=true
     *
     * Sets importTimestamp = createdAt for all vulnerabilities where importTimestamp is NULL.
     * This is needed after adding the importTimestamp field to support the "current" query
     * which uses MAX(importTimestamp) to find vulnerabilities from the latest import batch.
     *
     * Query Parameters:
     * - dryRun: If true, only logs what would be changed without saving (default: false)
     *
     * Feature: Import Timestamp field for Current Vulnerabilities query
     * User Story: As an ADMIN, I want to migrate existing vulnerabilities to have importTimestamp
     *             so that the Current Vulnerabilities view shows all vulns from the latest import
     */
    @Post("/api/vulnerabilities/migrate-import-timestamp")
    @Secured("ADMIN")  // ADMIN only
    open fun migrateImportTimestamp(
        authentication: Authentication,
        @QueryValue(defaultValue = "false") dryRun: Boolean
    ): HttpResponse<*> {
        return try {
            log.info("ImportTimestamp migration requested by user: {} (dryRun={})", authentication.name, dryRun)

            val result = vulnerabilityTimestampMigrationService.migrateImportTimestamp(dryRun)

            log.info("ImportTimestamp migration completed: totalProcessed={}, migrated={}, skipped={}, errors={}",
                result.totalProcessed, result.migrated, result.skipped, result.errors)

            HttpResponse.ok(result)

        } catch (e: Exception) {
            log.error("Error during importTimestamp migration", e)
            HttpResponse.serverError<ErrorResponse>()
                .body(ErrorResponse("Error during importTimestamp migration: ${e.message}"))
        }
    }

    /**
     * Add or update vulnerability via CLI
     * Feature: 052-cli-add-vulnerability
     *
     * POST /api/vulnerabilities/cli-add
     * Auth: ADMIN or VULN role
     * Request: AddVulnerabilityRequestDto
     * Response: AddVulnerabilityResponseDto (200 OK)
     *
     * Implements upsert pattern:
     * - If asset doesn't exist: create it with type=SERVER, owner=CLI-IMPORT
     * - If vulnerability with same CVE exists for asset: update it
     * - Otherwise: create new vulnerability
     *
     * User Story 1: Add vulnerability to existing asset (P1)
     * User Story 2: Add vulnerability with auto-created asset (P2)
     */
    @Post("/api/vulnerabilities/cli-add")
    @Secured("ADMIN", "VULN")
    open fun addVulnerabilityFromCli(
        @Valid @Body request: AddVulnerabilityRequestDto,
        authentication: Authentication
    ): HttpResponse<*> {
        return try {
            log.info("CLI add-vulnerability requested by user: {} - hostname: {}, cve: {}",
                authentication.name, request.hostname, request.cve)

            val result = vulnerabilityService.addVulnerabilityFromCli(request)

            log.info("CLI add-vulnerability completed: assetName={}, operation={}, assetCreated={}",
                result.assetName, result.operation, result.assetCreated)

            HttpResponse.ok(result)

        } catch (e: IllegalArgumentException) {
            log.warn("Invalid CLI add-vulnerability request: {}", e.message)
            HttpResponse.badRequest(ErrorResponse(e.message ?: "Invalid request"))
        } catch (e: Exception) {
            log.error("Error adding vulnerability via CLI", e)
            HttpResponse.serverError<ErrorResponse>()
                .body(ErrorResponse("Error adding vulnerability: ${e.message}"))
        }
    }
}
