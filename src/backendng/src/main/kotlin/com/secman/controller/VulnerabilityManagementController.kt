package com.secman.controller

import com.secman.domain.VulnerabilityException.ExceptionType
import com.secman.dto.CreateVulnerabilityExceptionRequest
import com.secman.dto.UpdateVulnerabilityExceptionRequest
import com.secman.dto.VulnerabilityExceptionDto
import com.secman.dto.VulnerabilityWithExceptionDto
import com.secman.dto.PaginatedVulnerabilitiesResponse
import com.secman.service.AssetFilterService
import com.secman.service.VulnerabilityExceptionService
import com.secman.service.VulnerabilityService
import io.micronaut.core.annotation.Nullable
import io.micronaut.http.HttpResponse
import io.micronaut.http.HttpStatus
import io.micronaut.http.annotation.*
import io.micronaut.scheduling.TaskExecutors
import io.micronaut.scheduling.annotation.ExecuteOn
import io.micronaut.security.annotation.Secured
import io.micronaut.security.authentication.Authentication
import io.micronaut.serde.annotation.Serdeable
import jakarta.validation.Valid
import org.slf4j.LoggerFactory
import kotlin.math.ceil

/**
 * Controller for vulnerability management and exception operations
 *
 * Endpoints:
 * - GET /api/vulnerabilities/current - List current vulnerabilities with filters
 * - GET /api/vulnerability-exceptions - List vulnerability exceptions
 * - POST /api/vulnerability-exceptions - Create new exception
 * - PUT /api/vulnerability-exceptions/{id} - Update exception
 * - DELETE /api/vulnerability-exceptions/{id} - Delete exception
 *
 * Access: ADMIN and VULN roles only
 *
 * Related to: Feature 004-i-want-to (VULN Role & Vulnerability Management UI)
 */
@Controller
@Secured("ADMIN", "VULN")
@ExecuteOn(TaskExecutors.BLOCKING)
open class VulnerabilityManagementController(
    private val vulnerabilityService: VulnerabilityService,
    private val vulnerabilityExceptionService: VulnerabilityExceptionService,
    private val assetFilterService: AssetFilterService
) {
    private val log = LoggerFactory.getLogger(VulnerabilityManagementController::class.java)

    @Serdeable
    data class ErrorResponse(val error: String)

    /**
     * Get current vulnerabilities (latest scan per asset) with exception status
     * Feature: 008-create-an-additional (Workgroup-Based Access Control)
     *
     * GET /api/vulnerabilities/current?severity=Critical&system=server&exceptionStatus=not_excepted&product=zlib&page=0&size=50
     * Auth: ADMIN or VULN role
     * Response: PaginatedVulnerabilitiesResponse
     *
     * FR-014, FR-016, FR-018: ADMIN sees all, VULN role respects workgroup restrictions
     *
     * Query Parameters:
     * - severity: Optional CVSS severity filter (e.g., "Critical", "High", "Medium", "Low")
     * - system: Optional system/asset name filter (substring match, case-insensitive)
     * - exceptionStatus: Optional filter - "excepted", "not_excepted", or omit for all
     * - product: Optional product/version filter (substring match, case-insensitive)
     * - page: Page number (0-indexed, default: 0)
     * - size: Page size (default: 50, max: 500)
     */
    @Get("/api/vulnerabilities/current")
    open fun getCurrentVulnerabilities(
        authentication: Authentication,
        @Nullable @QueryValue severity: String?,
        @Nullable @QueryValue system: String?,
        @Nullable @QueryValue exceptionStatus: String?,
        @Nullable @QueryValue product: String?,
        @Nullable @QueryValue page: Int?,
        @Nullable @QueryValue size: Int?
    ): HttpResponse<PaginatedVulnerabilitiesResponse> {
        return try {
            // Validate and sanitize pagination parameters
            val pageNumber = maxOf(page ?: 0, 0)
            val pageSize = minOf(maxOf(size ?: 50, 1), 500)
            
            log.debug("Getting current vulnerabilities for user: {} - severity: {}, system: {}, exceptionStatus: {}, product: {}, page: {}, size: {}",
                authentication.name, severity, system, exceptionStatus, product, pageNumber, pageSize)

            // Step 1: Get accessible assets based on workgroup membership
            val accessibleAssets = assetFilterService.getAccessibleAssets(authentication)
            val accessibleAssetIds = accessibleAssets.mapNotNull { it.id }.toSet()

            // Step 2: Get current vulnerabilities (latest per asset) from service with filters and pagination
            val (paginatedVulnerabilities, totalBeforePagination) = vulnerabilityService.getCurrentVulnerabilities(
                severity = severity,
                system = system,
                exceptionStatus = exceptionStatus,
                product = product,
                page = 0,  // Get all to filter by workgroup
                size = Int.MAX_VALUE
            )

            // Step 3: Intersect - only return current vulnerabilities for assets user can access
            val filteredVulnerabilities = paginatedVulnerabilities.filter { vulnDto ->
                vulnDto.assetId in accessibleAssetIds
            }

            // Step 4: Apply pagination to filtered results
            val totalElements = filteredVulnerabilities.size.toLong()
            val totalPages = ceil(totalElements.toDouble() / pageSize).toInt()
            val startIndex = pageNumber * pageSize
            val endIndex = minOf(startIndex + pageSize, filteredVulnerabilities.size)
            
            val finalPaginatedResult = if (startIndex < filteredVulnerabilities.size) {
                filteredVulnerabilities.subList(startIndex, endIndex)
            } else {
                emptyList()
            }
            
            val response = PaginatedVulnerabilitiesResponse(
                content = finalPaginatedResult,
                totalElements = totalElements,
                totalPages = totalPages,
                currentPage = pageNumber,
                pageSize = pageSize,
                hasNext = pageNumber < totalPages - 1,
                hasPrevious = pageNumber > 0
            )

            log.info("Returning {} current vulnerabilities for user {} (page {}/{}, total {})",
                finalPaginatedResult.size, authentication.name, pageNumber + 1, totalPages, totalElements)
            HttpResponse.ok(response)

        } catch (e: Exception) {
            log.error("Error fetching current vulnerabilities for user: {}", authentication.name, e)
            HttpResponse.serverError()
        }
    }

    /**
     * Get all vulnerability exceptions
     *
     * GET /api/vulnerability-exceptions?activeOnly=true&type=IP
     * Auth: ADMIN or VULN role
     * Response: List<VulnerabilityExceptionDto>
     *
     * Query Parameters:
     * - activeOnly: If true, only return non-expired exceptions (default: false)
     * - type: Optional filter by exception type (IP or PRODUCT)
     */
    @Get("/api/vulnerability-exceptions")
    open fun getAllExceptions(
        @Nullable @QueryValue activeOnly: Boolean?,
        @Nullable @QueryValue type: ExceptionType?
    ): HttpResponse<List<VulnerabilityExceptionDto>> {
        return try {
            log.debug("Getting exceptions - activeOnly: {}, type: {}", activeOnly, type)

            val exceptions = vulnerabilityExceptionService.getAllExceptions(
                activeOnly = activeOnly ?: false,
                type = type
            )

            log.info("Returning {} exceptions", exceptions.size)
            HttpResponse.ok(exceptions)

        } catch (e: Exception) {
            log.error("Error fetching vulnerability exceptions", e)
            HttpResponse.serverError()
        }
    }

    /**
     * Create a new vulnerability exception
     *
     * POST /api/vulnerability-exceptions
     * Auth: ADMIN or VULN role
     * Request: CreateVulnerabilityExceptionRequest
     * Response: VulnerabilityExceptionDto (201 Created)
     */
    @Post("/api/vulnerability-exceptions")
    open fun createException(
        @Valid @Body request: CreateVulnerabilityExceptionRequest,
        authentication: Authentication
    ): HttpResponse<*> {
        return try {
            val username = authentication.name
            log.info("Creating exception - type: {}, target: {}, by: {}",
                request.exceptionType, request.targetValue, username)

            val created = vulnerabilityExceptionService.createException(request, username)

            log.info("Created exception with id: {}", created.id)
            HttpResponse.status<VulnerabilityExceptionDto>(HttpStatus.CREATED).body(created)

        } catch (e: IllegalArgumentException) {
            log.warn("Invalid exception creation request: {}", e.message)
            HttpResponse.badRequest(ErrorResponse(e.message ?: "Invalid request"))
        } catch (e: Exception) {
            log.error("Error creating vulnerability exception", e)
            HttpResponse.serverError<ErrorResponse>().body(ErrorResponse("Error creating exception: ${e.message}"))
        }
    }

    /**
     * Update an existing vulnerability exception
     *
     * PUT /api/vulnerability-exceptions/{id}
     * Auth: ADMIN or VULN role
     * Request: UpdateVulnerabilityExceptionRequest
     * Response: VulnerabilityExceptionDto (200 OK)
     */
    @Put("/api/vulnerability-exceptions/{id}")
    open fun updateException(
        id: Long,
        @Valid @Body request: UpdateVulnerabilityExceptionRequest
    ): HttpResponse<*> {
        return try {
            log.info("Updating exception id: {}", id)

            val updated = vulnerabilityExceptionService.updateException(id, request)

            log.info("Updated exception id: {}", id)
            HttpResponse.ok(updated)

        } catch (e: IllegalArgumentException) {
            log.warn("Exception not found or invalid update request: {}", e.message)
            HttpResponse.notFound(ErrorResponse(e.message ?: "Exception not found"))
        } catch (e: Exception) {
            log.error("Error updating vulnerability exception id: {}", id, e)
            HttpResponse.serverError<ErrorResponse>().body(ErrorResponse("Error updating exception: ${e.message}"))
        }
    }

    /**
     * Delete a vulnerability exception
     *
     * DELETE /api/vulnerability-exceptions/{id}
     * Auth: ADMIN or VULN role
     * Response: 204 NO CONTENT on success
     */
    @Delete("/api/vulnerability-exceptions/{id}")
    open fun deleteException(id: Long): HttpResponse<*> {
        return try {
            log.info("Deleting exception id: {}", id)

            vulnerabilityExceptionService.deleteException(id)

            log.info("Deleted exception id: {}", id)
            HttpResponse.noContent<Any>()

        } catch (e: IllegalArgumentException) {
            log.warn("Exception not found for deletion: {}", e.message)
            HttpResponse.notFound(ErrorResponse(e.message ?: "Exception not found"))
        } catch (e: Exception) {
            log.error("Error deleting vulnerability exception id: {}", id, e)
            HttpResponse.serverError<ErrorResponse>().body(ErrorResponse("Error deleting exception: ${e.message}"))
        }
    }

    /**
     * Get distinct product versions for autocomplete
     * Feature 021 Phase 3: Product Exception Enhancement
     *
     * GET /api/vulnerability-products?search=apache&limit=50
     * Auth: ADMIN or VULN role
     * Response: List<String> of product names
     *
     * Query Parameters:
     * - search: Optional search term to filter products
     * - limit: Maximum number of results (default: 50, max: 100)
     */
    @Get("/api/vulnerability-products")
    open fun getDistinctProducts(
        @Nullable @QueryValue search: String?,
        @Nullable @QueryValue limit: Int?
    ): HttpResponse<List<String>> {
        return try {
            val resultLimit = minOf(maxOf(limit ?: 50, 1), 100)
            log.debug("Getting distinct products - search: {}, limit: {}", search, resultLimit)

            val products = vulnerabilityService.getDistinctProducts(search, resultLimit)

            log.info("Returning {} distinct products", products.size)
            HttpResponse.ok(products)

        } catch (e: Exception) {
            log.error("Error fetching distinct products", e)
            HttpResponse.serverError()
        }
    }

    /**
     * DTO for exception impact preview request
     * Feature 021 Phase 3
     */
    @Serdeable
    data class PreviewExceptionImpactRequest(
        val exceptionType: ExceptionType,
        val targetValue: String,
        val assetId: Long? = null
    )

    /**
     * DTO for exception impact preview response
     * Feature 021 Phase 3
     */
    @Serdeable
    data class ExceptionImpactPreview(
        val affectedVulnerabilities: List<VulnerabilityWithExceptionDto>,
        val totalCount: Int,
        val sampleSize: Int,
        val countBySeverity: Map<String, Int>
    )

    /**
     * Preview the impact of creating an exception
     * Feature 021 Phase 3: Product Exception Enhancement
     *
     * POST /api/vulnerability-exceptions/preview
     * Auth: ADMIN or VULN role
     * Request: PreviewExceptionImpactRequest
     * Response: ExceptionImpactPreview
     *
     * Shows a sample of vulnerabilities that would be affected by the exception
     * along with total count and severity breakdown
     */
    @Post("/api/vulnerability-exceptions/preview")
    open fun previewExceptionImpact(
        @Valid @Body request: PreviewExceptionImpactRequest
    ): HttpResponse<*> {
        return try {
            log.debug("Previewing exception impact - type: {}, target: {}, assetId: {}",
                request.exceptionType, request.targetValue, request.assetId)

            val (sample, totalCount) = vulnerabilityService.previewExceptionImpact(
                exceptionType = request.exceptionType,
                targetValue = request.targetValue,
                assetId = request.assetId,
                limit = 10  // Show first 10 as sample
            )

            // Count by severity
            val severityCounts = sample.groupingBy { it.cvssSeverity ?: "Unknown" }.eachCount()

            val preview = ExceptionImpactPreview(
                affectedVulnerabilities = sample,
                totalCount = totalCount,
                sampleSize = sample.size,
                countBySeverity = severityCounts
            )

            log.info("Exception would affect {} total vulnerabilities (showing {} sample)",
                totalCount, sample.size)
            HttpResponse.ok(preview)

        } catch (e: IllegalArgumentException) {
            log.warn("Invalid preview request: {}", e.message)
            HttpResponse.badRequest(ErrorResponse(e.message ?: "Invalid request"))
        } catch (e: Exception) {
            log.error("Error previewing exception impact", e)
            HttpResponse.serverError<ErrorResponse>()
                .body(ErrorResponse("Error previewing impact: ${e.message}"))
        }
    }
}
