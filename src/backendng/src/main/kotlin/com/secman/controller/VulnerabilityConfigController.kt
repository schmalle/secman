package com.secman.controller

import com.secman.dto.UpdateVulnerabilityConfigRequest
import com.secman.dto.VulnerabilityConfigDto
import com.secman.service.VulnerabilityConfigService
import io.micronaut.http.HttpResponse
import io.micronaut.http.annotation.*
import io.micronaut.scheduling.TaskExecutors
import io.micronaut.scheduling.annotation.ExecuteOn
import io.micronaut.security.annotation.Secured
import io.micronaut.security.authentication.Authentication
import io.micronaut.serde.annotation.Serdeable
import jakarta.validation.Valid
import org.slf4j.LoggerFactory

/**
 * Controller for vulnerability configuration management.
 *
 * Endpoints:
 * - GET /api/admin/vulnerability-config - Get current configuration
 * - PUT /api/admin/vulnerability-config - Update configuration
 *
 * Access: ADMIN role only
 *
 * Related to: Feature 021-vulnerability-overdue-exception-logic
 */
@Controller("/api/admin")
@Secured("ADMIN")
@ExecuteOn(TaskExecutors.BLOCKING)
open class VulnerabilityConfigController(
    private val configService: VulnerabilityConfigService
) {
    private val log = LoggerFactory.getLogger(VulnerabilityConfigController::class.java)
    
    @Serdeable
    data class ErrorResponse(val error: String)
    
    /**
     * Get current vulnerability configuration.
     *
     * GET /api/admin/vulnerability-config
     * Auth: ADMIN role required
     * Response: VulnerabilityConfigDto
     *
     * @return Current configuration or error response
     */
    @Get("/vulnerability-config")
    open fun getConfig(): HttpResponse<VulnerabilityConfigDto> {
        return try {
            log.debug("GET /api/admin/vulnerability-config - fetching current config")
            val config = configService.getConfig()
            log.debug("Returning config: reminderOneDays={}", config.reminderOneDays)
            HttpResponse.ok(config)
        } catch (e: Exception) {
            log.error("Error fetching vulnerability config", e)
            HttpResponse.serverError()
        }
    }
    
    /**
     * Update vulnerability configuration.
     *
     * PUT /api/admin/vulnerability-config
     * Auth: ADMIN role required
     * Request: UpdateVulnerabilityConfigRequest
     * Response: VulnerabilityConfigDto (updated config)
     *
     * @param request Update request with new reminderOneDays value
     * @param authentication Current authenticated user
     * @return Updated configuration or error response
     */
    @Put("/vulnerability-config")
    open fun updateConfig(
        @Valid @Body request: UpdateVulnerabilityConfigRequest,
        authentication: Authentication
    ): HttpResponse<*> {
        return try {
            val username = authentication.name
            log.info("PUT /api/admin/vulnerability-config - user: {}, reminderOneDays: {}", 
                username, request.reminderOneDays)
            
            val updated = configService.updateConfig(
                request.reminderOneDays,
                username
            )
            
            log.info("Config updated successfully by {}", username)
            HttpResponse.ok(updated)
        } catch (e: IllegalArgumentException) {
            log.warn("Invalid config update request: {}", e.message)
            HttpResponse.badRequest(ErrorResponse(e.message ?: "Invalid request"))
        } catch (e: Exception) {
            log.error("Error updating vulnerability config", e)
            HttpResponse.serverError<ErrorResponse>().body(
                ErrorResponse("Error updating configuration: ${e.message}")
            )
        }
    }
}
