package com.secman.service

import com.secman.repository.VulnerabilityRepository
import io.micronaut.context.annotation.Requires
import io.micronaut.transaction.annotation.Transactional
import jakarta.inject.Singleton
import org.slf4j.LoggerFactory
import java.time.LocalDateTime

/**
 * Service to migrate vulnerability scanTimestamp values from import time to discovery date
 *
 * Feature 048 Fix: Corrects the bug where scanTimestamp was set to import execution time
 * instead of the actual vulnerability discovery date, causing overdue status calculation errors.
 *
 * Background: After Feature 048 implementation, scanTimestamp was set to LocalDateTime.now()
 * for idempotency. This broke overdue status calculation (ChronoUnit.DAYS.between(scanTimestamp, now))
 * because vulnerabilities always appeared to be 0-1 days old regardless of actual age.
 *
 * This migration recalculates scanTimestamp by working backwards from the current time using
 * the daysOpen field (e.g., "901 days" → currentTime - 901 days).
 *
 * Related to: Feature 048 (Prevent Duplicate Vulnerabilities)
 */
@Singleton
@Requires(bean = VulnerabilityRepository::class)
open class VulnerabilityTimestampMigrationService(
    private val vulnerabilityRepository: VulnerabilityRepository
) {
    private val log = LoggerFactory.getLogger(javaClass)

    /**
     * Migrate all vulnerability timestamps from import time to discovery date
     *
     * Process:
     * 1. Fetch all vulnerabilities from database
     * 2. Parse daysOpen field (e.g., "901 days" → 901)
     * 3. Calculate discovery timestamp: currentTime - daysOpen
     * 4. Handle special cases:
     *    - Use patchPublicationDate if available (Feature 041)
     *    - Skip if daysOpen is unparseable
     * 5. Update scanTimestamp field
     * 6. Save in batch
     *
     * @param dryRun If true, only logs what would be changed without saving (default: false)
     * @return Migration result with counts
     */
    @Transactional
    open fun migrateVulnerabilityTimestamps(dryRun: Boolean = false): MigrationResult {
        log.info("Starting vulnerability timestamp migration (dryRun=$dryRun)")
        val currentTime = LocalDateTime.now()

        val allVulnerabilities = vulnerabilityRepository.findAll()
        log.info("Found ${allVulnerabilities.size} vulnerabilities to process")

        var migratedCount = 0
        var skippedCount = 0
        var errorCount = 0
        val errors = mutableListOf<String>()

        val vulnerabilitiesToUpdate = mutableListOf<com.secman.domain.Vulnerability>()

        for (vuln in allVulnerabilities) {
            try {
                // Determine the correct scanTimestamp
                val patchDate = vuln.patchPublicationDate
                val newScanTimestamp: LocalDateTime = if (patchDate != null) {
                    // Use patch publication date if available (Feature 041)
                    log.trace("Vuln ${vuln.id} (${vuln.vulnerabilityId}): Using patchPublicationDate=$patchDate")
                    patchDate
                } else {
                    // Parse daysOpen field (e.g., "901 days" or "1 day")
                    val daysOpenText = vuln.daysOpen
                    if (daysOpenText == null) {
                        log.warn("Vuln ${vuln.id} (${vuln.vulnerabilityId}): daysOpen is null, skipping")
                        skippedCount++
                        continue
                    }

                    val daysOpenNumber = parseDaysOpen(daysOpenText)
                    if (daysOpenNumber == null) {
                        log.warn("Vuln ${vuln.id} (${vuln.vulnerabilityId}): Cannot parse daysOpen='$daysOpenText', skipping")
                        skippedCount++
                        continue
                    }

                    // Calculate discovery timestamp by working backwards
                    val discoveryTimestamp = currentTime.minusDays(daysOpenNumber.toLong())
                    log.trace("Vuln ${vuln.id} (${vuln.vulnerabilityId}): daysOpen=$daysOpenNumber, discoveryTimestamp=$discoveryTimestamp")
                    discoveryTimestamp
                }

                // Check if timestamp actually changed (optimization)
                if (vuln.scanTimestamp == newScanTimestamp) {
                    log.trace("Vuln ${vuln.id} (${vuln.vulnerabilityId}): scanTimestamp unchanged, skipping")
                    skippedCount++
                    continue
                }

                // Update the timestamp
                val oldTimestamp = vuln.scanTimestamp
                vuln.scanTimestamp = newScanTimestamp

                log.debug("Vuln ${vuln.id} (${vuln.vulnerabilityId} on ${vuln.asset.name}): " +
                    "Updating scanTimestamp from $oldTimestamp to $newScanTimestamp")

                vulnerabilitiesToUpdate.add(vuln)
                migratedCount++

            } catch (e: Exception) {
                log.error("Error processing vulnerability ${vuln.id} (${vuln.vulnerabilityId}): ${e.message}", e)
                errors.add("Vuln ${vuln.id} (${vuln.vulnerabilityId}): ${e.message}")
                errorCount++
            }
        }

        // Save updates
        if (!dryRun && vulnerabilitiesToUpdate.isNotEmpty()) {
            log.info("Saving ${vulnerabilitiesToUpdate.size} updated vulnerabilities to database")
            vulnerabilityRepository.updateAll(vulnerabilitiesToUpdate)
            log.info("Successfully saved ${vulnerabilitiesToUpdate.size} vulnerabilities")
        } else if (dryRun) {
            log.info("DRY RUN: Would have updated ${vulnerabilitiesToUpdate.size} vulnerabilities")
        }

        val result = MigrationResult(
            totalProcessed = allVulnerabilities.size,
            migrated = migratedCount,
            skipped = skippedCount,
            errors = errorCount,
            errorMessages = errors,
            dryRun = dryRun
        )

        log.info("Migration complete: $result")
        return result
    }

    /**
     * Parse the daysOpen field to extract the number of days
     *
     * Examples:
     * - "901 days" → 901
     * - "1 day" → 1
     * - "58 days" → 58
     * - null or unparseable → null
     *
     * @param daysOpenText The daysOpen field value
     * @return The number of days, or null if unparseable
     */
    private fun parseDaysOpen(daysOpenText: String): Int? {
        try {
            // Extract the first number from the string
            val numberMatch = Regex("\\d+").find(daysOpenText)
            return numberMatch?.value?.toIntOrNull()
        } catch (e: Exception) {
            log.error("Failed to parse daysOpen='$daysOpenText': ${e.message}")
            return null
        }
    }

    /**
     * Result of the timestamp migration operation
     */
    data class MigrationResult(
        val totalProcessed: Int,
        val migrated: Int,
        val skipped: Int,
        val errors: Int,
        val errorMessages: List<String>,
        val dryRun: Boolean
    ) {
        override fun toString(): String {
            return "MigrationResult(totalProcessed=$totalProcessed, migrated=$migrated, " +
                "skipped=$skipped, errors=$errors, dryRun=$dryRun)"
        }
    }
}
