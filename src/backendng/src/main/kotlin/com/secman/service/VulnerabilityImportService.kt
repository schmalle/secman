package com.secman.service

import com.secman.config.VulnerabilitySettings
import com.secman.domain.Vulnerability
import com.secman.dto.SkippedRowDetail
import com.secman.dto.VulnerabilityImportResponse
import com.secman.repository.VulnerabilityRepository
import jakarta.inject.Singleton
import org.apache.poi.ss.usermodel.*
import org.apache.poi.xssf.usermodel.XSSFWorkbook
import org.slf4j.LoggerFactory
import java.io.InputStream
import java.time.LocalDateTime
import java.time.format.DateTimeFormatter
import java.time.format.DateTimeParseException
import java.time.temporal.ChronoUnit

/**
 * Service for importing vulnerabilities from Excel files
 *
 * Handles:
 * - Excel file parsing (Apache POI)
 * - Row validation (skip invalid, continue with valid)
 * - Asset lookup/creation via AssetMergeService
 * - Vulnerability entity creation
 * - Import statistics tracking
 *
 * Related to: Feature 003-i-want-to (Vulnerability Management System)
 */
@Singleton
class VulnerabilityImportService(
    private val vulnerabilityRepository: VulnerabilityRepository,
    private val assetMergeService: AssetMergeService,
    private val vulnerabilitySettings: VulnerabilitySettings
) {
    private val log = LoggerFactory.getLogger(VulnerabilityImportService::class.java)

    companion object {
        private val REQUIRED_HEADERS = listOf(
            "Hostname", "Local IP", "Host groups", "Cloud service account ID",
            "Cloud service instance ID", "OS version", "Active Directory domain",
            "Vulnerability ID", "CVSS severity", "Vulnerable product versions", "Days open"
        )

        // Optional headers (for backward compatibility)
        private val OPTIONAL_HEADERS = listOf(
            "Patch Publication Date"
        )
    }

    /**
     * Import vulnerabilities from an Excel file
     *
     * @param fileInputStream Excel file input stream
     * @param scanDate When the scan was performed (user-specified)
     * @return Import response with counts and skipped details
     */
    fun importFromExcel(fileInputStream: InputStream, scanDate: LocalDateTime): VulnerabilityImportResponse {
        log.info("Starting vulnerability import, scan date: {}", scanDate)

        val vulnerabilities = mutableListOf<Vulnerability>()
        val skippedRows = mutableListOf<SkippedRowDetail>()
        val createdAssets = mutableSetOf<String>() // Track new asset hostnames

        try {
            XSSFWorkbook(fileInputStream).use { workbook ->
                val sheet = workbook.getSheetAt(0) ?: throw IllegalArgumentException("Excel file has no sheets")

                // Validate headers
                val headerMap = validateAndMapHeaders(sheet)

                // Process data rows (skip header row 0)
                for (rowIndex in 1..sheet.lastRowNum) {
                    val row = sheet.getRow(rowIndex) ?: continue

                    try {
                        val result = parseRowToVulnerability(row, headerMap, scanDate, createdAssets)
                        if (result != null) {
                            vulnerabilities.add(result)
                        }
                    } catch (e: Exception) {
                        log.warn("Failed to parse row {}: {}", rowIndex + 1, e.message)
                        skippedRows.add(SkippedRowDetail(rowIndex + 1, e.message ?: "Unknown error"))
                    }
                }
            }

            // Save all vulnerabilities
            val saved = vulnerabilityRepository.saveAll(vulnerabilities)
            log.info("Import complete: {} vulnerabilities saved, {} rows skipped, {} assets created",
                saved.count(), skippedRows.size, createdAssets.size)

            return VulnerabilityImportResponse.create(
                imported = saved.count(),
                skipped = skippedRows.size,
                assetsCreated = createdAssets.size,
                skippedDetails = skippedRows
            )

        } catch (e: Exception) {
            log.error("Error during vulnerability import", e)
            throw IllegalArgumentException("Failed to import vulnerabilities: ${e.message}", e)
        }
    }

    /**
     * Validate headers and create column index mapping
     *
     * @param sheet Excel sheet
     * @return Map of header name to column index
     */
    private fun validateAndMapHeaders(sheet: Sheet): Map<String, Int> {
        val headerRow = sheet.getRow(0) ?: throw IllegalArgumentException("Header row not found")

        val headerMap = mutableMapOf<String, Int>()

        for (cellIndex in 0 until headerRow.lastCellNum) {
            val cell = headerRow.getCell(cellIndex)
            if (cell != null) {
                val headerName = getCellValueAsString(cell).trim()

                // Map required headers (case-insensitive)
                REQUIRED_HEADERS.forEach { required ->
                    if (headerName.equals(required, ignoreCase = true)) {
                        headerMap[required] = cellIndex
                    }
                }

                // Map optional headers (case-insensitive)
                OPTIONAL_HEADERS.forEach { optional ->
                    if (headerName.equals(optional, ignoreCase = true)) {
                        headerMap[optional] = cellIndex
                    }
                }
            }
        }

        // Check for required headers
        val missingHeaders = REQUIRED_HEADERS.filter { !headerMap.containsKey(it) }
        if (missingHeaders.isNotEmpty()) {
            throw IllegalArgumentException("Missing required headers: ${missingHeaders.joinToString(", ")}")
        }

        return headerMap
    }

    /**
     * Parse a row into a Vulnerability entity
     *
     * @param row Excel row
     * @param headerMap Column index mapping
     * @param scanDate Scan timestamp
     * @param createdAssets Set to track newly created assets
     * @return Vulnerability entity or null if row should be skipped
     */
    private fun parseRowToVulnerability(
        row: Row,
        headerMap: Map<String, Int>,
        scanDate: LocalDateTime,
        createdAssets: MutableSet<String>
    ): Vulnerability? {
        // Get hostname (required)
        val hostname = getCellValue(row, headerMap, "Hostname")?.trim()
        if (hostname.isNullOrBlank()) {
            throw IllegalArgumentException("Missing required hostname")
        }

        // Get other fields (all optional)
        val ip = getCellValue(row, headerMap, "Local IP")?.trim()
        val groups = getCellValue(row, headerMap, "Host groups")?.trim()
        val cloudAccountId = getCellValue(row, headerMap, "Cloud service account ID")?.trim()
        val cloudInstanceId = getCellValue(row, headerMap, "Cloud service instance ID")?.trim()
        val osVersion = getCellValue(row, headerMap, "OS version")?.trim()
        val adDomain = getCellValue(row, headerMap, "Active Directory domain")?.trim()

        val vulnerabilityId = getCellValue(row, headerMap, "Vulnerability ID")?.trim()
        val cvssSeverity = getCellValue(row, headerMap, "CVSS severity")?.trim()
        val vulnerableProductVersions = getCellValue(row, headerMap, "Vulnerable product versions")?.trim()
        val daysOpen = getCellValue(row, headerMap, "Days open")?.trim()

        // Parse patch publication date (optional column)
        val patchPublicationDateStr = getCellValue(row, headerMap, "Patch Publication Date")?.trim()
        val patchPublicationDate = parsePatchPublicationDate(patchPublicationDateStr)

        // Skip vulnerability if patch publication date is required but not present (Feature 041)
        if (vulnerabilitySettings.requirePatchPublicationDate && patchPublicationDate == null) {
            log.debug("Skipping vulnerability {} for asset {} - patch publication date required but not present",
                vulnerabilityId, hostname)
            return null // Skip this row
        }

        // Find or create asset
        val assetBefore = assetMergeService.findOrCreateAsset(
            hostname = hostname,
            ip = ip,
            groups = groups,
            cloudAccountId = cloudAccountId,
            cloudInstanceId = cloudInstanceId,
            osVersion = osVersion,
            adDomain = adDomain
        )

        // Track if this was a newly created asset
        if (assetBefore.createdAt != null &&
            assetBefore.createdAt!!.isAfter(LocalDateTime.now().minusMinutes(1))) {
            createdAssets.add(hostname)
        }

        // Calculate effective scan timestamp and days open based on configuration
        val (effectiveScanTimestamp, effectiveDaysOpen) = if (vulnerabilitySettings.usePatchPublicationDate && patchPublicationDate != null) {
            // Use patch publication date for calculation (Feature 041)
            val daysFromPatch = ChronoUnit.DAYS.between(patchPublicationDate, scanDate).toInt()
            val calculatedScanTime = scanDate
            val daysText = if (daysFromPatch == 1) "1 day" else "$daysFromPatch days"

            log.trace("Using patch publication date for CVE {}: patch_date={}, scan_date={}, days_from_patch={}",
                vulnerabilityId, patchPublicationDate, scanDate, daysFromPatch)

            Pair(calculatedScanTime, daysText)
        } else {
            // Use original logic: use provided days open and scan date
            Pair(scanDate, daysOpen?.takeIf { it.isNotEmpty() })
        }

        // Create vulnerability entity
        val vulnerability = Vulnerability(
            asset = assetBefore,
            vulnerabilityId = vulnerabilityId?.takeIf { it.isNotEmpty() },
            cvssSeverity = cvssSeverity?.takeIf { it.isNotEmpty() },
            vulnerableProductVersions = vulnerableProductVersions?.takeIf { it.isNotEmpty() },
            daysOpen = effectiveDaysOpen,
            scanTimestamp = effectiveScanTimestamp,
            patchPublicationDate = patchPublicationDate
        )

        return vulnerability
    }

    /**
     * Get cell value from row by header name
     *
     * @param row Excel row
     * @param headerMap Column index mapping
     * @param headerName Header name
     * @return Cell value as string or null
     */
    private fun getCellValue(row: Row, headerMap: Map<String, Int>, headerName: String): String? {
        val cellIndex = headerMap[headerName] ?: return null
        val cell = row.getCell(cellIndex) ?: return null
        return getCellValueAsString(cell)
    }

    /**
     * Convert cell value to string
     * Handles different cell types: STRING, NUMERIC, BOOLEAN, FORMULA
     *
     * @param cell Excel cell
     * @return Cell value as string
     */
    private fun getCellValueAsString(cell: Cell): String {
        return when (cell.cellType) {
            CellType.STRING -> cell.stringCellValue
            CellType.NUMERIC -> {
                if (DateUtil.isCellDateFormatted(cell)) {
                    cell.localDateTimeCellValue.toString()
                } else {
                    // Use DataFormatter for consistent number formatting
                    val formatter = DataFormatter()
                    formatter.formatCellValue(cell)
                }
            }
            CellType.BOOLEAN -> cell.booleanCellValue.toString()
            CellType.FORMULA -> {
                try {
                    val evaluator = cell.sheet.workbook.creationHelper.createFormulaEvaluator()
                    val result = evaluator.evaluate(cell)
                    when (result.cellType) {
                        CellType.STRING -> result.stringValue
                        CellType.NUMERIC -> result.numberValue.toString()
                        CellType.BOOLEAN -> result.booleanValue.toString()
                        else -> ""
                    }
                } catch (e: Exception) {
                    log.warn("Failed to evaluate formula in cell: {}", e.message)
                    ""
                }
            }
            else -> ""
        }
    }

    /**
     * Parse patch publication date from string value
     * Supports multiple date formats:
     * - ISO 8601: "2024-05-15T22:18:26" or "2024-05-15T22:18:26Z"
     * - Date only: "2024-05-15"
     * - Excel default: LocalDateTime from cell
     *
     * @param dateStr Date string from Excel cell
     * @return Parsed LocalDateTime or null if parsing fails or empty
     */
    private fun parsePatchPublicationDate(dateStr: String?): LocalDateTime? {
        if (dateStr.isNullOrBlank()) {
            return null
        }

        return try {
            // Try parsing as ISO 8601 with time
            LocalDateTime.parse(dateStr, DateTimeFormatter.ISO_DATE_TIME)
        } catch (e: DateTimeParseException) {
            try {
                // Try parsing as date-only (add time component)
                LocalDateTime.parse(dateStr + "T00:00:00")
            } catch (e2: DateTimeParseException) {
                try {
                    // Try parsing without timezone indicator
                    LocalDateTime.parse(dateStr.replace("Z", "").replace(" ", "T"))
                } catch (e3: DateTimeParseException) {
                    log.debug("Failed to parse patch publication date '{}': {}", dateStr, e3.message)
                    null
                }
            }
        }
    }
}
