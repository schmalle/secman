package com.secman.service

import com.secman.domain.*
import com.secman.dto.*
import com.secman.exception.ConcurrentApprovalException
import com.secman.repository.*
import io.micronaut.context.event.ApplicationEventPublisher
import io.micronaut.data.model.Page
import io.micronaut.data.model.Pageable
import jakarta.inject.Inject
import jakarta.inject.Singleton
import jakarta.persistence.OptimisticLockException
import jakarta.transaction.Transactional
import org.slf4j.LoggerFactory
import java.time.LocalDateTime

/**
 * Core business logic service for vulnerability exception request workflow.
 *
 * Responsibilities:
 * - Create exception requests (with auto-approval for ADMIN/SECCHAMPION)
 * - Approve/reject pending requests (with optimistic locking)
 * - Cancel pending requests
 * - Retrieve requests with pagination and filtering
 * - Calculate summary statistics
 * - Create VulnerabilityException entries on approval
 *
 * Concurrency Control:
 * - Uses optimistic locking (@Version field) to prevent race conditions
 * - First-approver-wins: Multiple simultaneous approvals handled gracefully
 * - Throws ConcurrentApprovalException when optimistic lock fails
 *
 * Feature: 031-vuln-exception-approval
 * Reference: quickstart.md lines 35-91, research.md lines 77-110
 */
@Singleton
open class VulnerabilityExceptionRequestService(
    @Inject private val requestRepository: VulnerabilityExceptionRequestRepository,
    @Inject private val vulnerabilityRepository: VulnerabilityRepository,
    @Inject private val vulnerabilityExceptionRepository: VulnerabilityExceptionRepository,
    @Inject private val userRepository: UserRepository,
    @Inject private val auditService: ExceptionRequestAuditService,
    @Inject private val eventPublisher: ApplicationEventPublisher<ExceptionCountChangedEvent>,
    @Inject private val notificationService: ExceptionRequestNotificationService
) {
    private val logger = LoggerFactory.getLogger(VulnerabilityExceptionRequestService::class.java)

    /**
     * Create a new exception request.
     *
     * Auto-approval logic:
     * - If requester has ADMIN or SECCHAMPION role → Status = APPROVED, auto-approval flag = true
     * - Otherwise → Status = PENDING (requires manual approval)
     *
     * @param dto Request creation data
     * @param requesterUserId ID of the user creating the request
     * @param clientIp Client IP address for audit logging (optional)
     * @return Created request DTO
     * @throws IllegalArgumentException if vulnerability not found or duplicate active request exists
     */
    @Transactional
    open fun createRequest(
        dto: CreateExceptionRequestDto,
        requesterUserId: Long,
        clientIp: String? = null
    ): VulnerabilityExceptionRequestDto {
        logger.debug("Creating exception request: vulnerabilityId={}, userId={}", dto.vulnerabilityId, requesterUserId)

        // Validate vulnerability exists
        val vulnerability = vulnerabilityRepository.findById(dto.vulnerabilityId).orElseThrow {
            IllegalArgumentException("Vulnerability with ID ${dto.vulnerabilityId} not found")
        }

        // Get requester user
        val requester = userRepository.findById(requesterUserId).orElseThrow {
            IllegalArgumentException("User with ID $requesterUserId not found")
        }

        // Check for duplicate active requests (FR-033)
        checkForDuplicateActiveRequest(dto.vulnerabilityId)

        // Determine if auto-approval applies
        val isAutoApproved = requester.hasRole(User.Role.ADMIN) || requester.hasRole(User.Role.SECCHAMPION)
        val initialStatus = if (isAutoApproved) ExceptionRequestStatus.APPROVED else ExceptionRequestStatus.PENDING

        // Create request entity (with sanitized reason to prevent XSS)
        val request = VulnerabilityExceptionRequest(
            vulnerability = vulnerability,
            requestedByUser = requester,
            requestedByUsername = requester.username,
            scope = dto.scope,
            reason = sanitizeInput(dto.reason),
            expirationDate = dto.expirationDate,
            status = initialStatus,
            autoApproved = isAutoApproved
        )

        // If auto-approved, set review fields immediately
        if (isAutoApproved) {
            request.reviewedByUser = requester
            request.reviewedByUsername = requester.username
            request.reviewDate = LocalDateTime.now()
        }

        // Save request
        val savedRequest = requestRepository.save(request)

        // Log creation
        auditService.logRequestCreated(savedRequest, requester, clientIp)

        // If auto-approved, create exception immediately and log approval
        if (isAutoApproved) {
            createExceptionFromRequest(savedRequest)
            auditService.logApproval(savedRequest, requester, clientIp)
            logger.info("Auto-approved exception request: requestId={}, userId={}", savedRequest.id, requesterUserId)
        } else {
            logger.info("Created pending exception request: requestId={}, userId={}", savedRequest.id, requesterUserId)
            // Publish count change event for real-time badge update (pending count increased)
            publishCountChangeEvent()

            // Send email notifications to ADMIN/SECCHAMPION users (Phase 10)
            try {
                notificationService.notifyAdminsOfNewRequest(savedRequest)
            } catch (e: Exception) {
                logger.error("Failed to send notification for new request {}: {}", savedRequest.id, e.message)
                // Do not throw - email failures should not block request creation
            }
        }

        return toDto(savedRequest)
    }

    /**
     * Approve a pending exception request.
     *
     * Creates corresponding VulnerabilityException on successful approval.
     * Uses optimistic locking to prevent concurrent approvals.
     *
     * @param requestId ID of the request to approve
     * @param reviewerUserId ID of the reviewer (ADMIN or SECCHAMPION)
     * @param reviewDto Optional review comment
     * @param clientIp Client IP address for audit logging (optional)
     * @return Updated request DTO
     * @throws ConcurrentApprovalException if request already reviewed by another user
     * @throws IllegalStateException if request not in PENDING status
     */
    @Transactional
    open fun approveRequest(
        requestId: Long,
        reviewerUserId: Long,
        reviewDto: ReviewExceptionRequestDto?,
        clientIp: String? = null
    ): VulnerabilityExceptionRequestDto {
        logger.debug("Approving exception request: requestId={}, reviewerId={}", requestId, reviewerUserId)

        val request = requestRepository.findById(requestId).orElseThrow {
            IllegalArgumentException("Exception request with ID $requestId not found")
        }

        val reviewer = userRepository.findById(reviewerUserId).orElseThrow {
            IllegalArgumentException("User with ID $reviewerUserId not found")
        }

        // Validate status transition
        if (!request.canTransitionTo(ExceptionRequestStatus.APPROVED)) {
            throw IllegalStateException(
                "Cannot approve request in ${request.status} status. Only PENDING requests can be approved."
            )
        }

        try {
            // Update request status (optimistic lock check happens here)
            request.status = ExceptionRequestStatus.APPROVED
            request.reviewedByUser = reviewer
            request.reviewedByUsername = reviewer.username
            request.reviewDate = LocalDateTime.now()
            request.reviewComment = reviewDto?.reviewComment?.let { sanitizeInput(it) }

            val updatedRequest = requestRepository.update(request)

            // Create corresponding VulnerabilityException
            createExceptionFromRequest(updatedRequest)

            // Log approval
            auditService.logApproval(updatedRequest, reviewer, clientIp)

            logger.info("Approved exception request: requestId={}, reviewerId={}", requestId, reviewerUserId)

            // Publish count change event for real-time badge update (pending count decreased)
            publishCountChangeEvent()

            // Send email notification to requester (Phase 10)
            try {
                notificationService.notifyRequesterOfApproval(updatedRequest)
            } catch (e: Exception) {
                logger.error("Failed to send approval notification for request {}: {}", requestId, e.message)
                // Do not throw - email failures should not block approval workflow
            }

            return toDto(updatedRequest)

        } catch (e: OptimisticLockException) {
            // Concurrent modification detected - another user already reviewed this request
            handleOptimisticLockFailure(requestId, "approve")
        }
    }

    /**
     * Reject a pending exception request.
     *
     * Does NOT create VulnerabilityException.
     * Uses optimistic locking to prevent concurrent reviews.
     *
     * @param requestId ID of the request to reject
     * @param reviewerUserId ID of the reviewer (ADMIN or SECCHAMPION)
     * @param reviewDto Review comment (REQUIRED for rejection, minimum 10 characters)
     * @param clientIp Client IP address for audit logging (optional)
     * @return Updated request DTO
     * @throws ConcurrentApprovalException if request already reviewed by another user
     * @throws IllegalArgumentException if review comment missing or too short
     * @throws IllegalStateException if request not in PENDING status
     */
    @Transactional
    open fun rejectRequest(
        requestId: Long,
        reviewerUserId: Long,
        reviewDto: ReviewExceptionRequestDto,
        clientIp: String? = null
    ): VulnerabilityExceptionRequestDto {
        logger.debug("Rejecting exception request: requestId={}, reviewerId={}", requestId, reviewerUserId)

        // Validate review comment (required for rejection, minimum 10 characters)
        if (reviewDto.reviewComment.isNullOrBlank()) {
            throw IllegalArgumentException("Review comment is required for rejection")
        }
        if (reviewDto.reviewComment.length < 10) {
            throw IllegalArgumentException("Review comment must be at least 10 characters")
        }

        val request = requestRepository.findById(requestId).orElseThrow {
            IllegalArgumentException("Exception request with ID $requestId not found")
        }

        val reviewer = userRepository.findById(reviewerUserId).orElseThrow {
            IllegalArgumentException("User with ID $reviewerUserId not found")
        }

        // Validate status transition
        if (!request.canTransitionTo(ExceptionRequestStatus.REJECTED)) {
            throw IllegalStateException(
                "Cannot reject request in ${request.status} status. Only PENDING requests can be rejected."
            )
        }

        try {
            // Update request status (optimistic lock check happens here)
            request.status = ExceptionRequestStatus.REJECTED
            request.reviewedByUser = reviewer
            request.reviewedByUsername = reviewer.username
            request.reviewDate = LocalDateTime.now()
            request.reviewComment = sanitizeInput(reviewDto.reviewComment)

            val updatedRequest = requestRepository.update(request)

            // Log rejection
            auditService.logRejection(updatedRequest, reviewer, clientIp)

            logger.info("Rejected exception request: requestId={}, reviewerId={}, comment={}",
                requestId, reviewerUserId, reviewDto.reviewComment?.take(50))

            // Publish count change event for real-time badge update (pending count decreased)
            publishCountChangeEvent()

            // Send email notification to requester (Phase 10)
            try {
                notificationService.notifyRequesterOfRejection(updatedRequest)
            } catch (e: Exception) {
                logger.error("Failed to send rejection notification for request {}: {}", requestId, e.message)
                // Do not throw - email failures should not block rejection workflow
            }

            return toDto(updatedRequest)

        } catch (e: OptimisticLockException) {
            // Concurrent modification detected
            handleOptimisticLockFailure(requestId, "reject")
        }
    }

    /**
     * Cancel a pending exception request (requester only).
     *
     * @param requestId ID of the request to cancel
     * @param requesterUserId ID of the user cancelling (must be original requester)
     * @param clientIp Client IP address for audit logging (optional)
     * @throws IllegalArgumentException if user is not the requester
     * @throws IllegalStateException if request not in PENDING status
     */
    @Transactional
    open fun cancelRequest(
        requestId: Long,
        requesterUserId: Long,
        clientIp: String? = null
    ): VulnerabilityExceptionRequestDto {
        logger.debug("Cancelling exception request: requestId={}, userId={}", requestId, requesterUserId)

        val request = requestRepository.findById(requestId).orElseThrow {
            IllegalArgumentException("Exception request with ID $requestId not found")
        }

        val user = userRepository.findById(requesterUserId).orElseThrow {
            IllegalArgumentException("User with ID $requesterUserId not found")
        }

        // Validate ownership
        if (request.requestedByUser?.id != requesterUserId) {
            throw IllegalArgumentException("Only the original requester can cancel this request")
        }

        // Validate status and auto-approval for APPROVED requests
        if (!request.canTransitionTo(ExceptionRequestStatus.CANCELLED)) {
            throw IllegalStateException(
                "Cannot cancel request in ${request.status} status. Only PENDING requests can be cancelled."
            )
        }

        // Additional validation for APPROVED requests
        if (request.status == ExceptionRequestStatus.APPROVED && !request.autoApproved) {
            throw IllegalStateException(
                "Cannot cancel manually approved requests. Only auto-approved requests can be revoked by the requester."
            )
        }

        // If cancelling an auto-approved request, delete the associated VulnerabilityException
        if (request.status == ExceptionRequestStatus.APPROVED && request.autoApproved) {
            deleteExceptionForRequest(request)
            logger.info("Deleted VulnerabilityException for auto-approved request: requestId={}", requestId)
        }

        // Update status
        request.status = ExceptionRequestStatus.CANCELLED
        val updatedRequest = requestRepository.update(request)

        // Log cancellation
        auditService.logCancellation(updatedRequest, user, clientIp)

        logger.info("Cancelled exception request: requestId={}, userId={}, autoApproved={}",
            requestId, requesterUserId, request.autoApproved)

        // Publish count change event for real-time badge update (only if was PENDING)
        publishCountChangeEvent()

        return toDto(updatedRequest)
    }

    /**
     * Get exception request by ID.
     *
     * @param requestId ID of the request
     * @return Request DTO
     */
    fun getRequestById(requestId: Long): VulnerabilityExceptionRequestDto {
        val request = requestRepository.findById(requestId).orElseThrow {
            IllegalArgumentException("Exception request with ID $requestId not found")
        }
        return toDto(request)
    }

    /**
     * Get all exception requests for a specific user (requester).
     *
     * @param userId ID of the requesting user
     * @param status Optional status filter
     * @param pageable Pagination parameters
     * @return Paginated list of user's requests
     */
    fun getUserRequests(
        userId: Long,
        status: ExceptionRequestStatus?,
        pageable: Pageable
    ): Page<VulnerabilityExceptionRequestDto> {
        val requests = if (status != null) {
            requestRepository.findByRequestedByUserIdAndStatus(userId, status, pageable)
        } else {
            requestRepository.findByRequestedByUserId(userId, pageable)
        }

        return requests.map { toDto(it) }
    }

    /**
     * Get summary statistics for a user's exception requests.
     *
     * @param userId ID of the user
     * @return Summary statistics DTO
     */
    fun getUserRequestSummary(userId: Long): ExceptionRequestSummaryDto {
        val totalRequests = requestRepository.countByRequestedByUserId(userId)
        val approvedCount = requestRepository.countByRequestedByUserIdAndStatus(userId, ExceptionRequestStatus.APPROVED)
        val pendingCount = requestRepository.countByRequestedByUserIdAndStatus(userId, ExceptionRequestStatus.PENDING)
        val rejectedCount = requestRepository.countByRequestedByUserIdAndStatus(userId, ExceptionRequestStatus.REJECTED)
        val expiredCount = requestRepository.countByRequestedByUserIdAndStatus(userId, ExceptionRequestStatus.EXPIRED)
        val cancelledCount = requestRepository.countByRequestedByUserIdAndStatus(userId, ExceptionRequestStatus.CANCELLED)

        return ExceptionRequestSummaryDto(
            totalRequests = totalRequests,
            approvedCount = approvedCount,
            pendingCount = pendingCount,
            rejectedCount = rejectedCount,
            expiredCount = expiredCount,
            cancelledCount = cancelledCount
        )
    }

    /**
     * Get all pending exception requests (for ADMIN/SECCHAMPION approval dashboard).
     *
     * @param pageable Pagination parameters (sorted by oldest first)
     * @return Paginated list of pending requests
     */
    fun getPendingRequests(pageable: Pageable): Page<VulnerabilityExceptionRequestDto> {
        return requestRepository.findByStatus(ExceptionRequestStatus.PENDING, pageable)
            .map { toDto(it) }
    }

    /**
     * Get count of pending exception requests (for badge display).
     *
     * @return Count of pending requests
     */
    fun getPendingCount(): Long {
        return requestRepository.countByStatus(ExceptionRequestStatus.PENDING)
    }

    /**
     * Create VulnerabilityException from approved request.
     *
     * Logic:
     * - SINGLE_VULNERABILITY scope → Create ASSET-type exception (asset_id = request.vulnerability.asset.id)
     * - CVE_PATTERN scope → Create PRODUCT-type exception (target_value = request.vulnerability.cveId)
     *
     * @param request The approved exception request
     */
    private fun createExceptionFromRequest(request: VulnerabilityExceptionRequest) {
        if (request.vulnerability == null) {
            logger.warn("Cannot create exception: vulnerability is null for requestId={}", request.id)
            return
        }

        val exception = when (request.scope) {
            ExceptionScope.SINGLE_VULNERABILITY -> {
                // Create ASSET-type exception for this specific asset
                VulnerabilityException(
                    exceptionType = VulnerabilityException.ExceptionType.ASSET,
                    targetValue = request.vulnerability!!.asset.name, // Asset name for display
                    assetId = request.vulnerability!!.asset.id,
                    expirationDate = request.expirationDate,
                    reason = request.reason,
                    createdBy = request.reviewedByUsername ?: request.requestedByUsername
                )
            }
            ExceptionScope.CVE_PATTERN -> {
                // Create PRODUCT-type exception matching CVE pattern across all assets
                VulnerabilityException(
                    exceptionType = VulnerabilityException.ExceptionType.PRODUCT,
                    targetValue = request.vulnerability!!.vulnerabilityId ?: "UNKNOWN_CVE",
                    expirationDate = request.expirationDate,
                    reason = request.reason,
                    createdBy = request.reviewedByUsername ?: request.requestedByUsername
                )
            }
        }

        vulnerabilityExceptionRepository.save(exception)

        logger.info(
            "Created VulnerabilityException from request: requestId={}, exceptionId={}, type={}, scope={}",
            request.id, exception.id, exception.exceptionType, request.scope
        )
    }

    /**
     * Delete VulnerabilityException associated with a request (for auto-approval revocation).
     *
     * Logic:
     * - SINGLE_VULNERABILITY scope → Delete ASSET-type exception matching asset + expiration + reason
     * - CVE_PATTERN scope → Delete PRODUCT-type exception matching CVE + expiration + reason
     *
     * @param request The exception request to delete exceptions for
     */
    private fun deleteExceptionForRequest(request: VulnerabilityExceptionRequest) {
        if (request.vulnerability == null) {
            logger.warn("Cannot delete exceptions: vulnerability is null for requestId={}", request.id)
            return
        }

        try {
            when (request.scope) {
                ExceptionScope.SINGLE_VULNERABILITY -> {
                    // Find ASSET-type exceptions matching this asset
                    val assetId = request.vulnerability!!.asset.id
                    val exceptions = vulnerabilityExceptionRepository.findByExceptionTypeAndAssetId(
                        VulnerabilityException.ExceptionType.ASSET,
                        assetId!!
                    )

                    for (exception in exceptions) {
                        // Check if this exception was created for this request
                        // (matches expiration date and reason)
                        if (exception.expirationDate == request.expirationDate &&
                            exception.reason == request.reason
                        ) {
                            vulnerabilityExceptionRepository.delete(exception)
                            logger.debug("Deleted ASSET exception {} for asset {}", exception.id, assetId)
                        }
                    }
                }

                ExceptionScope.CVE_PATTERN -> {
                    // Find PRODUCT-type exceptions matching this CVE
                    val cveId = request.vulnerability!!.vulnerabilityId ?: return
                    val exceptions = vulnerabilityExceptionRepository.findByExceptionTypeAndTargetValue(
                        VulnerabilityException.ExceptionType.PRODUCT,
                        cveId
                    )

                    for (exception in exceptions) {
                        // Check if this exception was created for this request
                        if (exception.expirationDate == request.expirationDate &&
                            exception.reason == request.reason
                        ) {
                            vulnerabilityExceptionRepository.delete(exception)
                            logger.debug("Deleted PRODUCT exception {} for CVE {}", exception.id, cveId)
                        }
                    }
                }
            }
        } catch (e: Exception) {
            logger.error("Error deleting exceptions for request {}: {}", request.id, e.message, e)
            throw IllegalStateException("Failed to delete associated exception: ${e.message}")
        }
    }

    /**
     * Check for duplicate active requests (PENDING or APPROVED) for the same vulnerability.
     *
     * @param vulnerabilityId ID of the vulnerability
     * @throws IllegalArgumentException if active request already exists
     */
    private fun checkForDuplicateActiveRequest(vulnerabilityId: Long) {
        val activeStatuses = listOf(ExceptionRequestStatus.PENDING, ExceptionRequestStatus.APPROVED)
        val existingRequests = requestRepository.findByVulnerabilityIdAndStatusIn(vulnerabilityId, activeStatuses)

        if (existingRequests.isNotEmpty()) {
            val existing = existingRequests.first()
            throw IllegalArgumentException(
                "This vulnerability already has an active exception request " +
                "(Status: ${existing.status}, Expires: ${existing.expirationDate}). " +
                "You cannot request another exception until the current one expires or is cancelled."
            )
        }
    }

    /**
     * Handle optimistic lock failure by fetching current state and throwing ConcurrentApprovalException.
     *
     * @param requestId ID of the request
     * @param action Action that was attempted ("approve" or "reject")
     * @throws ConcurrentApprovalException Always throws with current state details
     */
    private fun handleOptimisticLockFailure(requestId: Long, action: String): Nothing {
        // Fetch current state to inform user who won the race
        val currentState = requestRepository.findById(requestId).orElseThrow {
            IllegalStateException("Request $requestId not found after optimistic lock failure")
        }

        logger.warn(
            "Concurrent approval conflict on request {}: attempted to {}, but already {} by {} at {}",
            requestId, action, currentState.status, currentState.reviewedByUsername, currentState.reviewDate
        )

        throw ConcurrentApprovalException(
            reviewedBy = currentState.reviewedByUsername ?: "Unknown",
            reviewedAt = currentState.reviewDate ?: LocalDateTime.now(),
            currentStatus = currentState.status,
            requestId = requestId
        )
    }

    /**
     * Publish ExceptionCountChangedEvent for real-time badge updates.
     *
     * Queries current pending count and publishes event to SSE subscribers.
     * Called after operations that change pending count (create, approve, reject, cancel).
     *
     * **Phase 6: Real-Time Badge Updates**
     */
    private fun publishCountChangeEvent() {
        val currentCount = requestRepository.countByStatus(ExceptionRequestStatus.PENDING)
        val event = ExceptionCountChangedEvent(currentCount, this)
        eventPublisher.publishEvent(event)
        logger.debug("Published ExceptionCountChangedEvent: pendingCount={}", currentCount)
    }

    /**
     * Sanitize user input to prevent XSS attacks.
     *
     * Removes HTML tags and normalizes whitespace.
     * Prevents XSS by stripping potentially dangerous content.
     *
     * @param input Raw user input
     * @return Sanitized text safe for storage and display
     */
    private fun sanitizeInput(input: String): String {
        // Strip HTML tags using regex
        val withoutHtml = input.replace(Regex("<[^>]*>"), "")

        // Normalize whitespace (but preserve line breaks for reason/comment formatting)
        val normalized = withoutHtml
            .replace(Regex("\\r\\n|\\r"), "\n")  // Normalize line endings
            .replace(Regex(" +"), " ")  // Collapse multiple spaces
            .trim()

        return normalized
    }

    /**
     * Convert entity to DTO.
     *
     * @param request The exception request entity
     * @return Request DTO with embedded vulnerability info
     */
    private fun toDto(request: VulnerabilityExceptionRequest): VulnerabilityExceptionRequestDto {
        return VulnerabilityExceptionRequestDto(
            id = request.id!!,
            vulnerabilityId = request.vulnerability?.id,
            vulnerabilityCve = request.vulnerability?.vulnerabilityId,
            assetName = request.vulnerability?.asset?.name,
            assetIp = request.vulnerability?.asset?.ip,
            requestedByUsername = request.requestedByUsername,
            scope = request.scope,
            reason = request.reason,
            expirationDate = request.expirationDate,
            status = request.status,
            autoApproved = request.autoApproved,
            reviewedByUsername = request.reviewedByUsername,
            reviewDate = request.reviewDate,
            reviewComment = request.reviewComment,
            createdAt = request.createdAt!!,
            updatedAt = request.updatedAt!!
        )
    }
}
