package com.secman.service

import com.secman.repository.VulnerabilityRepository
import io.micronaut.security.authentication.Authentication
import jakarta.inject.Singleton
import jakarta.persistence.EntityManager
import jakarta.transaction.Transactional
import java.time.LocalDate
import java.time.LocalDateTime
import java.time.LocalTime

/**
 * Service for vulnerability statistics with unified access control
 *
 * Responsibilities:
 * - Provide aggregated vulnerability statistics (most common, severity distribution, etc.)
 * - Apply unified access control (workgroups, domain mappings, AWS account mappings)
 * - Support multiple statistical views: by vulnerability, by severity, by asset, by time
 *
 * Feature: 036-vuln-stats-lense, 043-crowdstrike-domain-import
 * Task: T004
 * User Stories: US1-US4 (All statistics user stories)
 * Spec reference: spec.md FR-001 through FR-015
 *
 * Access Control: Uses unified access control model via AssetFilterService
 * - ADMIN: Sees all vulnerabilities
 * - Non-admin: Sees vulnerabilities from accessible assets based on:
 *   - Workgroup membership
 *   - Domain mappings (UserMapping.domain matches Asset.adDomain)
 *   - AWS account mappings (UserMapping.awsAccountId matches Asset.cloudAccountId)
 *   - Manual asset creation
 *   - Scan uploads
 */
@Singleton
open class VulnerabilityStatisticsService(
    private val vulnerabilityRepository: VulnerabilityRepository,
    private val assetFilterService: AssetFilterService,
    private val entityManager: EntityManager
) {

    /**
     * Check if user has ADMIN role
     *
     * ADMIN users bypass access filtering and see all statistics
     *
     * @param authentication Current user authentication context
     * @return true if user has ADMIN role, false otherwise
     */
    private fun isAdmin(authentication: Authentication): Boolean {
        return authentication.roles.contains("ADMIN")
    }

    /**
     * Get asset IDs accessible to the current user using unified access control
     *
     * Uses AssetFilterService to apply unified access control model:
     * - Workgroup membership
     * - Domain mappings (AD domains)
     * - AWS account mappings
     * - Manual asset creation
     * - Scan uploads
     *
     * @param authentication Current user authentication context
     * @return Set of accessible asset IDs, or null if user is ADMIN (sees all)
     */
    private fun getAccessibleAssetIds(authentication: Authentication): Set<Long>? {
        if (isAdmin(authentication)) {
            // ADMIN sees all - return null to indicate no filtering needed
            return null
        }

        // Use AssetFilterService to get accessible assets with unified access control
        val accessibleAssets = assetFilterService.getAccessibleAssets(authentication)
        return accessibleAssets.mapNotNull { it.id }.toSet()
    }

    /**
     * Get available domains for filtering from user's accessible assets
     *
     * Returns list of unique AD domains from assets the user has access to.
     * Used to populate the domain selector dropdown.
     *
     * Feature: 059-vuln-stats-domain-filter
     * Task: T002
     * Spec reference: spec.md FR-002
     *
     * @param authentication Current user authentication context
     * @return AvailableDomainsDto with sorted domain list and asset count
     */
    fun getAvailableDomains(authentication: Authentication): com.secman.dto.AvailableDomainsDto {
        // Use existing access control - getAccessibleAssets handles ADMIN case internally
        val accessibleAssets = assetFilterService.getAccessibleAssets(authentication)

        // Extract unique domains (non-null, normalized to lowercase)
        val domains = accessibleAssets
            .mapNotNull { it.adDomain }
            .filter { it.isNotBlank() }
            .map { it.lowercase() }
            .distinct()
            .sorted()

        // Count assets with domains
        val totalAssetCount = accessibleAssets.count { !it.adDomain.isNullOrBlank() }

        return com.secman.dto.AvailableDomainsDto(
            domains = domains,
            totalAssetCount = totalAssetCount
        )
    }

    /**
     * Get accessible asset IDs with optional domain filter
     *
     * Applies domain filter on top of existing access control.
     * Domain filter NEVER bypasses RBAC - it's an additional constraint.
     *
     * Feature: 059-vuln-stats-domain-filter
     * Task: T002
     *
     * @param authentication Current user authentication context
     * @param domain Optional domain filter (null = all domains)
     * @return Set of accessible asset IDs, or null if user is ADMIN with no domain filter
     */
    private fun getAccessibleAssetIdsWithDomain(authentication: Authentication, domain: String?): Set<Long>? {
        // Get base accessible assets
        val baseAssetIds = getAccessibleAssetIds(authentication)

        // If no domain filter, return base result
        if (domain.isNullOrBlank()) {
            return baseAssetIds
        }

        // Normalize domain to lowercase for comparison
        val normalizedDomain = domain.lowercase()

        // Get accessible assets (getAccessibleAssets handles ADMIN case internally)
        val accessibleAssets = assetFilterService.getAccessibleAssets(authentication)

        // Filter by domain
        return accessibleAssets
            .filter { it.adDomain?.lowercase() == normalizedDomain }
            .mapNotNull { it.id }
            .toSet()
    }

    /**
     * Get most common vulnerabilities with unified access control and optional domain filter
     *
     * Returns top 10 vulnerabilities ranked by occurrence frequency across accessible assets.
     * Access control:
     * - ADMIN role: sees all vulnerabilities (no filtering)
     * - Non-admin: sees vulnerabilities from accessible assets (workgroups, domains, AWS accounts, etc.)
     *
     * Feature: 036-vuln-stats-lense, 043-crowdstrike-domain-import, 059-vuln-stats-domain-filter
     * Task: T013 [US1], T004 (domain filter)
     * Spec reference: spec.md FR-001, FR-002, FR-006
     * User Story: US1 - View Most Common Vulnerabilities (P1)
     *
     * @param authentication Current user authentication context
     * @param domain Optional AD domain filter (null = all domains). Case-insensitive.
     * @return List of most common vulnerabilities (max 10) with occurrence counts
     */
    fun getMostCommonVulnerabilities(authentication: Authentication, domain: String? = null): List<com.secman.dto.MostCommonVulnerabilityDto> {
        val accessibleAssetIds = getAccessibleAssetIdsWithDomain(authentication, domain)

        val rawResults = if (accessibleAssetIds == null) {
            // ADMIN sees all vulnerabilities (with no domain filter)
            vulnerabilityRepository.findMostCommonVulnerabilitiesForAll()
        } else if (accessibleAssetIds.isEmpty()) {
            // User has no accessible assets (or no assets in selected domain) - return empty list
            return emptyList()
        } else {
            // User sees vulnerabilities from accessible assets (unified access control + domain filter)
            vulnerabilityRepository.findMostCommonVulnerabilitiesForAssets(accessibleAssetIds)
        }

        // Transform raw results into DTOs
        return rawResults.map { row ->
            com.secman.dto.MostCommonVulnerabilityDto(
                vulnerabilityId = row.vulnerabilityId ?: "",
                cvssSeverity = row.cvssSeverity ?: "UNKNOWN",
                occurrenceCount = row.occurrenceCount?.toLong() ?: 0L,
                affectedAssetCount = row.affectedAssetCount?.toLong() ?: 0L
            )
        }
    }

    /**
     * Get most vulnerable products with unified access control and optional domain filter
     *
     * Returns top 10 products ranked by distinct vulnerability count across accessible assets.
     * Access control:
     * - ADMIN role: sees all vulnerabilities (no filtering)
     * - Non-admin: sees vulnerabilities from accessible assets (workgroups, domains, AWS accounts, etc.)
     *
     * Feature: 036-vuln-stats-lense, 059-vuln-stats-domain-filter
     * Task: T005 (domain filter)
     * Spec reference: spec.md
     *
     * @param authentication Current user authentication context
     * @param domain Optional AD domain filter (null = all domains). Case-insensitive.
     * @return List of most vulnerable products (max 10) with vulnerability counts
     */
    fun getMostVulnerableProducts(authentication: Authentication, domain: String? = null): List<com.secman.dto.MostVulnerableProductDto> {
        val accessibleAssetIds = getAccessibleAssetIdsWithDomain(authentication, domain)

        val rawResults = if (accessibleAssetIds == null) {
            // ADMIN sees all vulnerabilities (with no domain filter)
            vulnerabilityRepository.findMostVulnerableProductsForAll()
        } else if (accessibleAssetIds.isEmpty()) {
            // User has no accessible assets (or no assets in selected domain) - return empty list
            return emptyList()
        } else {
            // User sees vulnerabilities from accessible assets (unified access control + domain filter)
            vulnerabilityRepository.findMostVulnerableProductsForAssets(accessibleAssetIds)
        }

        // Transform raw results into DTOs
        return rawResults.map { row ->
            com.secman.dto.MostVulnerableProductDto(
                product = row.product ?: "",
                vulnerabilityCount = row.vulnerabilityCount?.toLong() ?: 0L,
                affectedAssetCount = row.affectedAssetCount?.toLong() ?: 0L,
                criticalCount = row.criticalCount?.toLong() ?: 0L,
                highCount = row.highCount?.toLong() ?: 0L
            )
        }
    }

    /**
     * Get severity distribution with unified access control and optional domain filter
     *
     * Returns vulnerability counts grouped by CVSS severity level (CRITICAL, HIGH, MEDIUM, LOW, UNKNOWN).
     * Includes computed percentage properties for each severity level.
     * Access control:
     * - ADMIN role: sees all vulnerabilities (no filtering)
     * - Non-admin: sees vulnerabilities from accessible assets (workgroups, domains, AWS accounts, etc.)
     *
     * Feature: 036-vuln-stats-lense, 043-crowdstrike-domain-import, 059-vuln-stats-domain-filter
     * Task: T023 [US2], T006 (domain filter)
     * Spec reference: spec.md FR-003, FR-004, FR-006
     * User Story: US2 - View Severity Distribution (P2)
     *
     * @param authentication Current user authentication context
     * @param domain Optional AD domain filter (null = all domains). Case-insensitive.
     * @return SeverityDistributionDto with counts and percentages for each severity level
     */
    fun getSeverityDistribution(authentication: Authentication, domain: String? = null): com.secman.dto.SeverityDistributionDto {
        val accessibleAssetIds = getAccessibleAssetIdsWithDomain(authentication, domain)

        // Get raw severity counts from repository
        val rawResults = if (accessibleAssetIds == null) {
            vulnerabilityRepository.findSeverityDistributionForAll()
        } else if (accessibleAssetIds.isEmpty()) {
            // User has no accessible assets (or no assets in selected domain) - return empty results
            emptyList()
        } else {
            vulnerabilityRepository.findSeverityDistributionForAssets(accessibleAssetIds)
        }

        // Aggregate results into severity counts
        var criticalCount = 0L
        var highCount = 0L
        var mediumCount = 0L
        var lowCount = 0L
        var unknownCount = 0L

        rawResults.forEach { row ->
            val severity = row["severity"] as? String ?: "UNKNOWN"
            val count = (row["count"] as? Number)?.toLong() ?: 0L

            when (severity.uppercase()) {
                "CRITICAL" -> criticalCount = count
                "HIGH" -> highCount = count
                "MEDIUM" -> mediumCount = count
                "LOW" -> lowCount = count
                "UNKNOWN" -> unknownCount = count
            }
        }

        return com.secman.dto.SeverityDistributionDto(
            critical = criticalCount,
            high = highCount,
            medium = mediumCount,
            low = lowCount,
            unknown = unknownCount
        )
    }

    /**
     * Get top assets ranked by vulnerability count with unified access control and optional domain filter
     *
     * Returns top 10 assets ranked by total vulnerability count with severity breakdowns.
     * Access control:
     * - ADMIN role: sees all assets (no filtering)
     * - Non-admin: sees accessible assets (workgroups, domains, AWS accounts, etc.)
     *
     * Feature: 036-vuln-stats-lense, 043-crowdstrike-domain-import, 059-vuln-stats-domain-filter
     * Task: T033 [US3]
     * Spec reference: spec.md FR-005, FR-006
     * User Story: US3 - View Asset Vulnerability Statistics (P3)
     *
     * @param authentication Current user authentication context
     * @param domain Optional AD domain filter (null = all domains). Case-insensitive.
     * @return List of top 10 assets with vulnerability counts and severity breakdowns
     */
    fun getTopAssetsByVulnerabilities(authentication: Authentication, domain: String? = null): List<com.secman.dto.TopAssetByVulnerabilitiesDto> {
        val accessibleAssetIds = getAccessibleAssetIdsWithDomain(authentication, domain)

        val rawResults = if (accessibleAssetIds == null) {
            // ADMIN sees all assets
            vulnerabilityRepository.findTopAssetsByVulnerabilitiesForAll()
        } else if (accessibleAssetIds.isEmpty()) {
            // User has no accessible assets - return empty list
            return emptyList()
        } else {
            // Non-admin user sees accessible assets (unified access control)
            vulnerabilityRepository.findTopAssetsByVulnerabilitiesForAssets(accessibleAssetIds)
        }

        // Transform raw results into DTOs
        return rawResults.map { row ->
            com.secman.dto.TopAssetByVulnerabilitiesDto(
                assetId = (row["assetId"] as? Number)?.toLong() ?: 0L,
                assetName = row["assetName"] as? String ?: "",
                assetType = row["assetType"] as? String,
                assetIp = row["assetIp"] as? String,
                totalVulnerabilityCount = (row["totalVulnerabilityCount"] as? Number)?.toLong() ?: 0L,
                criticalCount = (row["criticalCount"] as? Number)?.toLong() ?: 0L,
                highCount = (row["highCount"] as? Number)?.toLong() ?: 0L,
                mediumCount = (row["mediumCount"] as? Number)?.toLong() ?: 0L,
                lowCount = (row["lowCount"] as? Number)?.toLong() ?: 0L
            )
        }
    }

    /**
     * Get vulnerability statistics grouped by asset type with unified access control
     *
     * Returns vulnerability counts aggregated by asset type (Server, Workstation, etc.) with
     * severity breakdowns and average vulnerabilities per asset.
     * Access control:
     * - ADMIN role: sees all asset types (no filtering)
     * - Non-admin: sees asset types from accessible assets (workgroups, domains, AWS accounts, etc.)
     *
     * Feature: 036-vuln-stats-lense, 043-crowdstrike-domain-import
     * Task: T037 [US3]
     * Spec reference: spec.md FR-007, FR-008
     * User Story: US3 - View Asset Vulnerability Statistics (P3)
     *
     * @param authentication Current user authentication context
     * @return List of asset types with vulnerability statistics
     */
    fun getVulnerabilitiesByAssetType(authentication: Authentication): List<com.secman.dto.VulnerabilityByAssetTypeDto> {
        val accessibleAssetIds = getAccessibleAssetIds(authentication)

        // Get raw results from repository
        val rawResults = if (accessibleAssetIds == null) {
            vulnerabilityRepository.findVulnerabilitiesByAssetTypeForAll()
        } else if (accessibleAssetIds.isEmpty()) {
            // User has no accessible assets - return empty results
            return emptyList()
        } else {
            vulnerabilityRepository.findVulnerabilitiesByAssetTypeForAssets(accessibleAssetIds)
        }

        // Transform raw results into DTOs
        return rawResults.map { row ->
            com.secman.dto.VulnerabilityByAssetTypeDto(
                assetType = row["assetType"] as String,
                assetCount = (row["assetCount"] as? Number)?.toLong() ?: 0L,
                totalVulnerabilityCount = (row["totalVulnerabilityCount"] as? Number)?.toLong() ?: 0L,
                criticalCount = (row["criticalCount"] as? Number)?.toLong() ?: 0L,
                highCount = (row["highCount"] as? Number)?.toLong() ?: 0L,
                mediumCount = (row["mediumCount"] as? Number)?.toLong() ?: 0L,
                lowCount = (row["lowCount"] as? Number)?.toLong() ?: 0L,
                averageVulnerabilitiesPerAsset = (row["avgVulnsPerAsset"] as? Number)?.toDouble() ?: 0.0
            )
        }
    }

    /**
     * Get temporal vulnerability trends with unified access control
     *
     * Returns time-series data showing vulnerability counts over specified time period (30, 60, or 90 days).
     * Access control:
     * - ADMIN role: sees all vulnerabilities (no filtering)
     * - Non-admin: sees vulnerabilities from accessible assets (workgroups, domains, AWS accounts, etc.)
     *
     * Feature: 036-vuln-stats-lense, 043-crowdstrike-domain-import
     * Task: T049 [US4]
     * Spec reference: spec.md FR-009, FR-010, FR-011
     * User Story: US4 - View Temporal Trends (P4)
     *
     * @param authentication Current user authentication context
     * @param days Number of days to analyze (30, 60, or 90)
     * @return TemporalTrendsDto with daily data points
     * @throws IllegalArgumentException if days is not 30, 60, or 90
     */
    fun getTemporalTrends(authentication: Authentication, days: Int): com.secman.dto.TemporalTrendsDto {
        // Validate days parameter
        if (days !in listOf(30, 60, 90)) {
            throw IllegalArgumentException("Days parameter must be 30, 60, or 90")
        }

        // Calculate date range
        val endDate = LocalDate.now()
        val startDate = endDate.minusDays(days.toLong())
        val startDateTime = LocalDateTime.of(startDate, LocalTime.MIN)

        val accessibleAssetIds = getAccessibleAssetIds(authentication)

        // Get raw results from repository
        val rawResults = if (accessibleAssetIds == null) {
            vulnerabilityRepository.findTemporalTrendsForAll(startDateTime)
        } else if (accessibleAssetIds.isEmpty()) {
            // User has no accessible assets - return empty results
            emptyList()
        } else {
            vulnerabilityRepository.findTemporalTrendsForAssets(accessibleAssetIds, startDateTime)
        }

        // Transform raw results into data points
        val dataPoints = rawResults.map { row ->
            com.secman.dto.TemporalTrendDataPointDto(
                date = (row["date"] as java.sql.Date).toLocalDate(),
                totalCount = (row["totalCount"] as? Number)?.toLong() ?: 0L,
                criticalCount = (row["criticalCount"] as? Number)?.toLong() ?: 0L,
                highCount = (row["highCount"] as? Number)?.toLong() ?: 0L,
                mediumCount = (row["mediumCount"] as? Number)?.toLong() ?: 0L,
                lowCount = (row["lowCount"] as? Number)?.toLong() ?: 0L
            )
        }

        return com.secman.dto.TemporalTrendsDto(
            startDate = startDate,
            endDate = endDate,
            days = days,
            dataPoints = dataPoints
        )
    }

    /**
     * Get affected assets for a specific CVE with access control and optional domain filter
     *
     * Returns list of assets affected by the specified CVE, filtered by:
     * - User's access control (workgroups, domain mappings, AWS accounts, etc.)
     * - Optional domain filter
     *
     * @param authentication Current user authentication context
     * @param cveId The CVE identifier (e.g., "CVE-2024-12345")
     * @param domain Optional AD domain filter (null = all domains). Case-insensitive.
     * @return AffectedAssetsByCveDto with list of affected assets (max 100)
     */
    @Transactional
    open fun getAffectedAssetsByCve(
        authentication: Authentication,
        cveId: String,
        domain: String? = null
    ): com.secman.dto.AffectedAssetsByCveDto {
        val accessibleAssetIds = getAccessibleAssetIdsWithDomain(authentication, domain)

        val rawResults: List<Array<Any?>> = if (accessibleAssetIds == null) {
            // ADMIN sees all assets (with no domain filter)
            @Suppress("UNCHECKED_CAST")
            entityManager.createNativeQuery(
                """
                SELECT DISTINCT
                    a.id,
                    a.name,
                    a.ip,
                    a.ad_domain,
                    a.type
                FROM vulnerability v
                JOIN asset a ON v.asset_id = a.id
                WHERE v.vulnerability_id = :cveId
                ORDER BY a.name
                LIMIT 100
                """
            ).setParameter("cveId", cveId).resultList as List<Array<Any?>>
        } else if (accessibleAssetIds.isEmpty()) {
            // User has no accessible assets - return empty list
            emptyList()
        } else {
            // User sees assets within their access scope + domain filter
            @Suppress("UNCHECKED_CAST")
            entityManager.createNativeQuery(
                """
                SELECT DISTINCT
                    a.id,
                    a.name,
                    a.ip,
                    a.ad_domain,
                    a.type
                FROM vulnerability v
                JOIN asset a ON v.asset_id = a.id
                WHERE v.vulnerability_id = :cveId
                AND a.id IN :assetIds
                ORDER BY a.name
                LIMIT 100
                """
            ).setParameter("cveId", cveId)
             .setParameter("assetIds", accessibleAssetIds)
             .resultList as List<Array<Any?>>
        }

        // Get severity for this CVE using EntityManager
        val severity = try {
            entityManager.createQuery(
                "SELECT DISTINCT v.cvssSeverity FROM Vulnerability v WHERE v.vulnerabilityId = :cveId",
                String::class.java
            ).setParameter("cveId", cveId)
             .resultList
             .firstOrNull() ?: "UNKNOWN"
        } catch (_: Exception) {
            "UNKNOWN"
        }

        // Transform raw results into DTOs
        // Array indices: [0]=assetId, [1]=assetName, [2]=assetIp, [3]=adDomain, [4]=assetType
        val affectedAssets = rawResults.map { row ->
            com.secman.dto.AffectedAssetDto(
                assetId = (row[0] as Number).toLong(),
                assetName = row[1] as? String ?: "",
                assetIp = row[2] as? String,
                adDomain = row[3] as? String,
                assetType = row[4] as? String
            )
        }

        return com.secman.dto.AffectedAssetsByCveDto(
            cveId = cveId,
            severity = severity,
            affectedAssets = affectedAssets,
            totalCount = affectedAssets.size
        )
    }

    /**
     * Get assets that have a specific product installed with access control and optional domain filter
     *
     * Returns list of assets with the specified product, filtered by:
     * - User's access control (workgroups, domain mappings, AWS accounts, etc.)
     * - Optional domain filter
     *
     * @param authentication Current user authentication context
     * @param product The product name to search for
     * @param domain Optional AD domain filter (null = all domains). Case-insensitive.
     * @return AssetsByProductDto with list of assets (max 100)
     */
    @Transactional
    open fun getAssetsByProduct(
        authentication: Authentication,
        product: String,
        domain: String? = null
    ): com.secman.dto.AssetsByProductDto {
        val accessibleAssetIds = getAccessibleAssetIdsWithDomain(authentication, domain)

        val rawResults: List<Array<Any?>> = if (accessibleAssetIds == null) {
            // ADMIN sees all assets (with no domain filter)
            @Suppress("UNCHECKED_CAST")
            entityManager.createNativeQuery(
                """
                SELECT
                    a.id,
                    a.name,
                    a.ip,
                    a.ad_domain,
                    a.type,
                    COUNT(DISTINCT v.id) as vuln_count
                FROM asset a
                JOIN vulnerability v ON v.asset_id = a.id
                WHERE v.vulnerable_product_versions = :product
                GROUP BY a.id, a.name, a.ip, a.ad_domain, a.type
                ORDER BY vuln_count DESC, a.name
                LIMIT 100
                """
            ).setParameter("product", product).resultList as List<Array<Any?>>
        } else if (accessibleAssetIds.isEmpty()) {
            // User has no accessible assets - return empty list
            emptyList()
        } else {
            // User sees assets within their access scope + domain filter
            @Suppress("UNCHECKED_CAST")
            entityManager.createNativeQuery(
                """
                SELECT
                    a.id,
                    a.name,
                    a.ip,
                    a.ad_domain,
                    a.type,
                    COUNT(DISTINCT v.id) as vuln_count
                FROM asset a
                JOIN vulnerability v ON v.asset_id = a.id
                WHERE v.vulnerable_product_versions = :product
                AND a.id IN :assetIds
                GROUP BY a.id, a.name, a.ip, a.ad_domain, a.type
                ORDER BY vuln_count DESC, a.name
                LIMIT 100
                """
            ).setParameter("product", product)
             .setParameter("assetIds", accessibleAssetIds)
             .resultList as List<Array<Any?>>
        }

        // Transform raw results into DTOs
        // Array indices: [0]=assetId, [1]=assetName, [2]=assetIp, [3]=adDomain, [4]=assetType, [5]=vulnCount
        val assets = rawResults.map { row ->
            com.secman.dto.AssetWithProductDto(
                assetId = (row[0] as Number).toLong(),
                assetName = row[1] as? String ?: "",
                assetIp = row[2] as? String,
                adDomain = row[3] as? String,
                assetType = row[4] as? String,
                vulnerabilityCount = (row[5] as Number).toLong()
            )
        }

        return com.secman.dto.AssetsByProductDto(
            product = product,
            assets = assets,
            totalCount = assets.size
        )
    }
}
