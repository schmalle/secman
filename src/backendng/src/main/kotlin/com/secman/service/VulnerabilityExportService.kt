package com.secman.service

import com.secman.config.MemoryOptimizationConfig
import com.secman.dto.VulnerabilityExportDto
import com.secman.dto.VulnerabilityWithExceptionDto
import io.micronaut.security.authentication.Authentication
import jakarta.inject.Singleton
import org.apache.poi.ss.usermodel.CellStyle
import org.apache.poi.ss.usermodel.FillPatternType
import org.apache.poi.ss.usermodel.IndexedColors
import org.apache.poi.ss.usermodel.Workbook
import org.apache.poi.xssf.streaming.SXSSFWorkbook
import org.slf4j.LoggerFactory
import java.io.ByteArrayOutputStream
import java.time.format.DateTimeFormatter

/**
 * Service for exporting vulnerabilities to Excel format
 * Feature: Vulnerability Export Performance Optimization
 * Feature: 073-memory-optimization (streaming exports)
 *
 * Replaces client-side Excel generation with server-side streaming export.
 * For 358k vulnerabilities:
 * - Old: 715+ API calls, 90-120+ seconds
 * - New: 1 API call, 5-15 seconds
 *
 * Technical Approach (same as AssetExportService):
 * - Use SXSSFWorkbook(100) for streaming export (constant memory)
 * - Create CellStyle objects ONCE before loop (not per cell)
 * - Use fixed column widths (auto-sizing adds 3 minutes for 10K rows)
 * - Dispose workbook in finally block to clean up temp files
 * - Severity color-coding (Critical=Red, High=Orange, Medium=Blue, Low=Green)
 *
 * Memory Optimization (Feature 073):
 * - When streamingExportsEnabled=true: Write directly to Excel during fetch (write-on-fetch)
 * - When streamingExportsEnabled=false: Accumulate all records first (original behavior)
 * - Controlled by MEMORY_STREAMING_EXPORTS environment variable
 */
@Singleton
class VulnerabilityExportService(
    private val vulnerabilityService: VulnerabilityService,
    private val assetFilterService: AssetFilterService,
    private val memoryConfig: MemoryOptimizationConfig
) {

    private val log = LoggerFactory.getLogger(VulnerabilityExportService::class.java)

    // Date formatter for Excel cells
    private val dateFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")

    /**
     * Export vulnerabilities accessible to the authenticated user
     * Follows same access control pattern as VulnerabilityManagementController
     *
     * Note: This method is kept for backward compatibility when streaming is disabled.
     * When streamingExportsEnabled=true, use exportVulnerabilitiesToExcelStreaming() instead.
     *
     * @param authentication Current user authentication
     * @return List of VulnerabilityExportDto ready for Excel serialization
     */
    fun exportVulnerabilities(authentication: Authentication): List<VulnerabilityExportDto> {
        log.info("Exporting vulnerabilities for user: {} (buffered mode)", authentication.name)

        val isAdmin = authentication.roles.contains("ADMIN")

        // Get accessible asset IDs (only needed for non-ADMIN users)
        val accessibleAssetIds = if (isAdmin) {
            emptySet()
        } else {
            assetFilterService.getAccessibleAssets(authentication)
                .mapNotNull { it.id }
                .toSet()
        }

        // Use optimized query to get ALL vulnerabilities (no pagination for export)
        val allVulnerabilities = mutableListOf<VulnerabilityWithExceptionDto>()
        var page = 0
        val batchSize = memoryConfig.batchSize
        var hasMore = true

        while (hasMore) {
            val response = vulnerabilityService.getCurrentVulnerabilitiesOptimized(
                accessibleAssetIds = accessibleAssetIds,
                isAdmin = isAdmin,
                severity = null,
                system = null,
                exceptionStatus = null,
                product = null,
                adDomain = null,
                cloudAccountId = null,
                page = page,
                size = batchSize
            )
            allVulnerabilities.addAll(response.content)
            hasMore = response.hasNext
            page++

            log.debug("Fetched page {} with {} vulnerabilities (total so far: {})",
                page, response.content.size, allVulnerabilities.size)
        }

        log.info("Found {} vulnerabilities accessible to user {}",
            allVulnerabilities.size, authentication.name)

        // Convert to export DTOs
        return allVulnerabilities.map { VulnerabilityExportDto.fromVulnerabilityWithException(it) }
    }

    /**
     * Export vulnerabilities directly to Excel using streaming write-on-fetch pattern
     * Feature: 073-memory-optimization
     *
     * Memory optimization: Instead of accumulating all records then writing,
     * this method writes each batch directly to the Excel workbook during fetch.
     * This reduces peak memory from O(n) to O(batch_size).
     *
     * @param authentication Current user authentication
     * @return ByteArrayOutputStream containing the Excel workbook
     */
    fun exportVulnerabilitiesToExcelStreaming(authentication: Authentication): ByteArrayOutputStream {
        log.info("Exporting vulnerabilities for user: {} (streaming mode)", authentication.name)

        val isAdmin = authentication.roles.contains("ADMIN")

        // Get accessible asset IDs (only needed for non-ADMIN users)
        val accessibleAssetIds = if (isAdmin) {
            emptySet()
        } else {
            assetFilterService.getAccessibleAssets(authentication)
                .mapNotNull { it.id }
                .toSet()
        }

        // Create streaming workbook with 100-row window
        val workbook = SXSSFWorkbook(100)
        workbook.setCompressTempFiles(true)

        try {
            val sheet = workbook.createSheet("Vulnerabilities")

            // Create styles ONCE (not per cell) - critical for performance
            val styles = createVulnerabilityStyles(workbook)

            // Write header row
            createHeaderRow(sheet, styles.header)

            // Stream data directly to Excel during fetch
            var page = 0
            val batchSize = memoryConfig.batchSize
            var hasMore = true
            var rowNum = 1
            var totalCount = 0

            while (hasMore) {
                val response = vulnerabilityService.getCurrentVulnerabilitiesOptimized(
                    accessibleAssetIds = accessibleAssetIds,
                    isAdmin = isAdmin,
                    severity = null,
                    system = null,
                    exceptionStatus = null,
                    product = null,
                    adDomain = null,
                    cloudAccountId = null,
                    page = page,
                    size = batchSize
                )

                // Write batch directly to Excel (no intermediate accumulation)
                response.content.forEach { vuln ->
                    val dto = VulnerabilityExportDto.fromVulnerabilityWithException(vuln)
                    createVulnerabilityRow(sheet, rowNum++, dto, styles)
                    totalCount++
                }

                hasMore = response.hasNext
                page++

                log.debug("Streamed page {} with {} vulnerabilities to Excel (total so far: {})",
                    page, response.content.size, totalCount)
            }

            // Set fixed column widths (auto-sizing adds 3 minutes for 10K rows)
            setFixedColumnWidths(sheet)

            // Write to output stream
            val outputStream = ByteArrayOutputStream()
            workbook.write(outputStream)

            log.info("Streaming Excel export complete: {} rows written for user {}",
                totalCount, authentication.name)

            return outputStream

        } finally {
            // CRITICAL: Close workbook to clean up temp files
            workbook.close()
            log.debug("SXSSFWorkbook closed, temp files cleaned")
        }
    }

    /**
     * Export vulnerabilities to Excel, using streaming or buffered mode based on configuration
     * Feature: 073-memory-optimization
     *
     * @param authentication Current user authentication
     * @return ByteArrayOutputStream containing the Excel workbook
     */
    fun exportToExcel(authentication: Authentication): ByteArrayOutputStream {
        return if (memoryConfig.streamingExportsEnabled) {
            log.info("Using streaming export mode (memory optimized)")
            exportVulnerabilitiesToExcelStreaming(authentication)
        } else {
            log.info("Using buffered export mode (original behavior)")
            val dtos = exportVulnerabilities(authentication)
            writeToExcel(dtos)
        }
    }

    /**
     * Write vulnerability export DTOs to Excel workbook
     *
     * Performance optimizations:
     * - SXSSFWorkbook with 100-row memory window
     * - Create styles ONCE before loop
     * - Fixed column widths (not auto-sizing)
     * - Enable GZIP compression for temp files
     * - Severity color-coding for visual clarity
     *
     * @param dtos List of vulnerability export DTOs
     * @return ByteArrayOutputStream containing Excel workbook
     */
    fun writeToExcel(dtos: List<VulnerabilityExportDto>): ByteArrayOutputStream {
        log.info("Writing {} vulnerabilities to Excel format", dtos.size)

        // Create streaming workbook with 100-row window
        val workbook = SXSSFWorkbook(100)
        workbook.setCompressTempFiles(true)

        try {
            val sheet = workbook.createSheet("Vulnerabilities")

            // Create styles ONCE (not per cell) - critical for performance
            val styles = createVulnerabilityStyles(workbook)

            // Write header row
            createHeaderRow(sheet, styles.header)

            // Write data rows
            dtos.forEachIndexed { index, dto ->
                createVulnerabilityRow(sheet, index + 1, dto, styles)
            }

            // Set fixed column widths (auto-sizing adds 3 minutes for 10K rows)
            setFixedColumnWidths(sheet)

            // Write to output stream
            val outputStream = ByteArrayOutputStream()
            workbook.write(outputStream)

            log.info("Excel export complete: {} rows written", dtos.size)

            return outputStream

        } finally {
            // CRITICAL: Close workbook to clean up temp files
            workbook.close()
            log.debug("SXSSFWorkbook closed, temp files cleaned")
        }
    }

    /**
     * Create cell styles for Excel export (created ONCE, reused for all cells)
     * Includes severity color-coding: Critical=Red, High=Orange, Medium=Blue, Low=Green
     */
    private fun createVulnerabilityStyles(workbook: Workbook): VulnerabilityStyles {
        // Header style
        val headerStyle = workbook.createCellStyle().apply {
            fillForegroundColor = IndexedColors.GREY_25_PERCENT.index
            fillPattern = FillPatternType.SOLID_FOREGROUND
            val font = workbook.createFont()
            font.bold = true
            setFont(font)
        }

        // Text style (default)
        val textStyle = workbook.createCellStyle()

        // Severity styles with color-coding
        val criticalStyle = workbook.createCellStyle().apply {
            fillForegroundColor = IndexedColors.RED.index
            fillPattern = FillPatternType.SOLID_FOREGROUND
            val font = workbook.createFont()
            font.bold = true
            font.color = IndexedColors.WHITE.index
            setFont(font)
        }

        val highStyle = workbook.createCellStyle().apply {
            fillForegroundColor = IndexedColors.ORANGE.index
            fillPattern = FillPatternType.SOLID_FOREGROUND
            val font = workbook.createFont()
            font.bold = true
            setFont(font)
        }

        val mediumStyle = workbook.createCellStyle().apply {
            fillForegroundColor = IndexedColors.LIGHT_BLUE.index
            fillPattern = FillPatternType.SOLID_FOREGROUND
        }

        val lowStyle = workbook.createCellStyle().apply {
            fillForegroundColor = IndexedColors.LIGHT_GREEN.index
            fillPattern = FillPatternType.SOLID_FOREGROUND
        }

        // Overdue status styles
        val overdueStyle = workbook.createCellStyle().apply {
            fillForegroundColor = IndexedColors.CORAL.index
            fillPattern = FillPatternType.SOLID_FOREGROUND
            val font = workbook.createFont()
            font.bold = true
            setFont(font)
        }

        val exceptedStyle = workbook.createCellStyle().apply {
            fillForegroundColor = IndexedColors.LIGHT_YELLOW.index
            fillPattern = FillPatternType.SOLID_FOREGROUND
        }

        val okStyle = workbook.createCellStyle().apply {
            fillForegroundColor = IndexedColors.LIGHT_GREEN.index
            fillPattern = FillPatternType.SOLID_FOREGROUND
        }

        // Wrap text style for descriptions
        val wrapTextStyle = workbook.createCellStyle().apply {
            wrapText = true
        }

        return VulnerabilityStyles(
            header = headerStyle,
            text = textStyle,
            critical = criticalStyle,
            high = highStyle,
            medium = mediumStyle,
            low = lowStyle,
            overdue = overdueStyle,
            excepted = exceptedStyle,
            ok = okStyle,
            wrapText = wrapTextStyle
        )
    }

    /**
     * Create header row with column names
     */
    private fun createHeaderRow(sheet: org.apache.poi.ss.usermodel.Sheet, headerStyle: CellStyle) {
        val headerRow = sheet.createRow(0)
        val headers = listOf(
            "Asset Name", "IP", "CVE ID", "Severity", "Product",
            "Days Open", "Scan Date", "Overdue Status", "Has Exception", "Exception Reason"
        )

        headers.forEachIndexed { index, header ->
            val cell = headerRow.createCell(index)
            cell.setCellValue(header)
            cell.cellStyle = headerStyle
        }
    }

    /**
     * Create data row for single vulnerability
     */
    private fun createVulnerabilityRow(
        sheet: org.apache.poi.ss.usermodel.Sheet,
        rowNum: Int,
        dto: VulnerabilityExportDto,
        styles: VulnerabilityStyles
    ) {
        val row = sheet.createRow(rowNum)

        // Asset Name
        row.createCell(0).apply {
            setCellValue(dto.assetName)
            cellStyle = styles.text
        }

        // IP
        row.createCell(1).apply {
            setCellValue(dto.assetIp ?: "")
            cellStyle = styles.text
        }

        // CVE ID
        row.createCell(2).apply {
            setCellValue(dto.cveId ?: "")
            cellStyle = styles.text
        }

        // Severity (with color-coding)
        row.createCell(3).apply {
            setCellValue(dto.severity ?: "")
            cellStyle = when (dto.severity?.lowercase()) {
                "critical" -> styles.critical
                "high" -> styles.high
                "medium" -> styles.medium
                "low" -> styles.low
                else -> styles.text
            }
        }

        // Product
        row.createCell(4).apply {
            setCellValue(dto.product ?: "")
            cellStyle = styles.wrapText
        }

        // Days Open
        row.createCell(5).apply {
            setCellValue(dto.daysOpen ?: "")
            cellStyle = styles.text
        }

        // Scan Date
        row.createCell(6).apply {
            setCellValue(dto.scanDate.format(dateFormatter))
            cellStyle = styles.text
        }

        // Overdue Status (with color-coding)
        row.createCell(7).apply {
            setCellValue(dto.overdueStatus)
            cellStyle = when (dto.overdueStatus.uppercase()) {
                "OVERDUE" -> styles.overdue
                "EXCEPTED" -> styles.excepted
                "OK" -> styles.ok
                else -> styles.text
            }
        }

        // Has Exception
        row.createCell(8).apply {
            setCellValue(if (dto.hasException) "Yes" else "No")
            cellStyle = styles.text
        }

        // Exception Reason
        row.createCell(9).apply {
            setCellValue(dto.exceptionReason ?: "")
            cellStyle = styles.wrapText
        }
    }

    /**
     * Set fixed column widths (auto-sizing adds 3 minutes overhead for 10K rows)
     */
    private fun setFixedColumnWidths(sheet: org.apache.poi.ss.usermodel.Sheet) {
        sheet.setColumnWidth(0, 7000)  // Asset Name
        sheet.setColumnWidth(1, 4000)  // IP
        sheet.setColumnWidth(2, 5000)  // CVE ID
        sheet.setColumnWidth(3, 3000)  // Severity
        sheet.setColumnWidth(4, 10000) // Product
        sheet.setColumnWidth(5, 3500)  // Days Open
        sheet.setColumnWidth(6, 5500)  // Scan Date
        sheet.setColumnWidth(7, 4000)  // Overdue Status
        sheet.setColumnWidth(8, 4000)  // Has Exception
        sheet.setColumnWidth(9, 10000) // Exception Reason
    }

    /**
     * Data class for style objects (created once, reused)
     */
    private data class VulnerabilityStyles(
        val header: CellStyle,
        val text: CellStyle,
        val critical: CellStyle,
        val high: CellStyle,
        val medium: CellStyle,
        val low: CellStyle,
        val overdue: CellStyle,
        val excepted: CellStyle,
        val ok: CellStyle,
        val wrapText: CellStyle
    )
}
