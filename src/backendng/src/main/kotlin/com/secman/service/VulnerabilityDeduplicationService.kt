package com.secman.service

import com.secman.repository.AssetRepository
import jakarta.inject.Singleton
import jakarta.persistence.EntityManager
import jakarta.transaction.Transactional
import org.slf4j.LoggerFactory

/**
 * Service for deduplicating vulnerability records in the database.
 *
 * Scans all assets and removes duplicate vulnerabilities where the same
 * (asset_id, vulnerability_id, vulnerable_product_versions) tuple appears
 * more than once. For each set of duplicates, the record with the lowest
 * primary key (oldest insert) is kept.
 */
@Singleton
open class VulnerabilityDeduplicationService(
    private val assetRepository: AssetRepository,
    private val entityManager: EntityManager
) {
    private val log = LoggerFactory.getLogger(VulnerabilityDeduplicationService::class.java)

    /**
     * Deduplicate all vulnerability records across all assets.
     *
     * For each asset, groups vulnerabilities by (vulnerability_id, vulnerable_product_versions)
     * and deletes all but the oldest record (lowest id) in each group.
     *
     * @return DeduplicationResult with per-asset and total statistics
     */
    @Transactional
    open fun deduplicateAll(): DeduplicationResult {
        log.info("Starting vulnerability deduplication across all assets")

        // Use a native query to efficiently find and delete duplicates.
        // This query identifies the IDs to KEEP (minimum id per unique group),
        // then deletes everything else that shares the same grouping key.
        //
        // Strategy: find duplicate groups, collect IDs to delete, batch-delete.

        @Suppress("UNCHECKED_CAST")
        val duplicateRows = entityManager.createNativeQuery("""
            SELECT v.id, v.asset_id, v.vulnerability_id, v.vulnerable_product_versions
            FROM vulnerability v
            INNER JOIN (
                SELECT asset_id,
                       vulnerability_id,
                       COALESCE(vulnerable_product_versions, '') AS vpv,
                       MIN(id) AS keep_id,
                       COUNT(*) AS cnt
                FROM vulnerability
                GROUP BY asset_id, vulnerability_id, COALESCE(vulnerable_product_versions, '')
                HAVING COUNT(*) > 1
            ) dups ON v.asset_id = dups.asset_id
                  AND v.vulnerability_id = dups.vulnerability_id
                  AND COALESCE(v.vulnerable_product_versions, '') = dups.vpv
                  AND v.id != dups.keep_id
            ORDER BY v.asset_id, v.vulnerability_id
        """).resultList as List<Array<Any?>>

        if (duplicateRows.isEmpty()) {
            log.info("No duplicate vulnerabilities found")
            return DeduplicationResult(
                totalDuplicatesRemoved = 0,
                assetsAffected = 0,
                details = emptyList()
            )
        }

        val idsToDelete = duplicateRows.map { row -> (row[0] as Number).toLong() }
        val assetsAffected = duplicateRows.map { row -> (row[1] as Number).toLong() }.distinct().count()

        // Build per-asset detail for reporting
        val detailMap = mutableMapOf<Long, AssetDeduplicationDetail>()
        for (row in duplicateRows) {
            val assetId = (row[1] as Number).toLong()
            val vulnId = row[2]?.toString() ?: "UNKNOWN"
            val product = row[3]?.toString()

            val detail = detailMap.getOrPut(assetId) {
                AssetDeduplicationDetail(assetId = assetId, assetName = null, duplicatesRemoved = 0, duplicateKeys = mutableListOf())
            }
            detail.duplicatesRemoved++
            val key = if (product.isNullOrBlank()) vulnId else "$vulnId ($product)"
            if (key !in detail.duplicateKeys) {
                (detail.duplicateKeys as MutableList).add(key)
            }
        }

        log.info("Found {} duplicate vulnerability records across {} assets, deleting...",
            idsToDelete.size, assetsAffected)

        // Batch delete in chunks to avoid exceeding SQL parameter limits
        val chunkSize = 1000
        var totalDeleted = 0
        for (chunk in idsToDelete.chunked(chunkSize)) {
            val deleted = entityManager.createNativeQuery(
                "DELETE FROM vulnerability WHERE id IN (:ids)"
            ).setParameter("ids", chunk).executeUpdate()
            totalDeleted += deleted
        }

        log.info("Deduplication complete: removed {} duplicate records from {} assets",
            totalDeleted, assetsAffected)

        return DeduplicationResult(
            totalDuplicatesRemoved = totalDeleted,
            assetsAffected = assetsAffected,
            details = detailMap.values.toList()
        )
    }
}

/**
 * Result of a deduplication operation
 */
data class DeduplicationResult(
    val totalDuplicatesRemoved: Int,
    val assetsAffected: Int,
    val details: List<AssetDeduplicationDetail>
)

/**
 * Per-asset deduplication detail
 */
data class AssetDeduplicationDetail(
    val assetId: Long,
    val assetName: String?,
    var duplicatesRemoved: Int,
    val duplicateKeys: List<String>
)
