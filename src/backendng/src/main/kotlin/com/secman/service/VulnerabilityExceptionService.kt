package com.secman.service

import com.secman.domain.Asset
import com.secman.domain.Vulnerability
import com.secman.domain.VulnerabilityException
import com.secman.domain.VulnerabilityException.ExceptionType
import com.secman.dto.CreateVulnerabilityExceptionRequest
import com.secman.dto.UpdateVulnerabilityExceptionRequest
import com.secman.dto.VulnerabilityExceptionDto
import com.secman.repository.AssetRepository
import com.secman.repository.VulnerabilityExceptionRepository
import com.secman.repository.VulnerabilityRepository
import jakarta.inject.Singleton
import org.slf4j.LoggerFactory
import java.time.LocalDateTime

/**
 * Service for vulnerability exception management
 *
 * Handles:
 * - Creating, updating, deleting exceptions (IP, PRODUCT, ASSET, CVE types)
 * - Checking if vulnerabilities are excepted
 * - Managing exception lifecycle (active/expired)
 *
 * Related to: Feature 004-i-want-to (VULN Role & Vulnerability Management UI)
 * Related to: Feature 021-vulnerability-overdue-exception-logic (Added ASSET support)
 */
@Singleton
class VulnerabilityExceptionService(
    private val vulnerabilityExceptionRepository: VulnerabilityExceptionRepository,
    private val assetRepository: AssetRepository,
    private val vulnerabilityRepository: VulnerabilityRepository  // Feature 021 Phase 3: For affected counts
) {
    private val log = LoggerFactory.getLogger(VulnerabilityExceptionService::class.java)

    /**
     * Get all active exceptions (not expired)
     *
     * @return List of active vulnerability exceptions
     */
    fun getActiveExceptions(): List<VulnerabilityException> {
        val now = LocalDateTime.now()
        return vulnerabilityExceptionRepository.findByExpirationDateIsNullOrExpirationDateGreaterThan(now)
    }

    /**
     * Check if a vulnerability is excepted
     *
     * @param vulnerability The vulnerability to check
     * @param asset The asset the vulnerability is on
     * @return True if vulnerability is excepted, false otherwise
     */
    fun isVulnerabilityExcepted(vulnerability: Vulnerability, asset: Asset): Boolean {
        val activeExceptions = getActiveExceptions()

        // Check if any exception matches this vulnerability
        return activeExceptions.any { exception ->
            exception.matches(vulnerability, asset)
        }
    }

    /**
     * Find the matching exception for a vulnerability
     *
     * @param vulnerability The vulnerability to check
     * @param asset The asset the vulnerability is on
     * @return The matching exception, or null if none found
     */
    fun findMatchingException(vulnerability: Vulnerability, asset: Asset): VulnerabilityException? {
        val activeExceptions = getActiveExceptions()

        // Return the first matching exception
        return activeExceptions.firstOrNull { exception ->
            exception.matches(vulnerability, asset)
        }
    }

    /**
     * Get all exceptions with optional filters
     *
     * Feature 021 Phase 3: Now includes affected vulnerability counts
     *
     * @param activeOnly If true, only return active exceptions
     * @param type Optional filter by exception type
     * @param includeAffectedCount If true, calculate affected vulnerability count (more expensive)
     * @return List of exception DTOs
     */
    fun getAllExceptions(
        activeOnly: Boolean = false,
        type: ExceptionType? = null,
        includeAffectedCount: Boolean = true  // Feature 021 Phase 3: Default true
    ): List<VulnerabilityExceptionDto> {
        log.debug("Getting all exceptions - activeOnly: {}, type: {}, includeAffectedCount: {}",
            activeOnly, type, includeAffectedCount)

        val exceptions = when {
            activeOnly && type != null -> {
                getActiveExceptions().filter { it.exceptionType == type }
            }
            activeOnly -> {
                getActiveExceptions()
            }
            type != null -> {
                vulnerabilityExceptionRepository.findByExceptionType(type)
            }
            else -> {
                vulnerabilityExceptionRepository.findAll().toList()
            }
        }

        // Map to DTOs with optional affected count
        return exceptions.map { exception ->
            mapToDto(exception, includeAffectedCount)
        }
    }

    /**
     * Create a new vulnerability exception
     *
     * Feature 021: Now supports ASSET type with validation
     *
     * @param request The exception creation request
     * @param username The username of the user creating the exception
     * @return The created exception DTO
     * @throws IllegalArgumentException if ASSET exception with invalid assetId
     */
    fun createException(request: CreateVulnerabilityExceptionRequest, username: String): VulnerabilityExceptionDto {
        log.info("Creating exception - type: {}, target: {}, assetId: {}, by: {}",
            request.exceptionType, request.targetValue, request.assetId, username)

        // Validate ASSET exception
        if (request.exceptionType == ExceptionType.ASSET) {
            if (request.assetId == null) {
                throw IllegalArgumentException("Asset ID is required for ASSET-type exceptions")
            }
            // Verify asset exists
            val asset = assetRepository.findById(request.assetId).orElse(null)
                ?: throw IllegalArgumentException("Asset not found with id: ${request.assetId}")

            log.debug("ASSET exception validated for asset: {} ({})", asset.name, asset.id)
        }

        // Validate CVE exception (supports comma-separated CVE IDs)
        if (request.exceptionType == ExceptionType.CVE) {
            val cvePattern = Regex("^CVE-\\d{4}-\\d+$", RegexOption.IGNORE_CASE)
            val cveIds = request.targetValue.split(",").map { it.trim() }.filter { it.isNotEmpty() }
            if (cveIds.isEmpty()) {
                throw IllegalArgumentException("At least one CVE ID is required")
            }
            for (cveId in cveIds) {
                if (!cveId.matches(cvePattern)) {
                    throw IllegalArgumentException("Invalid CVE ID format: '$cveId'. Expected format: CVE-YYYY-NNNNN")
                }
            }
            if (request.assetId != null) {
                assetRepository.findById(request.assetId).orElse(null)
                    ?: throw IllegalArgumentException("Asset not found with id: ${request.assetId}")
            }
        }

        // Normalize CVE targetValue: strip spaces around commas for FIND_IN_SET compatibility
        val normalizedTargetValue = if (request.exceptionType == ExceptionType.CVE) {
            request.targetValue.split(",").map { it.trim() }.filter { it.isNotEmpty() }.joinToString(",")
        } else {
            request.targetValue.trim()
        }

        val exception = VulnerabilityException(
            exceptionType = request.exceptionType,
            targetValue = normalizedTargetValue,
            assetId = request.assetId,  // Feature 021: Set asset ID
            expirationDate = request.expirationDate,
            reason = request.reason.trim(),
            createdBy = username
        )

        val saved = vulnerabilityExceptionRepository.save(exception)
        log.info("Created exception with id: {}", saved.id)

        return mapToDto(saved, includeAffectedCount = false) // Don't calculate on create (no vulns yet potentially)
    }

    /**
     * Update an existing vulnerability exception
     *
     * Feature 021: Now supports updating ASSET type with validation
     *
     * @param id The exception ID to update
     * @param request The exception update request
     * @return The updated exception DTO
     * @throws IllegalArgumentException if exception not found or invalid asset ID
     */
    fun updateException(id: Long, request: UpdateVulnerabilityExceptionRequest): VulnerabilityExceptionDto {
        log.info("Updating exception id: {}", id)

        val exception = vulnerabilityExceptionRepository.findById(id).orElse(null)
            ?: throw IllegalArgumentException("Vulnerability exception not found with id: $id")

        // Validate ASSET exception
        if (request.exceptionType == ExceptionType.ASSET) {
            if (request.assetId == null) {
                throw IllegalArgumentException("Asset ID is required for ASSET-type exceptions")
            }
            // Verify asset exists
            val asset = assetRepository.findById(request.assetId).orElse(null)
                ?: throw IllegalArgumentException("Asset not found with id: ${request.assetId}")

            log.debug("ASSET exception validated for asset: {} ({})", asset.name, asset.id)
        }

        // Validate CVE exception (supports comma-separated CVE IDs)
        if (request.exceptionType == ExceptionType.CVE) {
            val cvePattern = Regex("^CVE-\\d{4}-\\d+$", RegexOption.IGNORE_CASE)
            val cveIds = request.targetValue.split(",").map { it.trim() }.filter { it.isNotEmpty() }
            if (cveIds.isEmpty()) {
                throw IllegalArgumentException("At least one CVE ID is required")
            }
            for (cveId in cveIds) {
                if (!cveId.matches(cvePattern)) {
                    throw IllegalArgumentException("Invalid CVE ID format: '$cveId'. Expected format: CVE-YYYY-NNNNN")
                }
            }
            if (request.assetId != null) {
                assetRepository.findById(request.assetId).orElse(null)
                    ?: throw IllegalArgumentException("Asset not found with id: ${request.assetId}")
            }
        }

        exception.exceptionType = request.exceptionType
        // Normalize CVE targetValue: strip spaces around commas for FIND_IN_SET compatibility
        exception.targetValue = if (request.exceptionType == ExceptionType.CVE) {
            request.targetValue.split(",").map { it.trim() }.filter { it.isNotEmpty() }.joinToString(",")
        } else {
            request.targetValue.trim()
        }
        exception.assetId = request.assetId  // Feature 021: Update asset ID
        exception.expirationDate = request.expirationDate
        exception.reason = request.reason.trim()

        val updated = vulnerabilityExceptionRepository.update(exception)
        log.info("Updated exception id: {}", id)

        return mapToDto(updated, includeAffectedCount = false) // Don't calculate on update
    }

    /**
     * Delete a vulnerability exception
     *
     * @param id The exception ID to delete
     * @throws IllegalArgumentException if exception not found
     */
    fun deleteException(id: Long) {
        log.info("Deleting exception id: {}", id)

        val exception = vulnerabilityExceptionRepository.findById(id).orElse(null)
            ?: throw IllegalArgumentException("Vulnerability exception not found with id: $id")

        vulnerabilityExceptionRepository.deleteById(id)
        log.info("Deleted exception id: {}", id)
    }

    /**
     * Calculate how many vulnerabilities are affected by an exception
     *
     * Feature 021 Phase 3: Exception impact calculation
     *
     * @param exception The exception to check
     * @return Count of affected vulnerabilities
     */
    fun calculateAffectedCount(exception: VulnerabilityException): Int {
        return when (exception.exceptionType) {
            ExceptionType.IP -> {
                try {
                    vulnerabilityRepository.countByAssetIp(exception.targetValue).toInt()
                } catch (e: Exception) {
                    log.warn("Failed to count IP-based exceptions: {}", e.message)
                    0
                }
            }
            ExceptionType.PRODUCT -> {
                // Count vulnerabilities matching product pattern
                try {
                    vulnerabilityRepository.countByVulnerableProductVersionsContainingIgnoreCase(
                        exception.targetValue
                    ).toInt()
                } catch (e: Exception) {
                    log.warn("Failed to count product-based exceptions: {}", e.message)
                    0
                }
            }
            ExceptionType.ASSET -> {
                // Count vulnerabilities for this specific asset
                if (exception.assetId != null) {
                    try {
                        vulnerabilityRepository.countByAssetId(exception.assetId!!).toInt()
                    } catch (e: Exception) {
                        log.warn("Failed to count asset-based exceptions: {}", e.message)
                        0
                    }
                } else {
                    0
                }
            }
            ExceptionType.CVE -> {
                try {
                    val cveIds = exception.targetValue.split(",").map { it.trim() }.filter { it.isNotEmpty() }
                    if (exception.assetId != null) {
                        vulnerabilityRepository.countByVulnerabilityIdInAndAssetId(cveIds, exception.assetId!!).toInt()
                    } else {
                        vulnerabilityRepository.countByVulnerabilityIdIn(cveIds).toInt()
                    }
                } catch (e: Exception) {
                    log.warn("Failed to count CVE-based exceptions: {}", e.message)
                    0
                }
            }
        }
    }

    /**
     * Map VulnerabilityException entity to DTO
     *
     * Feature 021: Now includes assetId, assetName, and optionally affectedCount
     * Feature 021 Phase 3: Added affected count calculation
     *
     * @param exception The exception entity
     * @param includeAffectedCount If true, calculate affected vulnerability count
     * @return Exception DTO
     */
    private fun mapToDto(
        exception: VulnerabilityException,
        includeAffectedCount: Boolean = false
    ): VulnerabilityExceptionDto {
        // Fetch asset name if this is an ASSET or CVE exception with assetId
        val assetName = if ((exception.exceptionType == ExceptionType.ASSET || exception.exceptionType == ExceptionType.CVE)
            && exception.assetId != null) {
            assetRepository.findById(exception.assetId!!).orElse(null)?.name
        } else {
            null
        }

        // Calculate affected count if requested
        val affectedCount = if (includeAffectedCount) {
            calculateAffectedCount(exception)
        } else {
            null
        }
        
        return VulnerabilityExceptionDto(
            id = exception.id,
            exceptionType = exception.exceptionType,
            targetValue = exception.targetValue,
            expirationDate = exception.expirationDate,
            reason = exception.reason,
            createdBy = exception.createdBy,
            createdAt = exception.createdAt,
            updatedAt = exception.updatedAt,
            isActive = exception.isActive(),
            affectedVulnerabilityCount = affectedCount,  // Feature 021 Phase 3
            assetId = exception.assetId,  // Feature 021
            assetName = assetName  // Feature 021
        )
    }
}
