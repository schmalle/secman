package com.secman.service

import com.secman.domain.Asset
import com.secman.domain.Vulnerability
import com.secman.domain.VulnerabilityException
import com.secman.domain.VulnerabilityException.ExceptionType
import com.secman.dto.CreateVulnerabilityExceptionRequest
import com.secman.dto.UpdateVulnerabilityExceptionRequest
import com.secman.dto.VulnerabilityExceptionDto
import com.secman.repository.AssetRepository
import com.secman.repository.VulnerabilityExceptionRepository
import com.secman.repository.VulnerabilityRepository
import jakarta.inject.Singleton
import org.slf4j.LoggerFactory
import java.time.LocalDateTime

/**
 * Service for vulnerability exception management
 *
 * Handles:
 * - Creating, updating, deleting exceptions (IP, PRODUCT, ASSET types)
 * - Checking if vulnerabilities are excepted
 * - Managing exception lifecycle (active/expired)
 *
 * Related to: Feature 004-i-want-to (VULN Role & Vulnerability Management UI)
 * Related to: Feature 021-vulnerability-overdue-exception-logic (Added ASSET support)
 */
@Singleton
class VulnerabilityExceptionService(
    private val vulnerabilityExceptionRepository: VulnerabilityExceptionRepository,
    private val assetRepository: AssetRepository
) {
    private val log = LoggerFactory.getLogger(VulnerabilityExceptionService::class.java)

    /**
     * Get all active exceptions (not expired)
     *
     * @return List of active vulnerability exceptions
     */
    fun getActiveExceptions(): List<VulnerabilityException> {
        val now = LocalDateTime.now()
        return vulnerabilityExceptionRepository.findByExpirationDateIsNullOrExpirationDateGreaterThan(now)
    }

    /**
     * Check if a vulnerability is excepted
     *
     * @param vulnerability The vulnerability to check
     * @param asset The asset the vulnerability is on
     * @return True if vulnerability is excepted, false otherwise
     */
    fun isVulnerabilityExcepted(vulnerability: Vulnerability, asset: Asset): Boolean {
        val activeExceptions = getActiveExceptions()

        // Check if any exception matches this vulnerability
        return activeExceptions.any { exception ->
            exception.matches(vulnerability, asset)
        }
    }

    /**
     * Find the matching exception for a vulnerability
     *
     * @param vulnerability The vulnerability to check
     * @param asset The asset the vulnerability is on
     * @return The matching exception, or null if none found
     */
    fun findMatchingException(vulnerability: Vulnerability, asset: Asset): VulnerabilityException? {
        val activeExceptions = getActiveExceptions()

        // Return the first matching exception
        return activeExceptions.firstOrNull { exception ->
            exception.matches(vulnerability, asset)
        }
    }

    /**
     * Get all exceptions with optional filters
     *
     * @param activeOnly If true, only return active exceptions
     * @param type Optional filter by exception type
     * @return List of exception DTOs
     */
    fun getAllExceptions(activeOnly: Boolean = false, type: ExceptionType? = null): List<VulnerabilityExceptionDto> {
        log.debug("Getting all exceptions - activeOnly: {}, type: {}", activeOnly, type)

        val exceptions = when {
            activeOnly && type != null -> {
                getActiveExceptions().filter { it.exceptionType == type }
            }
            activeOnly -> {
                getActiveExceptions()
            }
            type != null -> {
                vulnerabilityExceptionRepository.findByExceptionType(type)
            }
            else -> {
                vulnerabilityExceptionRepository.findAll().toList()
            }
        }

        // Map to DTOs (without affected vulnerability counts - requires separate query)
        return exceptions.map { exception ->
            mapToDto(exception)
        }
    }

    /**
     * Create a new vulnerability exception
     *
     * Feature 021: Now supports ASSET type with validation
     *
     * @param request The exception creation request
     * @param username The username of the user creating the exception
     * @return The created exception DTO
     * @throws IllegalArgumentException if ASSET exception with invalid assetId
     */
    fun createException(request: CreateVulnerabilityExceptionRequest, username: String): VulnerabilityExceptionDto {
        log.info("Creating exception - type: {}, target: {}, assetId: {}, by: {}",
            request.exceptionType, request.targetValue, request.assetId, username)

        // Validate ASSET exception
        if (request.exceptionType == ExceptionType.ASSET) {
            if (request.assetId == null) {
                throw IllegalArgumentException("Asset ID is required for ASSET-type exceptions")
            }
            // Verify asset exists
            val asset = assetRepository.findById(request.assetId).orElse(null)
                ?: throw IllegalArgumentException("Asset not found with id: ${request.assetId}")
            
            log.debug("ASSET exception validated for asset: {} ({})", asset.name, asset.id)
        }

        val exception = VulnerabilityException(
            exceptionType = request.exceptionType,
            targetValue = request.targetValue.trim(),
            assetId = request.assetId,  // Feature 021: Set asset ID
            expirationDate = request.expirationDate,
            reason = request.reason.trim(),
            createdBy = username
        )

        val saved = vulnerabilityExceptionRepository.save(exception)
        log.info("Created exception with id: {}", saved.id)

        return mapToDto(saved)
    }

    /**
     * Update an existing vulnerability exception
     *
     * Feature 021: Now supports updating ASSET type with validation
     *
     * @param id The exception ID to update
     * @param request The exception update request
     * @return The updated exception DTO
     * @throws IllegalArgumentException if exception not found or invalid asset ID
     */
    fun updateException(id: Long, request: UpdateVulnerabilityExceptionRequest): VulnerabilityExceptionDto {
        log.info("Updating exception id: {}", id)

        val exception = vulnerabilityExceptionRepository.findById(id).orElse(null)
            ?: throw IllegalArgumentException("Vulnerability exception not found with id: $id")

        // Validate ASSET exception
        if (request.exceptionType == ExceptionType.ASSET) {
            if (request.assetId == null) {
                throw IllegalArgumentException("Asset ID is required for ASSET-type exceptions")
            }
            // Verify asset exists
            val asset = assetRepository.findById(request.assetId).orElse(null)
                ?: throw IllegalArgumentException("Asset not found with id: ${request.assetId}")
            
            log.debug("ASSET exception validated for asset: {} ({})", asset.name, asset.id)
        }

        exception.exceptionType = request.exceptionType
        exception.targetValue = request.targetValue.trim()
        exception.assetId = request.assetId  // Feature 021: Update asset ID
        exception.expirationDate = request.expirationDate
        exception.reason = request.reason.trim()

        val updated = vulnerabilityExceptionRepository.update(exception)
        log.info("Updated exception id: {}", id)

        return mapToDto(updated)
    }

    /**
     * Delete a vulnerability exception
     *
     * @param id The exception ID to delete
     * @throws IllegalArgumentException if exception not found
     */
    fun deleteException(id: Long) {
        log.info("Deleting exception id: {}", id)

        val exception = vulnerabilityExceptionRepository.findById(id).orElse(null)
            ?: throw IllegalArgumentException("Vulnerability exception not found with id: $id")

        vulnerabilityExceptionRepository.deleteById(id)
        log.info("Deleted exception id: {}", id)
    }

    /**
     * Map VulnerabilityException entity to DTO
     *
     * Feature 021: Now includes assetId and assetName
     *
     * @param exception The exception entity
     * @return Exception DTO
     */
    private fun mapToDto(exception: VulnerabilityException): VulnerabilityExceptionDto {
        // Fetch asset name if this is an ASSET exception
        val assetName = if (exception.exceptionType == ExceptionType.ASSET && exception.assetId != null) {
            assetRepository.findById(exception.assetId!!).orElse(null)?.name
        } else {
            null
        }
        
        return VulnerabilityExceptionDto(
            id = exception.id,
            exceptionType = exception.exceptionType,
            targetValue = exception.targetValue,
            expirationDate = exception.expirationDate,
            reason = exception.reason,
            createdBy = exception.createdBy,
            createdAt = exception.createdAt,
            updatedAt = exception.updatedAt,
            isActive = exception.isActive(),
            affectedVulnerabilityCount = null,  // Not calculated in this service
            assetId = exception.assetId,  // Feature 021
            assetName = assetName  // Feature 021
        )
    }
}
