package com.secman.service

import com.secman.config.VulnerabilitySettings
import com.secman.domain.Asset
import com.secman.domain.CrowdStrikeImportHistory
import com.secman.domain.Vulnerability
import com.secman.dto.CrowdStrikeVulnerabilityBatchDto
import com.secman.dto.ImportStatisticsDto
import com.secman.dto.CrowdStrikeImportStatusDto
import com.secman.dto.VulnerabilityDto
import com.secman.repository.AssetRepository
import com.secman.repository.VulnerabilityRepository
import com.secman.repository.CrowdStrikeImportHistoryRepository
import jakarta.inject.Singleton
import jakarta.transaction.Transactional
import org.slf4j.LoggerFactory
import java.time.LocalDateTime
import java.time.temporal.ChronoUnit

/**
 * Service for importing CrowdStrike server vulnerabilities with automatic asset creation
 *
 * Provides functionality to:
 * - Find or create Asset records from CrowdStrike server data
 * - Import vulnerabilities with transactional replace pattern (delete old + insert new)
 * - Track import statistics (servers created/updated, vulnerabilities imported/skipped)
 * - Handle per-server transactions with rollback on failure
 * - Preserve existing asset metadata (owner, description, workgroups) when reusing assets
 *
 * Feature: 032-servers-query-import
 * Tasks: T019, T020, T021, T022
 * Spec reference: FR-008, FR-010, FR-011, FR-012, FR-013, FR-015
 */
@Singleton
open class CrowdStrikeVulnerabilityImportService(
    private val assetRepository: AssetRepository,
    private val vulnerabilityRepository: VulnerabilityRepository,
    private val importHistoryRepository: CrowdStrikeImportHistoryRepository,
    private val materializedViewRefreshService: MaterializedViewRefreshService,
    private val vulnerabilitySettings: VulnerabilitySettings
) {
    private val log = LoggerFactory.getLogger(CrowdStrikeVulnerabilityImportService::class.java)

    /**
     * Import batch of server vulnerabilities from CrowdStrike
     *
     * Task: T022
     * Spec reference: FR-008
     *
     * @param batches List of server vulnerability batches
     * @return ImportStatisticsDto with detailed statistics
     */
    fun importServerVulnerabilities(
        batches: List<CrowdStrikeVulnerabilityBatchDto>,
        triggeredBy: String? = null
    ): ImportStatisticsDto {
        log.info("Starting batch import of {} servers", batches.size)

        var serversCreated = 0
        var serversUpdated = 0
        var vulnerabilitiesImported = 0
        var vulnerabilitiesSkipped = 0
        var vulnerabilitiesWithPatchDate = 0
        val uniqueDomains = mutableSetOf<String>()  // Feature 043: Track unique domains
        val errors = mutableListOf<String>()

        for (batch in batches) {
            try {
                // Process each server in its own transaction (FR-010)
                val result = importVulnerabilitiesForServer(batch)

                if (result.assetCreated) serversCreated++
                else serversUpdated++

                vulnerabilitiesImported += result.vulnerabilitiesImported
                vulnerabilitiesSkipped += result.vulnerabilitiesSkipped
                vulnerabilitiesWithPatchDate += result.vulnerabilitiesWithPatchDate

                // Track unique domains (Feature 043)
                batch.adDomain?.let { domain ->
                    if (domain.isNotBlank()) {
                        uniqueDomains.add(domain.trim().uppercase())
                        log.trace("Tracked domain: {}", domain.trim().uppercase())
                    }
                }

                log.debug("Imported server '{}': created={}, imported={}, skipped={}, withPatchDate={}, domain={}",
                    batch.hostname, result.assetCreated, result.vulnerabilitiesImported, result.vulnerabilitiesSkipped, result.vulnerabilitiesWithPatchDate, batch.adDomain)
            } catch (e: Exception) {
                val errorMsg = "Failed to import server '${batch.hostname}': ${e.message}"
                log.error(errorMsg, e)
                errors.add(errorMsg)
            }
        }

        val statistics = ImportStatisticsDto(
            serversProcessed = batches.size,
            serversCreated = serversCreated,
            serversUpdated = serversUpdated,
            vulnerabilitiesImported = vulnerabilitiesImported,
            vulnerabilitiesSkipped = vulnerabilitiesSkipped,
            vulnerabilitiesWithPatchDate = vulnerabilitiesWithPatchDate,
            uniqueDomainCount = uniqueDomains.size,  // Feature 043
            discoveredDomains = uniqueDomains.sorted(),  // Feature 043
            errors = errors
        )

        log.info("Batch import completed: processed={}, created={}, updated={}, imported={}, skipped={}, withPatchDate={}, uniqueDomains={}, errors={}",
            batches.size, serversCreated, serversUpdated, vulnerabilitiesImported, vulnerabilitiesSkipped, vulnerabilitiesWithPatchDate, uniqueDomains.size, errors.size)

        recordImportHistory(statistics, triggeredBy)

        // Trigger async materialized view refresh after import
        // Feature: 034-outdated-assets, Task: T101
        // Spec reference: FR-005 (async refresh)
        if (vulnerabilitiesImported > 0) {
            log.info("Triggering materialized view refresh after importing {} vulnerabilities", vulnerabilitiesImported)
            materializedViewRefreshService.triggerAsyncRefresh("CLI Import - $vulnerabilitiesImported vulnerabilities imported")
        }

        return statistics
    }

    /**
     * Persist import execution metadata for UI consumption.
     */
    private fun recordImportHistory(statistics: ImportStatisticsDto, triggeredBy: String?) {
        try {
            val history = CrowdStrikeImportHistory(
                importedAt = LocalDateTime.now(),
                importedBy = triggeredBy,
                serversProcessed = statistics.serversProcessed,
                serversCreated = statistics.serversCreated,
                serversUpdated = statistics.serversUpdated,
                vulnerabilitiesImported = statistics.vulnerabilitiesImported,
                vulnerabilitiesSkipped = statistics.vulnerabilitiesSkipped,
                vulnerabilitiesWithPatchDate = statistics.vulnerabilitiesWithPatchDate,
                errorCount = statistics.errors.size
            )
            importHistoryRepository.save(history)
            log.info("Recorded CrowdStrike import history entry: {}", history)
        } catch (e: Exception) {
            log.error("Failed to record CrowdStrike import history", e)
        }
    }

    fun getLatestImportStatus(): CrowdStrikeImportStatusDto? {
        return importHistoryRepository.findLatest()
            ?.let { CrowdStrikeImportStatusDto.fromEntity(it) }
    }

    /**
     * Import vulnerabilities for a single server with transactional replace pattern
     *
     * Tasks: T021, T024, T025, T026
     * Spec reference: FR-010, FR-011
     *
     * @param batch Server vulnerability batch
     * @return ServerImportResult with statistics
     */
    @Transactional
    open fun importVulnerabilitiesForServer(batch: CrowdStrikeVulnerabilityBatchDto): ServerImportResult {
        log.debug("Importing vulnerabilities for server: {}", batch.hostname)

        // Find or create asset (T020)
        val (asset, isNewAsset) = findOrCreateAsset(batch)

        // Delete existing vulnerabilities for this asset (T025 - transactional replace pattern)
        val deletedCount = vulnerabilityRepository.deleteByAssetId(asset.id!!)
        if (deletedCount > 0) {
            log.debug("Deleted {} existing vulnerabilities for asset '{}'", deletedCount, asset.name)
        }

        // Filter vulnerabilities with CVE IDs (FR-013)
        var vulnsWithCve = batch.vulnerabilities.filter { !it.cveId.isNullOrBlank() }
        var skippedCount = batch.vulnerabilities.size - vulnsWithCve.size

        // Filter vulnerabilities without patch publication date if required (Feature 041)
        if (vulnerabilitySettings.requirePatchPublicationDate) {
            val beforeFilterCount = vulnsWithCve.size
            vulnsWithCve = vulnsWithCve.filter { it.patchPublicationDate != null }
            val additionalSkipped = beforeFilterCount - vulnsWithCve.size
            skippedCount += additionalSkipped

            if (additionalSkipped > 0) {
                log.debug("Skipped {} vulnerabilities without patch publication date for asset '{}' (requirePatchPublicationDate=true)",
                    additionalSkipped, asset.name)
            }
        }

        if (skippedCount > 0) {
            log.debug("Skipped {} vulnerabilities (no CVE ID or no patch publication date) for asset '{}'", skippedCount, asset.name)
        }

        // Create new vulnerability records (T021)
        var vulnerabilitiesWithPatchDateCount = 0
        val vulnerabilities = vulnsWithCve.map { vulnDto ->
            // Track vulnerabilities with patch publication date
            if (vulnDto.patchPublicationDate != null) {
                vulnerabilitiesWithPatchDateCount++
            }

            // Calculate scan timestamp and days open based on configuration
            val (scanTimestamp, daysOpenText) = if (vulnerabilitySettings.usePatchPublicationDate && vulnDto.patchPublicationDate != null) {
                // Use patch publication date for calculation (Feature 041)
                // days_open = scan_timestamp - patch_publication_date
                val currentTime = LocalDateTime.now()
                val patchDate = vulnDto.patchPublicationDate
                val daysFromPatch = ChronoUnit.DAYS.between(patchDate, currentTime).toInt()

                // scanTimestamp is set to current time - daysFromPatch
                val calculatedScanTime = currentTime.minusDays(daysFromPatch.toLong())
                val daysText = if (daysFromPatch == 1) "1 day" else "$daysFromPatch days"

                log.trace("Using patch publication date for CVE {}: patch_date={}, days_from_patch={}",
                    vulnDto.cveId, patchDate, daysFromPatch)

                Pair(calculatedScanTime, daysText)
            } else {
                // Use original logic: days_open from detection time (current behavior)
                val scanTime = LocalDateTime.now().minusDays(vulnDto.daysOpen.toLong())
                val daysText = "${vulnDto.daysOpen} days"
                Pair(scanTime, daysText)
            }

            Vulnerability(
                asset = asset,
                vulnerabilityId = vulnDto.cveId,
                cvssSeverity = vulnDto.severity,
                vulnerableProductVersions = vulnDto.affectedProduct,
                daysOpen = daysOpenText,
                scanTimestamp = scanTimestamp,
                patchPublicationDate = vulnDto.patchPublicationDate
            )
        }

        // Save all vulnerabilities in batch
        if (vulnerabilities.isNotEmpty()) {
            vulnerabilityRepository.saveAll(vulnerabilities)
            log.debug("Created {} new vulnerabilities for asset '{}' ({} with patch publication date)",
                vulnerabilities.size, asset.name, vulnerabilitiesWithPatchDateCount)
        }

        return ServerImportResult(
            assetCreated = isNewAsset,
            vulnerabilitiesImported = vulnerabilities.size,
            vulnerabilitiesSkipped = skippedCount,
            vulnerabilitiesWithPatchDate = vulnerabilitiesWithPatchDateCount
        )
    }

    /**
     * Find existing asset by hostname or create new one with metadata
     *
     * Tasks: T020, T033, T034, T035
     * Spec reference: FR-012, FR-014
     *
     * @param batch Server vulnerability batch with metadata
     * @return Pair of (Asset, isNew)
     */
    private fun findOrCreateAsset(batch: CrowdStrikeVulnerabilityBatchDto): Pair<Asset, Boolean> {
        val existing = assetRepository.findByNameIgnoreCase(batch.hostname)

        return if (existing != null) {
            // Smart update: Only modify fields that have changed (Feature 043: US3)
            var hasChanges = false
            val changedFields = mutableListOf<String>()

            // Compare and update IP
            val newIp = batch.ip?.takeIf { it.isNotBlank() }
            if (newIp != null && newIp != existing.ip) {
                log.debug("IP changed for {}: {} -> {}", batch.hostname, existing.ip, newIp)
                existing.ip = newIp
                hasChanges = true
                changedFields.add("ip")
            }

            // Compare and update groups
            val newGroups = batch.groups?.takeIf { it.isNotBlank() }
            if (newGroups != null && newGroups != existing.groups) {
                log.debug("Groups changed for {}: {} -> {}", batch.hostname, existing.groups, newGroups)
                existing.groups = newGroups
                hasChanges = true
                changedFields.add("groups")
            }

            // Compare and update cloud account ID
            val newCloudAccountId = batch.cloudAccountId?.takeIf { it.isNotBlank() }
            if (newCloudAccountId != null && newCloudAccountId != existing.cloudAccountId) {
                log.debug("Cloud account ID changed for {}: {} -> {}", batch.hostname, existing.cloudAccountId, newCloudAccountId)
                existing.cloudAccountId = newCloudAccountId
                hasChanges = true
                changedFields.add("cloudAccountId")
            }

            // Compare and update cloud instance ID
            val newCloudInstanceId = batch.cloudInstanceId?.takeIf { it.isNotBlank() }
            if (newCloudInstanceId != null && newCloudInstanceId != existing.cloudInstanceId) {
                log.debug("Cloud instance ID changed for {}: {} -> {}", batch.hostname, existing.cloudInstanceId, newCloudInstanceId)
                existing.cloudInstanceId = newCloudInstanceId
                hasChanges = true
                changedFields.add("cloudInstanceId")
            }

            // Compare and update AD domain (case-insensitive, normalized to lowercase by @PreUpdate)
            val newAdDomain = batch.adDomain?.takeIf { it.isNotBlank() }
            if (newAdDomain != null && newAdDomain.lowercase() != existing.adDomain?.lowercase()) {
                log.debug("AD domain changed for {}: {} -> {}", batch.hostname, existing.adDomain, newAdDomain)
                existing.adDomain = newAdDomain
                hasChanges = true
                changedFields.add("adDomain")
            }

            // Compare and update OS version
            val newOsVersion = batch.osVersion?.takeIf { it.isNotBlank() }
            if (newOsVersion != null && newOsVersion != existing.osVersion) {
                log.debug("OS version changed for {}: {} -> {}", batch.hostname, existing.osVersion, newOsVersion)
                existing.osVersion = newOsVersion
                hasChanges = true
                changedFields.add("osVersion")
            }

            // Always update lastSeen
            existing.lastSeen = LocalDateTime.now()

            // Only write to database if fields changed
            val updated = if (hasChanges) {
                existing.updatedAt = LocalDateTime.now()
                assetRepository.update(existing)
                log.info("Updated asset '{}' (id={}): changed fields: {}", batch.hostname, existing.id, changedFields.joinToString(", "))
                existing
            } else {
                log.debug("No changes for asset '{}' (id={}), skipping database write", batch.hostname, existing.id)
                existing
            }

            // Preserve: owner, description, workgroups, manualCreator, scanUploader (FR-014)
            Pair(updated, false)
        } else {
            // Create new asset (T020, T033)
            val newAsset = Asset(
                name = batch.hostname,
                type = "SERVER",  // FR-002
                owner = "CrowdStrike Import",  // FR-012
                description = null,
                ip = batch.ip?.takeIf { it.isNotBlank() },
                groups = batch.groups?.takeIf { it.isNotBlank() },
                cloudAccountId = batch.cloudAccountId?.takeIf { it.isNotBlank() },
                cloudInstanceId = batch.cloudInstanceId?.takeIf { it.isNotBlank() },
                adDomain = batch.adDomain?.takeIf { it.isNotBlank() },
                osVersion = batch.osVersion?.takeIf { it.isNotBlank() },
                lastSeen = LocalDateTime.now(),
                manualCreator = null,  // Not manually created
                scanUploader = null    // Not from scan upload
            )

            val created = assetRepository.save(newAsset)
            log.debug("Created new asset: {} (id={})", batch.hostname, created.id)

            Pair(created, true)
        }
    }
}

/**
 * Result of importing vulnerabilities for a single server
 */
data class ServerImportResult(
    val assetCreated: Boolean,
    val vulnerabilitiesImported: Int,
    val vulnerabilitiesSkipped: Int,
    val vulnerabilitiesWithPatchDate: Int
)
