package com.secman.service

import com.secman.domain.Asset
import com.secman.domain.Vulnerability
import com.secman.dto.CrowdStrikeVulnerabilityBatchDto
import com.secman.dto.ImportStatisticsDto
import com.secman.dto.VulnerabilityDto
import com.secman.repository.AssetRepository
import com.secman.repository.VulnerabilityRepository
import jakarta.inject.Singleton
import jakarta.transaction.Transactional
import org.slf4j.LoggerFactory
import java.time.LocalDateTime

/**
 * Service for importing CrowdStrike server vulnerabilities with automatic asset creation
 *
 * Provides functionality to:
 * - Find or create Asset records from CrowdStrike server data
 * - Import vulnerabilities with transactional replace pattern (delete old + insert new)
 * - Track import statistics (servers created/updated, vulnerabilities imported/skipped)
 * - Handle per-server transactions with rollback on failure
 * - Preserve existing asset metadata (owner, description, workgroups) when reusing assets
 *
 * Feature: 032-servers-query-import
 * Tasks: T019, T020, T021, T022
 * Spec reference: FR-008, FR-010, FR-011, FR-012, FR-013, FR-015
 */
@Singleton
open class CrowdStrikeVulnerabilityImportService(
    private val assetRepository: AssetRepository,
    private val vulnerabilityRepository: VulnerabilityRepository
) {
    private val log = LoggerFactory.getLogger(CrowdStrikeVulnerabilityImportService::class.java)

    /**
     * Import batch of server vulnerabilities from CrowdStrike
     *
     * Task: T022
     * Spec reference: FR-008
     *
     * @param batches List of server vulnerability batches
     * @return ImportStatisticsDto with detailed statistics
     */
    fun importServerVulnerabilities(batches: List<CrowdStrikeVulnerabilityBatchDto>): ImportStatisticsDto {
        log.info("Starting batch import of {} servers", batches.size)

        var serversCreated = 0
        var serversUpdated = 0
        var vulnerabilitiesImported = 0
        var vulnerabilitiesSkipped = 0
        val errors = mutableListOf<String>()

        for (batch in batches) {
            try {
                // Process each server in its own transaction (FR-010)
                val result = importVulnerabilitiesForServer(batch)

                if (result.assetCreated) serversCreated++
                else serversUpdated++

                vulnerabilitiesImported += result.vulnerabilitiesImported
                vulnerabilitiesSkipped += result.vulnerabilitiesSkipped

                log.debug("Imported server '{}': created={}, imported={}, skipped={}",
                    batch.hostname, result.assetCreated, result.vulnerabilitiesImported, result.vulnerabilitiesSkipped)
            } catch (e: Exception) {
                val errorMsg = "Failed to import server '${batch.hostname}': ${e.message}"
                log.error(errorMsg, e)
                errors.add(errorMsg)
            }
        }

        val statistics = ImportStatisticsDto(
            serversProcessed = batches.size,
            serversCreated = serversCreated,
            serversUpdated = serversUpdated,
            vulnerabilitiesImported = vulnerabilitiesImported,
            vulnerabilitiesSkipped = vulnerabilitiesSkipped,
            errors = errors
        )

        log.info("Batch import completed: processed={}, created={}, updated={}, imported={}, skipped={}, errors={}",
            batches.size, serversCreated, serversUpdated, vulnerabilitiesImported, vulnerabilitiesSkipped, errors.size)

        return statistics
    }

    /**
     * Import vulnerabilities for a single server with transactional replace pattern
     *
     * Tasks: T021, T024, T025, T026
     * Spec reference: FR-010, FR-011
     *
     * @param batch Server vulnerability batch
     * @return ServerImportResult with statistics
     */
    @Transactional
    open fun importVulnerabilitiesForServer(batch: CrowdStrikeVulnerabilityBatchDto): ServerImportResult {
        log.debug("Importing vulnerabilities for server: {}", batch.hostname)

        // Find or create asset (T020)
        val (asset, isNewAsset) = findOrCreateAsset(batch)

        // Delete existing vulnerabilities for this asset (T025 - transactional replace pattern)
        val deletedCount = vulnerabilityRepository.deleteByAssetId(asset.id!!)
        if (deletedCount > 0) {
            log.debug("Deleted {} existing vulnerabilities for asset '{}'", deletedCount, asset.name)
        }

        // Filter vulnerabilities with CVE IDs (FR-013)
        val vulnsWithCve = batch.vulnerabilities.filter { !it.cveId.isNullOrBlank() }
        val skippedCount = batch.vulnerabilities.size - vulnsWithCve.size

        if (skippedCount > 0) {
            log.debug("Skipped {} vulnerabilities without CVE IDs for asset '{}'", skippedCount, asset.name)
        }

        // Create new vulnerability records (T021)
        val vulnerabilities = vulnsWithCve.map { vulnDto ->
            Vulnerability(
                asset = asset,
                vulnerabilityId = vulnDto.cveId,
                cvssSeverity = vulnDto.severity,
                vulnerableProductVersions = vulnDto.affectedProduct,
                daysOpen = "${vulnDto.daysOpen} days",  // Convert Int to String format
                scanTimestamp = LocalDateTime.now()
            )
        }

        // Save all vulnerabilities in batch
        if (vulnerabilities.isNotEmpty()) {
            vulnerabilityRepository.saveAll(vulnerabilities)
            log.debug("Created {} new vulnerabilities for asset '{}'", vulnerabilities.size, asset.name)
        }

        return ServerImportResult(
            assetCreated = isNewAsset,
            vulnerabilitiesImported = vulnerabilities.size,
            vulnerabilitiesSkipped = skippedCount
        )
    }

    /**
     * Find existing asset by hostname or create new one with metadata
     *
     * Tasks: T020, T033, T034, T035
     * Spec reference: FR-012, FR-014
     *
     * @param batch Server vulnerability batch with metadata
     * @return Pair of (Asset, isNew)
     */
    private fun findOrCreateAsset(batch: CrowdStrikeVulnerabilityBatchDto): Pair<Asset, Boolean> {
        val existing = assetRepository.findByNameIgnoreCase(batch.hostname)

        return if (existing != null) {
            // Update metadata for existing asset (T034)
            existing.groups = batch.groups?.takeIf { it.isNotBlank() }
            existing.cloudAccountId = batch.cloudAccountId?.takeIf { it.isNotBlank() }
            existing.cloudInstanceId = batch.cloudInstanceId?.takeIf { it.isNotBlank() }
            existing.adDomain = batch.adDomain?.takeIf { it.isNotBlank() }
            existing.osVersion = batch.osVersion?.takeIf { it.isNotBlank() }
            existing.ip = batch.ip?.takeIf { it.isNotBlank() }
            existing.lastSeen = LocalDateTime.now()  // T035
            existing.updatedAt = LocalDateTime.now()

            // Preserve: owner, description, workgroups, manualCreator, scanUploader (FR-014)
            val updated = assetRepository.update(existing)
            log.debug("Reusing existing asset: {} (id={})", batch.hostname, updated.id)

            Pair(updated, false)
        } else {
            // Create new asset (T020, T033)
            val newAsset = Asset(
                name = batch.hostname,
                type = "SERVER",  // FR-002
                owner = "CrowdStrike Import",  // FR-012
                description = null,
                ip = batch.ip?.takeIf { it.isNotBlank() },
                groups = batch.groups?.takeIf { it.isNotBlank() },
                cloudAccountId = batch.cloudAccountId?.takeIf { it.isNotBlank() },
                cloudInstanceId = batch.cloudInstanceId?.takeIf { it.isNotBlank() },
                adDomain = batch.adDomain?.takeIf { it.isNotBlank() },
                osVersion = batch.osVersion?.takeIf { it.isNotBlank() },
                lastSeen = LocalDateTime.now(),
                manualCreator = null,  // Not manually created
                scanUploader = null    // Not from scan upload
            )

            val created = assetRepository.save(newAsset)
            log.debug("Created new asset: {} (id={})", batch.hostname, created.id)

            Pair(created, true)
        }
    }
}

/**
 * Result of importing vulnerabilities for a single server
 */
data class ServerImportResult(
    val assetCreated: Boolean,
    val vulnerabilitiesImported: Int,
    val vulnerabilitiesSkipped: Int
)
