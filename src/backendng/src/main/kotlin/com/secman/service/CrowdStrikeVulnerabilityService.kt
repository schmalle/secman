package com.secman.service

import com.secman.domain.Asset
import com.secman.domain.Vulnerability
import com.secman.dto.*
import com.secman.repository.AssetRepository
import com.secman.repository.FalconConfigRepository
import com.secman.repository.VulnerabilityExceptionRepository
import com.secman.repository.VulnerabilityRepository
import io.micronaut.http.HttpRequest
import io.micronaut.http.HttpResponse
import io.micronaut.http.client.HttpClient
import io.micronaut.http.client.annotation.Client
import io.micronaut.http.uri.UriBuilder
import io.micronaut.retry.annotation.Retryable
import jakarta.inject.Singleton
import org.slf4j.LoggerFactory
import java.time.LocalDateTime
import java.time.temporal.ChronoUnit

/**
 * Service for integrating with CrowdStrike Falcon API
 *
 * Provides functionality to:
 * - Query CrowdStrike for system vulnerabilities (last 40 days, OPEN status)
 * - Authenticate with OAuth2 client credentials flow
 * - Cache OAuth2 tokens (30 minutes)
 * - Map CrowdStrike response to internal DTOs
 * - Check against VulnerabilityException table
 * - Save vulnerabilities to database
 *
 * Related to: Feature 015-we-have-currently (CrowdStrike System Vulnerability Lookup)
 * Tasks: T018-T026 [US1-Impl], T049-T050 [US3-Impl]
 */
@Singleton
open class CrowdStrikeVulnerabilityService(
    @Client("\${secman.http.services.crowdstrike.base-urls.us-1}")
    private val crowdStrikeClient: HttpClient,
    private val falconConfigRepository: FalconConfigRepository,
    private val assetRepository: AssetRepository,
    private val vulnerabilityRepository: VulnerabilityRepository,
    private val vulnerabilityExceptionRepository: VulnerabilityExceptionRepository
) {
    private val log = LoggerFactory.getLogger(CrowdStrikeVulnerabilityService::class.java)

    // OAuth2 token cache
    private var cachedToken: String? = null
    private var tokenExpiresAt: LocalDateTime? = null

    // FalconConfig cache (avoids repeated DB queries)
    private var cachedConfig: com.secman.domain.FalconConfig? = null

    /**
     * Query CrowdStrike for vulnerabilities by hostname
     *
     * Task: T026 [US1-Impl]
     *
     * @param hostname System hostname to query
     * @return CrowdStrikeQueryResponse with vulnerabilities
     * @throws CrowdStrikeError.ConfigurationError if credentials not configured
     * @throws CrowdStrikeError.AuthenticationError if OAuth2 fails
     * @throws CrowdStrikeError.NotFoundError if hostname not found
     * @throws CrowdStrikeError.RateLimitError if rate limit exceeded
     * @throws CrowdStrikeError.NetworkError if network issues
     * @throws CrowdStrikeError.ServerError if CrowdStrike service unavailable
     */
    fun queryByHostname(hostname: String): CrowdStrikeQueryResponse {
        require(hostname.isNotBlank()) { "Hostname cannot be blank" }

        log.info("Querying CrowdStrike for vulnerabilities: hostname={}", hostname)

        try {
            // 1. Authenticate
            val token = authenticateWithCrowdStrike()

            // 2. Query Spotlight API
            val apiResponse = queryCrowdStrikeApi(hostname, token)

            // 3. Map to DTOs
            val vulnerabilityDtos = mapToDtos(apiResponse)

            // 4. Check exceptions
            val vulnsWithExceptions = checkExceptions(vulnerabilityDtos)

            log.info("Successfully queried CrowdStrike: hostname={}, count={}", hostname, vulnsWithExceptions.size)

            return CrowdStrikeQueryResponse(
                hostname = hostname,
                vulnerabilities = vulnsWithExceptions,
                totalCount = vulnsWithExceptions.size,
                queriedAt = LocalDateTime.now()
            )
        } catch (e: CrowdStrikeError) {
            log.error("CrowdStrike query failed: hostname={}, error={}", hostname, e.message)
            throw e
        } catch (e: Exception) {
            log.error("Unexpected error querying CrowdStrike: hostname={}", hostname, e)
            throw CrowdStrikeError.ServerError(message = "Unexpected error: ${e.message}", cause = e)
        }
    }

    /**
     * Load CrowdStrike configuration from database
     *
     * Task: T019 [US1-Impl]
     *
     * @return FalconConfig with credentials
     * @throws CrowdStrikeError.ConfigurationError if no config found
     */
    private fun loadFalconConfig(): com.secman.domain.FalconConfig {
        // Return cached config if available
        if (cachedConfig != null) {
            return cachedConfig!!
        }

        log.debug("Loading FalconConfig from database")

        // Try to find active config
        val activeConfig = falconConfigRepository.findActiveConfig()
        if (activeConfig.isPresent) {
            log.debug("Found active FalconConfig: id={}", activeConfig.get().id)
            cachedConfig = activeConfig.get()
            return activeConfig.get()
        }

        // Fallback: Find most recent config
        val recentConfig = falconConfigRepository.findMostRecent()
        if (recentConfig.isPresent) {
            log.warn("No active FalconConfig found, using most recent: id={}", recentConfig.get().id)
            cachedConfig = recentConfig.get()
            return recentConfig.get()
        }

        // No config found
        log.error("No FalconConfig found in database")
        throw CrowdStrikeError.ConfigurationError("CrowdStrike API credentials not configured in database. Contact administrator.")
    }

    /**
     * Authenticate with CrowdStrike using OAuth2 client credentials
     *
     * Task: T020 [US1-Impl]
     *
     * @return OAuth2 access token
     * @throws CrowdStrikeError.ConfigurationError if credentials not configured
     * @throws CrowdStrikeError.AuthenticationError if auth fails
     */
    private fun authenticateWithCrowdStrike(): String {
        // Check if cached token is still valid
        if (cachedToken != null && tokenExpiresAt != null && LocalDateTime.now().isBefore(tokenExpiresAt)) {
            log.debug("Using cached OAuth2 token")
            return cachedToken!!
        }

        log.debug("Authenticating with CrowdStrike (OAuth2 client credentials)")

        // Load credentials from database
        val config = loadFalconConfig()

        try {
            // Build OAuth2 token request
			val baseUrl ="https://api.crowdstrike.com"
            val tokenRequest = HttpRequest.POST(baseUrl + "/oauth2/token", mapOf(
                "client_id" to config.clientId,
                "client_secret" to config.clientSecret
            ))
                .contentType(io.micronaut.http.MediaType.APPLICATION_FORM_URLENCODED)

            // Make OAuth2 request
            val response = crowdStrikeClient.toBlocking().exchange(tokenRequest, Map::class.java)

            if (response.status.code != 201) {

				log.error("OAuth2 authentication failed: status={}, code={}", response.status, response.status.code)
				log.debug("Authenticating with CrowdStrike (OAuth2 client credentials), client_id={}, client_secret={}", config.clientId, config.clientSecret)

                throw CrowdStrikeError.AuthenticationError("CrowdStrike authentication failed with status ${response.status}")
            }

            val tokenData = response.body() as Map<*, *>
            val accessToken = tokenData["access_token"]?.toString()
                ?: throw CrowdStrikeError.AuthenticationError("No access_token in response")

            val expiresIn = (tokenData["expires_in"] as? Number)?.toLong() ?: 1800L

            // Cache token (subtract 60 seconds for safety margin)
            cachedToken = accessToken
            tokenExpiresAt = LocalDateTime.now().plusSeconds(expiresIn - 60)

            log.info("Successfully authenticated with CrowdStrike, token expires at {}", tokenExpiresAt)
            return accessToken
        } catch (e: io.micronaut.http.client.exceptions.HttpClientResponseException) {
            log.error("HTTP error during authentication: status={}", e.status, e)
            if (e.status.code == 401 || e.status.code == 403) {
                throw CrowdStrikeError.AuthenticationError("Invalid CrowdStrike credentials", e)
            }
            throw CrowdStrikeError.AuthenticationError("Authentication failed: ${e.message}", e)
        } catch (e: CrowdStrikeError) {
            throw e
        } catch (e: Exception) {
            log.error("Unexpected error during authentication", e)
            throw CrowdStrikeError.AuthenticationError("Authentication error: ${e.message}", e)
        }
    }

    /**
     * Get device ID (aid) by hostname
     *
     * Task: T021-FIX [Bug fix - hostname to device ID lookup]
     *
     * CrowdStrike Spotlight API doesn't support filtering by hostname directly.
     * Must first query Hosts API to get the device ID (aid).
     *
     * Uses multi-strategy approach with fallback:
     * 1. Stemmed search (case-insensitive, starts with): hostname:'value*'
     * 2. Contains search (case-insensitive, anywhere): hostname:*'*value*'
     * 3. Exact match (case-sensitive): hostname:['value']
     * 4. Fallback: Get all devices and filter locally (case-insensitive)
     *
     * @param hostname System hostname
     * @param token OAuth2 access token
     * @return Device ID (aid) or null if not found
     * @throws CrowdStrikeError.NetworkError if network issues
     * @throws CrowdStrikeError.ServerError if server error (500+)
     */
    private fun getDeviceIdByHostname(hostname: String, token: String): String? {
        log.info("Looking up device ID for hostname: {}", hostname)

        // Strategy 1: Stemmed search (case-insensitive, starts with) - RECOMMENDED by CrowdStrike
        log.debug("Strategy 1: Trying stemmed search (starts with, case-insensitive)")
        val stemmedResult = tryHostnameFilter(hostname, "hostname:'$hostname*'", token)
        if (stemmedResult != null) {
            log.info("Found device ID using stemmed search: {}", stemmedResult)
            return stemmedResult
        }

        // Strategy 2: Contains search (case-insensitive, anywhere in hostname)
        log.debug("Strategy 2: Trying contains search (anywhere, case-insensitive)")
        val containsResult = tryHostnameFilter(hostname, "hostname:*'*$hostname*'", token)
        if (containsResult != null) {
            log.info("Found device ID using contains search: {}", containsResult)
            return containsResult
        }

        // Strategy 3: Exact match (case-sensitive with square brackets)
        log.debug("Strategy 3: Trying exact match (case-sensitive)")
        val exactResult = tryHostnameFilter(hostname, "hostname:['$hostname']", token)
        if (exactResult != null) {
            log.info("Found device ID using exact match: {}", exactResult)
            return exactResult
        }

        // Strategy 4: Fallback - Get all devices and filter locally (case-insensitive)
        log.warn("All filter strategies failed. Attempting fallback: get all devices and filter locally")
        val fallbackResult = getAllDevicesAndFilterByHostname(hostname, token)
        if (fallbackResult != null) {
            log.info("Found device ID using local filtering: {}", fallbackResult)
            return fallbackResult
        }

        log.warn("All strategies exhausted. No device found for hostname: {}", hostname)
        return null
    }

    /**
     * Try a single hostname filter strategy
     *
     * @param hostname Original hostname (for logging)
     * @param filter FQL filter string
     * @param token OAuth2 access token
     * @return Device ID or null if not found
     */
    private fun tryHostnameFilter(hostname: String, filter: String, token: String): String? {
        try {
            // Build request URL with proper encoding
            val baseUrl = "https://api.crowdstrike.com"
            val uri = UriBuilder.of("/devices/queries/devices/v1")
                .queryParam("filter", filter)
                .queryParam("limit", "10")  // Get up to 10 matches
                .build()

            val fullUrl = baseUrl + uri.toString()
            log.debug("Trying filter: {} | Full URL: {}", filter, fullUrl)

            val request = HttpRequest.GET<Any>(fullUrl)
                .header("Authorization", "Bearer $token")
                .header("Accept", "application/json")

            // Make API request
            val response = crowdStrikeClient.toBlocking().exchange(request, Map::class.java)

            when (response.status.code) {
                200 -> {
                    val responseBody = response.body() as? Map<String, Any>
                        ?: throw CrowdStrikeError.ServerError(message = "Empty response from CrowdStrike Hosts API")

                    // Extract device IDs from response
                    val resources = responseBody["resources"] as? List<*>
                    if (resources.isNullOrEmpty()) {
                        log.debug("Filter returned 0 results: {}", filter)
                        return null
                    }

                    val deviceId = resources[0]?.toString()
                    log.debug("Filter returned {} results. Using first device ID: {}", resources.size, deviceId)
                    return deviceId
                }
                429 -> {
                    val retryAfter = response.headers.get("Retry-After")?.toIntOrNull() ?: 30
                    log.warn("CrowdStrike rate limit exceeded during device lookup, retry after {} seconds", retryAfter)
                    throw CrowdStrikeError.RateLimitError(retryAfter)
                }
                in 500..599 -> {
                    log.error("CrowdStrike server error during device lookup: status={}", response.status)
                    throw CrowdStrikeError.ServerError(response.status.code)
                }
                else -> {
                    log.error("Unexpected CrowdStrike response during device lookup: status={}", response.status)
                    throw CrowdStrikeError.ServerError(
                        statusCode = response.status.code,
                        message = "Unexpected response: ${response.status}"
                    )
                }
            }
        } catch (e: io.micronaut.http.client.exceptions.HttpClientResponseException) {
            when (e.status.code) {
                429 -> {
                    val retryAfter = e.response.headers.get("Retry-After")?.toIntOrNull() ?: 30
                    throw CrowdStrikeError.RateLimitError(retryAfter, cause = e)
                }
                in 500..599 -> throw CrowdStrikeError.ServerError(e.status.code, cause = e)
                else -> {
                    log.warn("Filter failed with status {}: {}", e.status.code, filter)
                    return null  // Don't throw, try next strategy
                }
            }
        } catch (e: CrowdStrikeError) {
            throw e
        } catch (e: java.net.SocketTimeoutException) {
            log.error("Network timeout querying CrowdStrike Hosts API", e)
            throw CrowdStrikeError.NetworkError(cause = e)
        } catch (e: java.io.IOException) {
            log.error("Network error querying CrowdStrike Hosts API", e)
            throw CrowdStrikeError.NetworkError(cause = e)
        } catch (e: Exception) {
            log.error("Unexpected error querying CrowdStrike Hosts API", e)
            return null  // Don't throw, try next strategy
        }
    }

    /**
     * Fallback strategy: Get all devices and filter by hostname locally (case-insensitive)
     *
     * @param hostname System hostname to find
     * @param token OAuth2 access token
     * @return Device ID or null if not found
     */
    private fun getAllDevicesAndFilterByHostname(hostname: String, token: String): String? {
        try {
            log.debug("Fallback: Getting all devices (no filter) and filtering locally")

            val baseUrl = "https://api.crowdstrike.com"
            val uri = UriBuilder.of("/devices/queries/devices/v1")
                .queryParam("limit", "5000")  // Max limit for single request
                .build()

            val fullUrl = baseUrl + uri.toString()
            log.debug("Fallback URL: {}", fullUrl)

            val request = HttpRequest.GET<Any>(fullUrl)
                .header("Authorization", "Bearer $token")
                .header("Accept", "application/json")

            val response = crowdStrikeClient.toBlocking().exchange(request, Map::class.java)

            if (response.status.code == 200) {
                val responseBody = response.body() as? Map<String, Any>
                    ?: throw CrowdStrikeError.ServerError(message = "Empty response from CrowdStrike Hosts API")

                val deviceIds = responseBody["resources"] as? List<*>
                if (deviceIds.isNullOrEmpty()) {
                    log.warn("Fallback: No devices found in CrowdStrike")
                    return null
                }

                log.debug("Fallback: Retrieved {} device IDs. Fetching device details...", deviceIds.size)

                // Get device details to find hostname match
                // Note: This would require calling /devices/entities/devices/v1 with IDs
                // For now, we'll just warn and return null (full implementation would need details API)
                log.warn("Fallback: Device details API not implemented. Cannot filter {} devices locally", deviceIds.size)
                log.warn("Fallback: Consider implementing /devices/entities/devices/v1 call to get device details with hostnames")

                return null
            } else {
                log.error("Fallback: Unexpected response status: {}", response.status)
                return null
            }
        } catch (e: Exception) {
            log.error("Fallback: Failed to get all devices", e)
            return null
        }
    }

    /**
     * Query CrowdStrike Spotlight API for vulnerabilities
     *
     * Task: T021 [US1-Impl] - Updated to use device ID instead of hostname
     *
     * @param hostname System hostname
     * @param token OAuth2 access token
     * @return Raw API response JSON
     * @throws CrowdStrikeError.NotFoundError if hostname not found (404)
     * @throws CrowdStrikeError.RateLimitError if rate limit exceeded (429)
     * @throws CrowdStrikeError.ServerError if server error (500+)
     * @throws CrowdStrikeError.NetworkError if network issues
     */
    @Retryable(includes = [CrowdStrikeError.RateLimitError::class], attempts = "3", delay = "1s", multiplier = "2.0")
    open fun queryCrowdStrikeApi(hostname: String, token: String): Map<String, Any> {
        log.debug("Querying CrowdStrike Spotlight API: hostname={}", hostname)

        // Step 1: Get device ID from hostname (declare outside try block for catch block access)
        val deviceId = try {
            val id = getDeviceIdByHostname(hostname, token)
            if (id == null) {
                log.warn("Core error, initial calls failed... Hostname not found in CrowdStrike: {}", hostname)
                log.warn("Hostname not found in CrowdStrike: {}", hostname)
                throw CrowdStrikeError.NotFoundError(hostname)
            }
            id
        } catch (e: CrowdStrikeError) {
            throw e
        } catch (e: Exception) {
            log.error("Failed to lookup device ID for hostname: {}", hostname, e)
            throw CrowdStrikeError.ServerError(message = "Device lookup failed: ${e.message}", cause = e)
        }

        log.info("Using device ID '{}' for hostname '{}'", deviceId, hostname)

        try {

            // Calculate 40 days ago timestamp in ISO 8601 format
            val fortyDaysAgo = LocalDateTime.now().minusDays(40)
            // Format: 2025-09-02T22:10:32Z (ISO 8601 with 'T' separator and 'Z' suffix)
            // Truncate nanoseconds to seconds for better API compatibility
            val timestampFilter = fortyDaysAgo.toString().substring(0, 19) + "Z"

            log.debug("Using timestamp filter: {}", timestampFilter)

            // Build filter query: aid:'<device_id>'+status:'open'
            val filter = "aid:'$deviceId'+status:'open'"

            // Build request URL - Using v1 endpoint (documented version)
            val baseUrl = "https://api.crowdstrike.com"
            val uri = UriBuilder.of("/spotlight/combined/vulnerabilities/v1")
                .queryParam("filter", filter)
                .queryParam("limit", "5000")  // Max results per CrowdStrike docs
                .build()

            val fullUrl = baseUrl + uri.toString()
            log.debug("CrowdStrike Spotlight API request: url={}, filter={}", fullUrl, filter)

            val request = HttpRequest.GET<Any>(fullUrl)
                .header("Authorization", "Bearer $token")
                .header("Accept", "application/json")

            // Make API request
            val response = crowdStrikeClient.toBlocking().exchange(request, Map::class.java)

            when (response.status.code) {
                200 -> {
                    val responseBody = response.body() as? Map<String, Any>
                        ?: throw CrowdStrikeError.ServerError(message = "Empty response from CrowdStrike")

                    val resources = responseBody["resources"] as? List<*>
                    val resourceCount = resources?.size ?: 0
                    log.info("CrowdStrike Spotlight API response: status=200, vulnerabilities found={}", resourceCount)

                    if (resourceCount == 0) {
                        log.info("Device '{}' (aid: {}) has no open vulnerabilities", hostname, deviceId)
                    }

                    return responseBody
                }
                404 -> {
                    // 404 from Spotlight API typically means no vulnerabilities found (not device not found)
                    // Device lookup already succeeded, so treat this as "no vulnerabilities"
                    log.info("Spotlight API returned 404 for device '{}' (aid: {}). Treating as no vulnerabilities.", hostname, deviceId)

                    // Return empty response structure
                    return mapOf(
                        "resources" to emptyList<Any>(),
                        "meta" to mapOf("total" to 0)
                    )
                }
                429 -> {
                    val retryAfter = response.headers.get("Retry-After")?.toIntOrNull() ?: 30
                    log.warn("CrowdStrike rate limit exceeded, retry after {} seconds", retryAfter)
                    throw CrowdStrikeError.RateLimitError(retryAfter)
                }
                in 500..599 -> {
                    log.error("CrowdStrike server error: status={}", response.status)
                    throw CrowdStrikeError.ServerError(response.status.code)
                }
                else -> {
                    log.error("Unexpected CrowdStrike response: status={}", response.status)
                    throw CrowdStrikeError.ServerError(
                        statusCode = response.status.code,
                        message = "Unexpected response: ${response.status}"
                    )
                }
            }
        } catch (e: io.micronaut.http.client.exceptions.HttpClientResponseException) {
            when (e.status.code) {
                404 -> {
                    // 404 from Spotlight API - device has no vulnerabilities
                    log.info("Spotlight API returned 404 for device '{}' (aid: {}). Response: {}", hostname, deviceId, e.response.body.orElse(null))

                    // Return empty response structure instead of throwing error
                    return mapOf(
                        "resources" to emptyList<Any>(),
                        "meta" to mapOf("total" to 0)
                    )
                }
                429 -> {
                    val retryAfter = e.response.headers.get("Retry-After")?.toIntOrNull() ?: 30
                    throw CrowdStrikeError.RateLimitError(retryAfter, cause = e)
                }
                in 500..599 -> throw CrowdStrikeError.ServerError(e.status.code, cause = e)
                else -> {
                    log.error("Spotlight API error: status={}, message={}, response={}", e.status.code, e.message, e.response.body.orElse(null))
                    throw CrowdStrikeError.ServerError(e.status.code, "API error: ${e.message}", e)
                }
            }
        } catch (e: CrowdStrikeError) {
            throw e
        } catch (e: java.net.SocketTimeoutException) {
            log.error("Network timeout querying CrowdStrike", e)
            throw CrowdStrikeError.NetworkError(cause = e)
        } catch (e: java.io.IOException) {
            log.error("Network error querying CrowdStrike", e)
            throw CrowdStrikeError.NetworkError(cause = e)
        } catch (e: Exception) {
            log.error("Unexpected error querying CrowdStrike API", e)
            throw CrowdStrikeError.ServerError(message = "Unexpected error: ${e.message}", cause = e)
        }
    }

    /**
     * Map CVSS score to severity level
     *
     * Task: T022 [US1-Impl]
     *
     * @param score CVSS score (0.0-10.0)
     * @return Severity level (Critical, High, Medium, Low, Unknown)
     */
    private fun mapCvssScoreToSeverity(score: Double?): String {
        return when {
            score == null -> "Unknown"
            score >= 9.0 -> "Critical"
            score >= 7.0 -> "High"
            score >= 4.0 -> "Medium"
            score >= 0.1 -> "Low"
            else -> "Unknown"
        }
    }

    /**
     * Calculate days open since detection
     *
     * Task: T023 [US1-Impl]
     *
     * @param detectedAt Detection timestamp
     * @return Days open string (e.g., "15 days")
     */
    private fun calculateDaysOpen(detectedAt: LocalDateTime): String {
        val days = ChronoUnit.DAYS.between(detectedAt, LocalDateTime.now())
        return if (days == 1L) "1 day" else "$days days"
    }

    /**
     * Map CrowdStrike API response to DTOs
     *
     * Task: T024 [US1-Impl]
     *
     * @param apiResponse Raw API response
     * @return List of CrowdStrikeVulnerabilityDto
     */
    private fun mapToDtos(apiResponse: Map<String, Any>): List<CrowdStrikeVulnerabilityDto> {
        log.debug("Mapping CrowdStrike API response to DTOs")

        try {
            // Extract resources array from response
            val resources = apiResponse["resources"] as? List<*> ?: emptyList<Any>()

            if (resources.isEmpty()) {
                log.debug("No vulnerabilities found in CrowdStrike response")
                return emptyList()
            }

            log.debug("Mapping {} vulnerabilities from CrowdStrike response", resources.size)

            return resources.mapNotNull { resource ->
                try {
                    val vuln = resource as? Map<*, *> ?: return@mapNotNull null

                    // Extract fields from CrowdStrike response
                    val id = vuln["id"]?.toString() ?: "cs-${System.currentTimeMillis()}"
                    val hostname = vuln["hostname"]?.toString() ?: vuln["aid"]?.toString() ?: ""
                    val ip = vuln["local_ip"]?.toString()

                    // CVE information
                    val cve = vuln["cve"] as? Map<*, *>
                    val cveId = cve?.get("id")?.toString()

                    // CVSS score and severity
                    val cvssScore = (vuln["score"] as? Number)?.toDouble()
                        ?: (cve?.get("base_score") as? Number)?.toDouble()
                    val severity = mapCvssScoreToSeverity(cvssScore)

                    // Affected product
                    val apps = vuln["apps"] as? List<*>
                    val affectedProduct = apps?.mapNotNull { app ->
                        val appMap = app as? Map<*, *>
                        appMap?.get("product_name_version")?.toString()
                    }?.joinToString(", ")

                    // Detection timestamp
                    val createdTimestamp = vuln["created_timestamp"]?.toString()
                        ?: vuln["created_on"]?.toString()
                        ?: LocalDateTime.now().toString()
                    val detectedAt = try {
                        LocalDateTime.parse(createdTimestamp.replace(" ", "T"))
                    } catch (e: Exception) {
                        LocalDateTime.now()
                    }

                    // Days open
                    val daysOpen = calculateDaysOpen(detectedAt)

                    // Status
                    val status = vuln["status"]?.toString() ?: "open"

                    CrowdStrikeVulnerabilityDto(
                        id = id,
                        hostname = hostname,
                        ip = ip,
                        cveId = cveId,
                        severity = severity,
                        cvssScore = cvssScore,
                        affectedProduct = affectedProduct,
                        daysOpen = daysOpen,
                        detectedAt = detectedAt,
                        status = status,
                        hasException = false,  // Will be updated by checkExceptions()
                        exceptionReason = null
                    )
                } catch (e: Exception) {
                    log.warn("Failed to map vulnerability: {}", e.message, e)
                    null
                }
            }
        } catch (e: Exception) {
            log.error("Failed to map CrowdStrike response to DTOs", e)
            throw CrowdStrikeError.ServerError(message = "Failed to parse API response: ${e.message}", cause = e)
        }
    }

    /**
     * Check vulnerabilities against active exceptions
     *
     * Task: T025 [US1-Impl]
     *
     * @param vulnerabilities List of vulnerabilities
     * @return Updated list with exception status
     */
    private fun checkExceptions(vulnerabilities: List<CrowdStrikeVulnerabilityDto>): List<CrowdStrikeVulnerabilityDto> {
        log.debug("Checking {} vulnerabilities against active exceptions", vulnerabilities.size)

        // Load all active exceptions
        val activeExceptions = vulnerabilityExceptionRepository.findAll()
            .filter { it.isActive() }

        if (activeExceptions.isEmpty()) {
            log.debug("No active exceptions found")
            return vulnerabilities
        }

        // Check each vulnerability against exceptions
        return vulnerabilities.map { vuln ->
            val matchingException = activeExceptions.firstOrNull { exception ->
                // IP-based exception
                if (exception.exceptionType == com.secman.domain.VulnerabilityException.ExceptionType.IP) {
                    vuln.ip == exception.targetValue
                }
                // Product-based exception
                else if (exception.exceptionType == com.secman.domain.VulnerabilityException.ExceptionType.PRODUCT) {
                    vuln.affectedProduct?.contains(exception.targetValue, ignoreCase = true) == true
                } else {
                    false
                }
            }

            if (matchingException != null) {
                log.debug("Vulnerability {} matches exception: {}", vuln.id, matchingException.reason)
                vuln.copy(
                    hasException = true,
                    exceptionReason = matchingException.reason
                )
            } else {
                vuln
            }
        }
    }

    /**
     * Save vulnerabilities to database
     *
     * Task: T050 [US3-Impl]
     *
     * @param hostname System hostname
     * @param vulnerabilities List of vulnerabilities to save
     * @return CrowdStrikeSaveResponse with save results
     */
    fun saveToDatabase(hostname: String, vulnerabilities: List<CrowdStrikeVulnerabilityDto>): CrowdStrikeSaveResponse {
        require(hostname.isNotBlank()) { "Hostname cannot be blank" }
        require(vulnerabilities.isNotEmpty()) { "At least one vulnerability is required" }

        log.info("Saving {} vulnerabilities to database: hostname={}", vulnerabilities.size, hostname)

        var vulnerabilitiesSaved = 0
        var assetsCreated = 0
        val errors = mutableListOf<String>()

        for (vuln in vulnerabilities) {
            try {
                // Find or create asset
                val asset = findOrCreateAsset(vuln.hostname, vuln.ip)
                if (asset.id == null || assetRepository.count() > 0) {
                    // Check if this was a new asset
                    // TODO: Better way to track if asset was newly created
                }

                // Create Vulnerability entity
                val vulnerability = Vulnerability(
                    asset = asset,
                    vulnerabilityId = vuln.cveId,
                    cvssSeverity = vuln.severity,
                    vulnerableProductVersions = vuln.affectedProduct,
                    daysOpen = vuln.daysOpen,
                    scanTimestamp = vuln.detectedAt
                )

                // Save vulnerability
                vulnerabilityRepository.save(vulnerability)
                vulnerabilitiesSaved++

                log.debug("Saved vulnerability: id={}, cve={}, asset={}", vuln.id, vuln.cveId, asset.name)
            } catch (e: Exception) {
                val errorMsg = "Failed to save ${vuln.cveId}: ${e.message}"
                log.error(errorMsg, e)
                errors.add(errorMsg)
            }
        }

        val message = buildSaveMessage(hostname, vulnerabilitiesSaved, assetsCreated)
        log.info("Save complete: {}", message)

        return CrowdStrikeSaveResponse(
            message = message,
            vulnerabilitiesSaved = vulnerabilitiesSaved,
            assetsCreated = assetsCreated,
            errors = errors
        )
    }

    /**
     * Find or create asset by hostname and IP
     *
     * Task: T049 [US3-Impl]
     *
     * @param hostname System hostname
     * @param ip System IP address (nullable)
     * @return Found or created Asset
     */
    private fun findOrCreateAsset(hostname: String, ip: String?): Asset {
        // Search by hostname (case-insensitive)
        val byHostname = assetRepository.findByName(hostname)
        if (byHostname.isPresent) {
            log.debug("Found asset by hostname: {}", hostname)
            return byHostname.get()
        }

        // Search by IP if provided
        if (ip != null) {
            val byIp = assetRepository.findByIp(ip)
            if (byIp.isNotEmpty()) {
                log.debug("Found asset by IP: {}", ip)
                return byIp.first()
            }
        }

        // Create new asset with defaults
        log.info("Creating new asset: hostname={}, ip={}", hostname, ip)
        val newAsset = Asset(
            name = hostname,
            ip = ip,
            type = "Endpoint",
            owner = "CrowdStrike",
            description = "",
            lastSeen = LocalDateTime.now()
        )

        return assetRepository.save(newAsset)
    }

    /**
     * Build save message
     */
    private fun buildSaveMessage(hostname: String, saved: Int, created: Int): String {
        val baseMsg = "Saved $saved vulnerabilities for system '$hostname'"
        return if (created > 0) {
            "$baseMsg. Created new asset."
        } else {
            baseMsg
        }
    }
}
