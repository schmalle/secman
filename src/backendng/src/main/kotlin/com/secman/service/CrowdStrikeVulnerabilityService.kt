package com.secman.service

import com.secman.domain.Asset
import com.secman.domain.Vulnerability
import com.secman.dto.*
import com.secman.repository.AssetRepository
import com.secman.repository.FalconConfigRepository
import com.secman.repository.UserRepository
import com.secman.repository.VulnerabilityExceptionRepository
import com.secman.repository.VulnerabilityRepository
import io.micronaut.http.HttpRequest
import io.micronaut.http.HttpResponse
import io.micronaut.http.client.HttpClient
import io.micronaut.http.client.annotation.Client
import io.micronaut.http.uri.UriBuilder
import io.micronaut.retry.annotation.Retryable
import io.micronaut.security.authentication.Authentication
import jakarta.inject.Singleton
import jakarta.transaction.Transactional
import org.slf4j.LoggerFactory
import java.time.LocalDateTime
import java.time.temporal.ChronoUnit

/**
 * Service for integrating with CrowdStrike Falcon API
 *
 * Provides functionality to:
 * - Query CrowdStrike for system vulnerabilities (last 40 days, OPEN status)
 * - Authenticate with OAuth2 client credentials flow
 * - Cache OAuth2 tokens (30 minutes)
 * - Map CrowdStrike response to internal DTOs
 * - Check against VulnerabilityException table
 * - Save vulnerabilities to database
 *
 * Related to: Feature 015-we-have-currently (CrowdStrike System Vulnerability Lookup)
 * Tasks: T018-T026 [US1-Impl], T049-T050 [US3-Impl]
 */
@Singleton
open class CrowdStrikeVulnerabilityService(
    @Client("\${secman.http.services.crowdstrike.base-urls.us-1}")
    private val crowdStrikeClient: HttpClient,
    private val falconConfigRepository: FalconConfigRepository,
    private val assetRepository: AssetRepository,
    private val vulnerabilityRepository: VulnerabilityRepository,
    private val vulnerabilityExceptionRepository: VulnerabilityExceptionRepository,
    private val userRepository: UserRepository
) {
    private val log = LoggerFactory.getLogger(CrowdStrikeVulnerabilityService::class.java)

    // OAuth2 token cache
    private var cachedToken: String? = null
    private var tokenExpiresAt: LocalDateTime? = null

    // FalconConfig cache (avoids repeated DB queries)
    private var cachedConfig: com.secman.domain.FalconConfig? = null

    /**
     * Query CrowdStrike for vulnerabilities by hostname
     *
     * Task: T026 [US1-Impl]
     *
     * @param hostname System hostname to query
     * @return CrowdStrikeQueryResponse with vulnerabilities
     * @throws CrowdStrikeError.ConfigurationError if credentials not configured
     * @throws CrowdStrikeError.AuthenticationError if OAuth2 fails
     * @throws CrowdStrikeError.NotFoundError if hostname not found
     * @throws CrowdStrikeError.RateLimitError if rate limit exceeded
     * @throws CrowdStrikeError.NetworkError if network issues
     * @throws CrowdStrikeError.ServerError if CrowdStrike service unavailable
     */
    fun queryByHostname(hostname: String): CrowdStrikeQueryResponse {
        require(hostname.isNotBlank()) { "Hostname cannot be blank" }

        log.info("Querying CrowdStrike for vulnerabilities: hostname={}", hostname)

        try {
            // 1. Authenticate
            val token = authenticateWithCrowdStrike()

            // 2. Query Spotlight API
            val apiResponse = queryCrowdStrikeApi(hostname, token)

            // 3. Map to DTOs
            val vulnerabilityDtos = mapToDtos(apiResponse)

            // 4. Check exceptions
            val vulnsWithExceptions = checkExceptions(vulnerabilityDtos)

            log.info("Successfully queried CrowdStrike: hostname={}, count={}", hostname, vulnsWithExceptions.size)

            return CrowdStrikeQueryResponse(
                hostname = hostname,
                vulnerabilities = vulnsWithExceptions,
                totalCount = vulnsWithExceptions.size,
                queriedAt = LocalDateTime.now()
            )
        } catch (e: CrowdStrikeError) {
            log.error("CrowdStrike query failed: hostname={}, error={}", hostname, e.message)
            throw e
        } catch (e: Exception) {
            log.error("Unexpected error querying CrowdStrike: hostname={}", hostname, e)
            throw CrowdStrikeError.ServerError(message = "Unexpected error: ${e.message}", cause = e)
        }
    }

    /**
     * Load CrowdStrike configuration from database
     *
     * Task: T019 [US1-Impl]
     *
     * @return FalconConfig with credentials
     * @throws CrowdStrikeError.ConfigurationError if no config found
     */
    private fun loadFalconConfig(): com.secman.domain.FalconConfig {
        // Return cached config if available
        if (cachedConfig != null) {
            return cachedConfig!!
        }

        log.debug("Loading FalconConfig from database")

        // Try to find active config
        val activeConfig = falconConfigRepository.findActiveConfig()
        if (activeConfig.isPresent) {
            log.debug("Found active FalconConfig: id={}", activeConfig.get().id)
            cachedConfig = activeConfig.get()
            return activeConfig.get()
        }

        // Fallback: Find most recent config
        val recentConfig = falconConfigRepository.findMostRecent()
        if (recentConfig.isPresent) {
            log.warn("No active FalconConfig found, using most recent: id={}", recentConfig.get().id)
            cachedConfig = recentConfig.get()
            return recentConfig.get()
        }

        // No config found
        log.error("No FalconConfig found in database")
        throw CrowdStrikeError.ConfigurationError("CrowdStrike API credentials not configured in database. Contact administrator.")
    }

    /**
     * Authenticate with CrowdStrike using OAuth2 client credentials
     *
     * Task: T020 [US1-Impl]
     *
     * @return OAuth2 access token
     * @throws CrowdStrikeError.ConfigurationError if credentials not configured
     * @throws CrowdStrikeError.AuthenticationError if auth fails
     */
    private fun authenticateWithCrowdStrike(): String {
        // Check if cached token is still valid
        if (cachedToken != null && tokenExpiresAt != null && LocalDateTime.now().isBefore(tokenExpiresAt)) {
            log.debug("Using cached OAuth2 token")
            return cachedToken!!
        }

        log.debug("Authenticating with CrowdStrike (OAuth2 client credentials)")

        // Load credentials from database
        val config = loadFalconConfig()

        try {
            // Build OAuth2 token request
			val baseUrl ="https://api.crowdstrike.com"
            val tokenRequest = HttpRequest.POST(baseUrl + "/oauth2/token", mapOf(
                "client_id" to config.clientId,
                "client_secret" to config.clientSecret
            ))
                .contentType(io.micronaut.http.MediaType.APPLICATION_FORM_URLENCODED)

            // Make OAuth2 request
            val response = crowdStrikeClient.toBlocking().exchange(tokenRequest, Map::class.java)

            if (response.status.code != 201) {

				log.error("OAuth2 authentication failed: status={}, code={}", response.status, response.status.code)
				log.debug("Authenticating with CrowdStrike (OAuth2 client credentials), client_id={}, client_secret={}", config.clientId, config.clientSecret)

                throw CrowdStrikeError.AuthenticationError("CrowdStrike authentication failed with status ${response.status}")
            }

            val tokenData = response.body() as Map<*, *>
            val accessToken = tokenData["access_token"]?.toString()
                ?: throw CrowdStrikeError.AuthenticationError("No access_token in response")

            val expiresIn = (tokenData["expires_in"] as? Number)?.toLong() ?: 1800L

            // Cache token (subtract 60 seconds for safety margin)
            cachedToken = accessToken
            tokenExpiresAt = LocalDateTime.now().plusSeconds(expiresIn - 60)

            log.info("Successfully authenticated with CrowdStrike, token expires at {}", tokenExpiresAt)
            return accessToken
        } catch (e: io.micronaut.http.client.exceptions.HttpClientResponseException) {
            log.error("HTTP error during authentication: status={}", e.status, e)
            if (e.status.code == 401 || e.status.code == 403) {
                throw CrowdStrikeError.AuthenticationError("Invalid CrowdStrike credentials", e)
            }
            throw CrowdStrikeError.AuthenticationError("Authentication failed: ${e.message}", e)
        } catch (e: CrowdStrikeError) {
            throw e
        } catch (e: Exception) {
            log.error("Unexpected error during authentication", e)
            throw CrowdStrikeError.AuthenticationError("Authentication error: ${e.message}", e)
        }
    }

    /**
     * Get device ID (aid) by hostname
     *
     * Task: T021-FIX [Bug fix - hostname to device ID lookup]
     *
     * CrowdStrike Spotlight API doesn't support filtering by hostname directly.
     * Must first query Hosts API to get the device ID (aid).
     *
     * Uses multi-strategy approach with fallback:
     * 1. Stemmed search (case-insensitive, starts with): hostname:'value*'
     * 2. Contains search (case-insensitive, anywhere): hostname:*'*value*'
     * 3. Exact match (case-sensitive): hostname:['value']
     * 4. Fallback: Get all devices and filter locally (case-insensitive)
     *
     * @param hostname System hostname
     * @param token OAuth2 access token
     * @return Device ID (aid) or null if not found
     * @throws CrowdStrikeError.NetworkError if network issues
     * @throws CrowdStrikeError.ServerError if server error (500+)
     */
    private fun getDeviceIdByHostname(hostname: String, token: String): String? {
        log.info("Looking up device ID for hostname: {}", hostname)

        // Strategy 1: Stemmed search (case-insensitive, starts with) - RECOMMENDED by CrowdStrike
        log.debug("Strategy 1: Trying stemmed search (starts with, case-insensitive)")
        val stemmedResult = tryHostnameFilter(hostname, "hostname:'$hostname*'", token)
        if (stemmedResult != null) {
            log.info("Found device ID using stemmed search: {}", stemmedResult)
            return stemmedResult
        }

        // Strategy 2: Contains search (case-insensitive, anywhere in hostname)
        log.debug("Strategy 2: Trying contains search (anywhere, case-insensitive)")
        val containsResult = tryHostnameFilter(hostname, "hostname:*'*$hostname*'", token)
        if (containsResult != null) {
            log.info("Found device ID using contains search: {}", containsResult)
            return containsResult
        }

        // Strategy 3: Exact match (case-sensitive with square brackets)
        log.debug("Strategy 3: Trying exact match (case-sensitive)")
        val exactResult = tryHostnameFilter(hostname, "hostname:['$hostname']", token)
        if (exactResult != null) {
            log.info("Found device ID using exact match: {}", exactResult)
            return exactResult
        }

        // Strategy 4: Fallback - Get all devices and filter locally (case-insensitive)
        log.warn("All filter strategies failed. Attempting fallback: get all devices and filter locally")
        val fallbackResult = getAllDevicesAndFilterByHostname(hostname, token)
        if (fallbackResult != null) {
            log.info("Found device ID using local filtering: {}", fallbackResult)
            return fallbackResult
        }

        log.warn("All strategies exhausted. No device found for hostname: {}", hostname)
        return null
    }

    /**
     * Try a single hostname filter strategy
     *
     * @param hostname Original hostname (for logging)
     * @param filter FQL filter string
     * @param token OAuth2 access token
     * @return Device ID or null if not found
     */
    @Suppress("UNCHECKED_CAST")
    private fun tryHostnameFilter(hostname: String, filter: String, token: String): String? {
        try {
            // Build request URL with proper encoding
            val baseUrl = "https://api.crowdstrike.com"
            val uri = UriBuilder.of("/devices/queries/devices/v1")
                .queryParam("filter", filter)
                .queryParam("limit", "10")  // Get up to 10 matches
                .build()

            val fullUrl = baseUrl + uri.toString()
            log.debug("Trying filter: {} | Full URL: {}", filter, fullUrl)

            val request = HttpRequest.GET<Any>(fullUrl)
                .header("Authorization", "Bearer $token")
                .header("Accept", "application/json")

            // Make API request
            val response = crowdStrikeClient.toBlocking().exchange(request, Map::class.java)

            when (response.status.code) {
                200 -> {
                    val responseBody = response.body() as? Map<String, Any>
                        ?: throw CrowdStrikeError.ServerError(message = "Empty response from CrowdStrike Hosts API")

                    // Extract device IDs from response
                    val resources = responseBody["resources"] as? List<*>
                    if (resources.isNullOrEmpty()) {
                        log.debug("Filter returned 0 results: {}", filter)
                        return null
                    }

                    val deviceId = resources[0]?.toString()
                    log.debug("Filter returned {} results. Using first device ID: {}", resources.size, deviceId)
                    return deviceId
                }
                429 -> {
                    val retryAfter = response.headers.get("Retry-After")?.toIntOrNull() ?: 30
                    log.warn("CrowdStrike rate limit exceeded during device lookup, retry after {} seconds", retryAfter)
                    throw CrowdStrikeError.RateLimitError(retryAfter)
                }
                in 500..599 -> {
                    log.error("CrowdStrike server error during device lookup: status={}", response.status)
                    throw CrowdStrikeError.ServerError(response.status.code)
                }
                else -> {
                    log.error("Unexpected CrowdStrike response during device lookup: status={}", response.status)
                    throw CrowdStrikeError.ServerError(
                        statusCode = response.status.code,
                        message = "Unexpected response: ${response.status}"
                    )
                }
            }
        } catch (e: io.micronaut.http.client.exceptions.HttpClientResponseException) {
            when (e.status.code) {
                429 -> {
                    val retryAfter = e.response.headers.get("Retry-After")?.toIntOrNull() ?: 30
                    throw CrowdStrikeError.RateLimitError(retryAfter, cause = e)
                }
                in 500..599 -> throw CrowdStrikeError.ServerError(e.status.code, cause = e)
                else -> {
                    log.warn("Filter failed with status {}: {}", e.status.code, filter)
                    return null  // Don't throw, try next strategy
                }
            }
        } catch (e: CrowdStrikeError) {
            throw e
        } catch (e: java.net.SocketTimeoutException) {
            log.error("Network timeout querying CrowdStrike Hosts API", e)
            throw CrowdStrikeError.NetworkError(cause = e)
        } catch (e: java.io.IOException) {
            log.error("Network error querying CrowdStrike Hosts API", e)
            throw CrowdStrikeError.NetworkError(cause = e)
        } catch (e: Exception) {
            log.error("Unexpected error querying CrowdStrike Hosts API", e)
            return null  // Don't throw, try next strategy
        }
    }

    /**
     * Fallback strategy: Get all devices and filter by hostname locally (case-insensitive)
     *
     * @param hostname System hostname to find
     * @param token OAuth2 access token
     * @return Device ID or null if not found
     */
    @Suppress("UNCHECKED_CAST")
    private fun getAllDevicesAndFilterByHostname(hostname: String, token: String): String? {
        try {
            log.debug("Fallback: Getting all devices (no filter) and filtering locally")

            val baseUrl = "https://api.crowdstrike.com"
            val uri = UriBuilder.of("/devices/queries/devices/v1")
                .queryParam("limit", "5000")  // Max limit for single request
                .build()

            val fullUrl = baseUrl + uri.toString()
            log.debug("Fallback URL: {}", fullUrl)

            val request = HttpRequest.GET<Any>(fullUrl)
                .header("Authorization", "Bearer $token")
                .header("Accept", "application/json")

            val response = crowdStrikeClient.toBlocking().exchange(request, Map::class.java)

            if (response.status.code == 200) {
                val responseBody = response.body() as? Map<String, Any>
                    ?: throw CrowdStrikeError.ServerError(message = "Empty response from CrowdStrike Hosts API")

                val deviceIds = responseBody["resources"] as? List<*>
                if (deviceIds.isNullOrEmpty()) {
                    log.warn("Fallback: No devices found in CrowdStrike")
                    return null
                }

                log.debug("Fallback: Retrieved {} device IDs. Fetching device details...", deviceIds.size)

                // Get device details to find hostname match
                // Note: This would require calling /devices/entities/devices/v1 with IDs
                // For now, we'll just warn and return null (full implementation would need details API)
                log.warn("Fallback: Device details API not implemented. Cannot filter {} devices locally", deviceIds.size)
                log.warn("Fallback: Consider implementing /devices/entities/devices/v1 call to get device details with hostnames")

                return null
            } else {
                log.error("Fallback: Unexpected response status: {}", response.status)
                return null
            }
        } catch (e: Exception) {
            log.error("Fallback: Failed to get all devices", e)
            return null
        }
    }

    /**
     * Query CrowdStrike Spotlight API for vulnerabilities
     *
     * Task: T021 [US1-Impl] - Updated to use device ID instead of hostname
     *
     * @param hostname System hostname
     * @param token OAuth2 access token
     * @return Raw API response JSON
     * @throws CrowdStrikeError.NotFoundError if hostname not found (404)
     * @throws CrowdStrikeError.RateLimitError if rate limit exceeded (429)
     * @throws CrowdStrikeError.ServerError if server error (500+)
     * @throws CrowdStrikeError.NetworkError if network issues
     */
    @Suppress("UNCHECKED_CAST")
    @Retryable(includes = [CrowdStrikeError.RateLimitError::class], attempts = "3", delay = "1s", multiplier = "2.0")
    open fun queryCrowdStrikeApi(hostname: String, token: String): Map<String, Any> {
        log.debug("Querying CrowdStrike Spotlight API: hostname={}", hostname)

        // Step 1: Get device ID from hostname (declare outside try block for catch block access)
        val deviceId = try {
            val id = getDeviceIdByHostname(hostname, token)
            if (id == null) {
                log.warn("Core error, initial calls failed... Hostname not found in CrowdStrike: {}", hostname)
                log.warn("Hostname not found in CrowdStrike: {}", hostname)
                throw CrowdStrikeError.NotFoundError(hostname)
            }
            id
        } catch (e: CrowdStrikeError) {
            throw e
        } catch (e: Exception) {
            log.error("Failed to lookup device ID for hostname: {}", hostname, e)
            throw CrowdStrikeError.ServerError(message = "Device lookup failed: ${e.message}", cause = e)
        }

        log.info("Using device ID '{}' for hostname '{}'", deviceId, hostname)

        try {

            // Calculate 40 days ago timestamp in ISO 8601 format
            val fortyDaysAgo = LocalDateTime.now().minusDays(40)
            // Format: 2025-09-02T22:10:32Z (ISO 8601 with 'T' separator and 'Z' suffix)
            // Truncate nanoseconds to seconds for better API compatibility
            val timestampFilter = fortyDaysAgo.toString().substring(0, 19) + "Z"

            log.debug("Using timestamp filter: {}", timestampFilter)

            // Build filter query: aid:'<device_id>'+status:'open'
            val filter = "aid:'$deviceId'+status:'open'"

            // Build request URL - Using v1 endpoint (documented version)
            val baseUrl = "https://api.crowdstrike.com"
            val uri = UriBuilder.of("/spotlight/combined/vulnerabilities/v1")
                .queryParam("filter", filter)
                .queryParam("limit", "5000")  // Max results per CrowdStrike docs
                .queryParam("facet", "cve")  // Include detailed CVE information with CVSS and severity
                .build()

            val fullUrl = baseUrl + uri.toString()
            log.debug("CrowdStrike Spotlight API request: url={}, filter={}, facet=cve", fullUrl, filter)

            val request = HttpRequest.GET<Any>(fullUrl)
                .header("Authorization", "Bearer $token")
                .header("Accept", "application/json")

            // Make API request
            val response = crowdStrikeClient.toBlocking().exchange(request, Map::class.java)

            when (response.status.code) {
                200 -> {
                    val responseBody = response.body() as? Map<String, Any>
                        ?: throw CrowdStrikeError.ServerError(message = "Empty response from CrowdStrike")

                    val resources = responseBody["resources"] as? List<*>
                    val resourceCount = resources?.size ?: 0
                    log.info("CrowdStrike Spotlight API response: status=200, vulnerabilities found={}", resourceCount)

                    if (resourceCount == 0) {
                        log.info("Device '{}' (aid: {}) has no open vulnerabilities", hostname, deviceId)
                    }

                    return responseBody
                }
                404 -> {
                    // 404 from Spotlight API typically means no vulnerabilities found (not device not found)
                    // Device lookup already succeeded, so treat this as "no vulnerabilities"
                    log.info("Spotlight API returned 404 for device '{}' (aid: {}). Treating as no vulnerabilities.", hostname, deviceId)

                    // Return empty response structure
                    return mapOf(
                        "resources" to emptyList<Any>(),
                        "meta" to mapOf("total" to 0)
                    )
                }
                429 -> {
                    val retryAfter = response.headers.get("Retry-After")?.toIntOrNull() ?: 30
                    log.warn("CrowdStrike rate limit exceeded, retry after {} seconds", retryAfter)
                    throw CrowdStrikeError.RateLimitError(retryAfter)
                }
                in 500..599 -> {
                    log.error("CrowdStrike server error: status={}", response.status)
                    throw CrowdStrikeError.ServerError(response.status.code)
                }
                else -> {
                    log.error("Unexpected CrowdStrike response: status={}", response.status)
                    throw CrowdStrikeError.ServerError(
                        statusCode = response.status.code,
                        message = "Unexpected response: ${response.status}"
                    )
                }
            }
        } catch (e: io.micronaut.http.client.exceptions.HttpClientResponseException) {
            when (e.status.code) {
                404 -> {
                    // 404 from Spotlight API - device has no vulnerabilities
                    log.info("Spotlight API returned 404 for device '{}' (aid: {}). Response: {}", hostname, deviceId, e.response.body.orElse(null))

                    // Return empty response structure instead of throwing error
                    return mapOf(
                        "resources" to emptyList<Any>(),
                        "meta" to mapOf("total" to 0)
                    )
                }
                429 -> {
                    val retryAfter = e.response.headers.get("Retry-After")?.toIntOrNull() ?: 30
                    throw CrowdStrikeError.RateLimitError(retryAfter, cause = e)
                }
                in 500..599 -> throw CrowdStrikeError.ServerError(e.status.code, cause = e)
                else -> {
                    log.error("Spotlight API error: status={}, message={}, response={}", e.status.code, e.message, e.response.body.orElse(null))
                    throw CrowdStrikeError.ServerError(e.status.code, "API error: ${e.message}", e)
                }
            }
        } catch (e: CrowdStrikeError) {
            throw e
        } catch (e: java.net.SocketTimeoutException) {
            log.error("Network timeout querying CrowdStrike", e)
            throw CrowdStrikeError.NetworkError(cause = e)
        } catch (e: java.io.IOException) {
            log.error("Network error querying CrowdStrike", e)
            throw CrowdStrikeError.NetworkError(cause = e)
        } catch (e: Exception) {
            log.error("Unexpected error querying CrowdStrike API", e)
            throw CrowdStrikeError.ServerError(message = "Unexpected error: ${e.message}", cause = e)
        }
    }

    /**
     * Map CVSS score to severity level
     *
     * Task: T022 [US1-Impl]
     *
     * @param score CVSS score (0.0-10.0)
     * @return Severity level (Critical, High, Medium, Low, Unknown)
     */
    private fun mapCvssScoreToSeverity(score: Double?): String {
        return when {
            score == null -> "Unknown"
            score >= 9.0 -> "Critical"
            score >= 7.0 -> "High"
            score >= 4.0 -> "Medium"
            score >= 0.1 -> "Low"
            else -> "Unknown"
        }
    }

    /**
     * Normalize severity string from CrowdStrike API
     * Handles various formats: CRITICAL, critical, Critical, etc.
     *
     * @param apiSeverity Raw severity string from API
     * @return Normalized severity (Critical, High, Medium, Low, Informational, Unknown)
     */
    private fun normalizeSeverity(apiSeverity: String): String {
        return when (apiSeverity.uppercase()) {
            "CRITICAL" -> "Critical"
            "HIGH" -> "High"
            "MEDIUM", "MODERATE" -> "Medium"
            "LOW" -> "Low"
            "INFORMATIONAL", "INFO" -> "Informational"
            else -> apiSeverity.replaceFirstChar { it.uppercase() } // Capitalize first letter
        }
    }

    /**
     * Parse detection timestamp from CrowdStrike vulnerability data
     * Handles multiple timestamp formats and field names
     *
     * @param vuln Vulnerability map from CrowdStrike API
     * @return Parsed LocalDateTime
     */
    private fun parseDetectionTimestamp(vuln: Map<*, *>): LocalDateTime {
        // Try different field names
        val timestampValue = vuln["created_timestamp"]
            ?: vuln["created_on"]
            ?: vuln["cve_created_timestamp"]
            ?: vuln["first_found_date"]
            ?: vuln["remediation"]?.let { (it as? Map<*, *>)?.get("created_timestamp") }

        if (timestampValue == null) {
            log.warn("No timestamp field found in vulnerability, using current time")
            return LocalDateTime.now()
        }

        // Try to parse as epoch milliseconds (number)
        if (timestampValue is Number) {
            return try {
                val epochSeconds = timestampValue.toLong()
                // Handle both seconds and milliseconds
                val instant = if (epochSeconds > 10000000000L) {
                    java.time.Instant.ofEpochMilli(epochSeconds)
                } else {
                    java.time.Instant.ofEpochSecond(epochSeconds)
                }
                LocalDateTime.ofInstant(instant, java.time.ZoneId.systemDefault())
            } catch (e: Exception) {
                log.warn("Failed to parse epoch timestamp: {}", timestampValue, e)
                LocalDateTime.now()
            }
        }

        // Try to parse as ISO string
        val timestampString = timestampValue.toString()
        return try {
            // Try ISO format with various patterns
            when {
                timestampString.contains("T") -> LocalDateTime.parse(timestampString.substringBefore(".").substringBefore("Z"))
                timestampString.contains(" ") -> LocalDateTime.parse(timestampString.replace(" ", "T").substringBefore("."))
                else -> {
                    log.warn("Unknown timestamp format: {}", timestampString)
                    LocalDateTime.now()
                }
            }
        } catch (e: Exception) {
            log.warn("Failed to parse timestamp string: {}", timestampString, e)
            LocalDateTime.now()
        }
    }

    /**
     * Calculate days open since detection
     *
     * Task: T023 [US1-Impl]
     *
     * @param detectedAt Detection timestamp
     * @return Days open string (e.g., "15 days")
     */
    private fun calculateDaysOpen(detectedAt: LocalDateTime): String {
        val days = ChronoUnit.DAYS.between(detectedAt, LocalDateTime.now())
        return if (days == 1L) "1 day" else "$days days"
    }

    /**
     * Map CrowdStrike API response to DTOs
     *
     * Task: T024 [US1-Impl]
     *
     * @param apiResponse Raw API response
     * @return List of CrowdStrikeVulnerabilityDto
     */
    private fun mapToDtos(apiResponse: Map<String, Any>): List<CrowdStrikeVulnerabilityDto> {
        log.debug("Mapping CrowdStrike API response to DTOs")

        try {
            // Extract resources array from response
            val resources = apiResponse["resources"] as? List<*> ?: emptyList<Any>()

            if (resources.isEmpty()) {
                log.debug("No vulnerabilities found in CrowdStrike response")
                return emptyList()
            }

            log.debug("Mapping {} vulnerabilities from CrowdStrike response", resources.size)

            return resources.mapNotNull { resource ->
                try {
                    val vuln = resource as? Map<*, *> ?: return@mapNotNull null

                    // DEBUG: Log all available fields in vulnerability
                    log.debug("CrowdStrike vulnerability fields: {}", vuln.keys.joinToString(", "))

                    // Extract fields from CrowdStrike response
                    val id = vuln["id"]?.toString() ?: "cs-${System.currentTimeMillis()}"
                    val hostInfo = vuln["host_info"] as? Map<*, *>
                    val deviceInfo = vuln["device"] as? Map<*, *>

                    // Prefer real host metadata before falling back to the CrowdStrike agent ID
                    val hostname = vuln["hostname"]?.toString()
                        ?: hostInfo?.get("hostname")?.toString()
                        ?: hostInfo?.get("host_name")?.toString()
                        ?: deviceInfo?.get("hostname")?.toString()
                        ?: deviceInfo?.get("host_name")?.toString()
                        ?: vuln["aid"]?.toString()
                        ?: ""

                    val ip = vuln["local_ip"]?.toString()
                        ?: hostInfo?.get("local_ip")?.toString()
                        ?: deviceInfo?.get("local_ip")?.toString()

                    // CVE information
                    val cve = vuln["cve"] as? Map<*, *>
                    val cveId = cve?.get("id")?.toString()

                    // DEBUG: Log CVE fields if present
                    if (cve != null) {
                        log.debug("CVE fields: {}", cve.keys.joinToString(", "))
                    }

                    // CVSS score and severity - try multiple field locations
                    // CrowdStrike Spotlight API can return severity in different fields
                    val cvssScore = (vuln["score"] as? Number)?.toDouble()
                        ?: (cve?.get("base_score") as? Number)?.toDouble()
                        ?: (vuln["base_score"] as? Number)?.toDouble()

                    // Try to get severity directly from API, otherwise map from CVSS score
                    val severityFromApi = vuln["severity"]?.toString()
                        ?: cve?.get("severity")?.toString()

                    val severity = when {
                        severityFromApi != null -> normalizeSeverity(severityFromApi)
                        cvssScore != null -> mapCvssScoreToSeverity(cvssScore)
                        else -> "Unknown"
                    }

                    log.debug("Vulnerability {} - severity: {}, cvssScore: {}, severityFromApi: {}",
                        cveId ?: id, severity, cvssScore, severityFromApi)

                    // Affected product
                    val apps = vuln["apps"] as? List<*>
                    val affectedProduct = apps?.mapNotNull { app ->
                        val appMap = app as? Map<*, *>
                        appMap?.get("product_name_version")?.toString()
                    }?.joinToString(", ")

                    // Detection timestamp - try multiple field names and formats
                    val detectedAt = parseDetectionTimestamp(vuln)

                    // Days open
                    val daysOpen = calculateDaysOpen(detectedAt)

                    log.debug("Vulnerability {} - detectedAt: {}, daysOpen: {}",
                        cveId ?: id, detectedAt, daysOpen)

                    // Status
                    val status = vuln["status"]?.toString() ?: "open"

                    CrowdStrikeVulnerabilityDto(
                        id = id,
                        hostname = hostname,
                        ip = ip,
                        cveId = cveId,
                        severity = severity,
                        cvssScore = cvssScore,
                        affectedProduct = affectedProduct,
                        daysOpen = daysOpen,
                        detectedAt = detectedAt,
                        status = status,
                        hasException = false,  // Will be updated by checkExceptions()
                        exceptionReason = null
                    )
                } catch (e: Exception) {
                    log.warn("Failed to map vulnerability: {}", e.message, e)
                    null
                }
            }
        } catch (e: Exception) {
            log.error("Failed to map CrowdStrike response to DTOs", e)
            throw CrowdStrikeError.ServerError(message = "Failed to parse API response: ${e.message}", cause = e)
        }
    }

    /**
     * Check vulnerabilities against active exceptions
     *
     * Task: T025 [US1-Impl]
     *
     * @param vulnerabilities List of vulnerabilities
     * @return Updated list with exception status
     */
    private fun checkExceptions(vulnerabilities: List<CrowdStrikeVulnerabilityDto>): List<CrowdStrikeVulnerabilityDto> {
        log.debug("Checking {} vulnerabilities against active exceptions", vulnerabilities.size)

        // Load all active exceptions
        val activeExceptions = vulnerabilityExceptionRepository.findAll()
            .filter { it.isActive() }

        if (activeExceptions.isEmpty()) {
            log.debug("No active exceptions found")
            return vulnerabilities
        }

        // Check each vulnerability against exceptions
        return vulnerabilities.map { vuln ->
            val matchingException = activeExceptions.firstOrNull { exception ->
                // IP-based exception
                if (exception.exceptionType == com.secman.domain.VulnerabilityException.ExceptionType.IP) {
                    vuln.ip == exception.targetValue
                }
                // Product-based exception
                else if (exception.exceptionType == com.secman.domain.VulnerabilityException.ExceptionType.PRODUCT) {
                    vuln.affectedProduct?.contains(exception.targetValue, ignoreCase = true) == true
                } else {
                    false
                }
            }

            if (matchingException != null) {
                log.debug("Vulnerability {} matches exception: {}", vuln.id, matchingException.reason)
                vuln.copy(
                    hasException = true,
                    exceptionReason = matchingException.reason
                )
            } else {
                vuln
            }
        }
    }

    /**
     * Save vulnerabilities to database with asset auto-creation
     *
     * Feature 030 - CrowdStrike Asset Auto-Creation
     * Tasks: T004, T005, T006, T009, T010
     *
     * @param request Save request with hostname and vulnerabilities
     * @param authentication Current authenticated user
     * @return CrowdStrikeSaveResponse with save results
     */
    @Transactional
    open fun saveToDatabase(request: CrowdStrikeSaveRequest, authentication: Authentication): CrowdStrikeSaveResponse {
        require(request.hostname.isNotBlank()) { "Hostname cannot be blank" }
        require(request.vulnerabilities.isNotEmpty()) { "At least one vulnerability is required" }

        val hostname = request.hostname
        val username = authentication.name
        log.info("Saving {} vulnerabilities to database: hostname={}, user={}", request.vulnerabilities.size, hostname, username)

        var vulnerabilitiesSaved = 0
        var vulnerabilitiesSkipped = 0
        var assetsCreated = 0
        val errors = mutableListOf<String>()

        try {
            // Phase 1: Validate all vulnerabilities first (T010)
            val validVulnerabilities = mutableListOf<CrowdStrikeVulnerabilityDto>()
            for (vuln in request.vulnerabilities) {
                val validationResult = validateVulnerability(vuln)
                if (validationResult.isValid) {
                    validVulnerabilities.add(vuln)
                } else {
                    vulnerabilitiesSkipped++
                    val errorMsg = "Skipped invalid vulnerability: cve=${vuln.cveId}, reason=${validationResult.reason}, hostname=$hostname"
                    log.warn(errorMsg)
                    errors.add(errorMsg)
                }
            }

            if (validVulnerabilities.isEmpty()) {
                log.warn("No valid vulnerabilities to save: hostname={}, user={}", hostname, username)
                return CrowdStrikeSaveResponse(
                    message = "No valid vulnerabilities to save for $hostname",
                    vulnerabilitiesSaved = 0,
                    vulnerabilitiesSkipped = vulnerabilitiesSkipped,
                    assetsCreated = 0,
                    errors = errors
                )
            }

            // Phase 2: Find or create asset (T007, T008)
            val assetResult = findOrCreateAsset(hostname, validVulnerabilities.firstOrNull()?.ip, authentication)
            val asset = assetResult.asset
            if (assetResult.wasCreated) {
                assetsCreated = 1
            }

            // Phase 3: Save valid vulnerabilities with duplicate detection (T009)
            for (vuln in validVulnerabilities) {
                try {
                    val cveId = vuln.cveId ?: "UNKNOWN"

                    // Check for duplicate (T009)
                    val isDuplicate = vulnerabilityRepository.existsByAssetAndVulnerabilityIdAndScanTimestamp(
                        asset, cveId, vuln.detectedAt
                    )

                    if (isDuplicate) {
                        vulnerabilitiesSkipped++
                        val errorMsg = "Skipped duplicate: $cveId already exists for asset $hostname with scan date ${vuln.detectedAt}"
                        log.info(errorMsg)
                        errors.add(errorMsg)
                        continue
                    }

                    // Create Vulnerability entity
                    val vulnerability = Vulnerability(
                        asset = asset,
                        vulnerabilityId = cveId,
                        cvssSeverity = vuln.severity,
                        vulnerableProductVersions = vuln.affectedProduct,
                        daysOpen = vuln.daysOpen,
                        scanTimestamp = vuln.detectedAt
                    )

                    // Save vulnerability
                    vulnerabilityRepository.save(vulnerability)
                    vulnerabilitiesSaved++

                    log.debug("Saved vulnerability: cve={}, asset={}", cveId, asset.name)
                } catch (e: Exception) {
                    vulnerabilitiesSkipped++
                    val errorMsg = "Failed to save ${vuln.cveId ?: "UNKNOWN"}: ${e.message}"
                    log.error(errorMsg, e)
                    errors.add(errorMsg)
                }
            }

            log.info("Saved vulnerabilities: asset={}, saved={}, skipped={}, user={}", hostname, vulnerabilitiesSaved, vulnerabilitiesSkipped, username)

            val message = if (assetsCreated > 0) {
                "Saved $vulnerabilitiesSaved vulnerabilities, skipped $vulnerabilitiesSkipped, created 1 asset for $hostname"
            } else {
                "Saved $vulnerabilitiesSaved vulnerabilities, skipped $vulnerabilitiesSkipped for $hostname"
            }

            return CrowdStrikeSaveResponse(
                message = message,
                vulnerabilitiesSaved = vulnerabilitiesSaved,
                vulnerabilitiesSkipped = vulnerabilitiesSkipped,
                assetsCreated = assetsCreated,
                errors = errors
            )
        } catch (e: Exception) {
            val errorMsg = formatErrorMessage(e, authentication)
            log.error("Failed to save vulnerabilities: hostname={}, user={}, error={}", hostname, username, errorMsg, e)
            throw e
        }
    }

    /**
     * Validate vulnerability data
     * Feature 030 - Task T006
     *
     * @param vuln Vulnerability DTO to validate
     * @return ValidationResult with isValid flag and reason
     */
    private fun validateVulnerability(vuln: CrowdStrikeVulnerabilityDto): ValidationResult {
        // CVE ID format validation (if present)
        if (vuln.cveId != null && vuln.cveId.isNotBlank() && !vuln.cveId.matches(Regex("CVE-\\d{4}-\\d{4,}"))) {
            return ValidationResult(false, "Invalid CVE ID format: ${vuln.cveId}")
        }

        // Severity validation
        val validSeverities = setOf("Critical", "High", "Medium", "Low", "Informational", "Unknown")
        if (vuln.severity !in validSeverities) {
            return ValidationResult(false, "Invalid severity: ${vuln.severity}")
        }

        // Days open validation (if present) - daysOpen is String like "15 days"
        if (vuln.daysOpen != null) {
            try {
                val daysNum = vuln.daysOpen.split(" ")[0].toIntOrNull()
                if (daysNum != null && daysNum < 0) {
                    return ValidationResult(false, "Invalid days open (negative): ${vuln.daysOpen}")
                }
            } catch (e: Exception) {
                // Ignore parse errors, days open is optional validation
            }
        }

        return ValidationResult(true, null)
    }

    /**
     * Format error message based on user role
     * Feature 030 - Task T011
     *
     * @param exception Exception to format
     * @param authentication Current authenticated user
     * @return Formatted error message (technical for ADMIN, generic for users)
     */
    private fun formatErrorMessage(exception: Exception, authentication: Authentication): String {
        val isAdmin = authentication.roles.contains("ADMIN")
        return if (isAdmin) {
            exception.message ?: "Unknown error"
        } else {
            "Database error"
        }
    }

    /**
     * Validation result data class
     */
    private data class ValidationResult(
        val isValid: Boolean,
        val reason: String?
    )

    /**
     * Find or create asset by hostname and IP with auto-creation
     *
     * Feature 030 - CrowdStrike Asset Auto-Creation
     * Tasks: T007, T008
     *
     * @param hostname System hostname
     * @param ip System IP address (nullable)
     * @param authentication Current authenticated user
     * @return AssetResult with asset and creation flag
     */
    private fun findOrCreateAsset(hostname: String, ip: String?, authentication: Authentication): AssetResult {
        val username = authentication.name

        // Search by hostname (case-insensitive) - T007
        val existingAsset = assetRepository.findByNameIgnoreCase(hostname)
        if (existingAsset != null) {
            log.debug("Found asset by hostname: {}", hostname)

            // T008: Update IP address if different
            if (ip != null && existingAsset.ip != ip) {
                log.info("Updating asset IP: name={}, oldIp={}, newIp={}", existingAsset.name, existingAsset.ip, ip)
                existingAsset.ip = ip
                existingAsset.updatedAt = LocalDateTime.now()
                assetRepository.update(existingAsset)
            }

            return AssetResult(existingAsset, wasCreated = false)
        }

        // T007: Create new asset with user attribution
        log.info("Creating new asset: hostname={}, ip={}, owner={}, user={}", hostname, ip, username, username)

        // Lookup user entity for manualCreator
        val user = userRepository.findByUsername(username).orElse(null)

        val newAsset = Asset(
            name = hostname,
            ip = ip,
            type = "Server",  // T007: Changed from "Endpoint" to "Server"
            owner = username,  // T007: Changed from "CrowdStrike" to authenticated user
            description = "",
            lastSeen = LocalDateTime.now()
        )

        // T007: Set manualCreator to authenticated user
        if (user != null) {
            newAsset.manualCreator = user
        }

        val savedAsset = assetRepository.save(newAsset)
        log.info("Created asset: name={}, ip={}, owner={}, user={}", savedAsset.name, savedAsset.ip, savedAsset.owner, username)

        return AssetResult(savedAsset, wasCreated = true)
    }

    /**
     * Asset result data class
     */
    private data class AssetResult(
        val asset: Asset,
        val wasCreated: Boolean
    )

    /**
     * Build save message
     */
    private fun buildSaveMessage(hostname: String, saved: Int, created: Int): String {
        val baseMsg = "Saved $saved vulnerabilities for system '$hostname'"
        return if (created > 0) {
            "$baseMsg. Created new asset."
        } else {
            baseMsg
        }
    }
}
