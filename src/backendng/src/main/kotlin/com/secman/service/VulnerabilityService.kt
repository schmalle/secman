package com.secman.service

import com.secman.domain.Asset
import com.secman.domain.Vulnerability
import com.secman.domain.VulnerabilityException
import com.secman.dto.OverdueStatus
import com.secman.dto.VulnerabilityWithExceptionDto
import com.secman.repository.VulnerabilityRepository
import com.secman.repository.VulnerabilityExceptionRepository
import jakarta.inject.Singleton
import org.slf4j.LoggerFactory
import java.time.LocalDateTime
import java.time.temporal.ChronoUnit

/**
 * Service for vulnerability operations and filtering
 *
 * Handles:
 * - Querying current vulnerabilities (latest scan per asset)
 * - Filtering by severity, system, exception status, overdue status
 * - Checking exception status per vulnerability
 * - Calculating overdue status based on configurable threshold
 *
 * Related to: Feature 004-i-want-to (VULN Role & Vulnerability Management UI)
 * Related to: Feature 021-vulnerability-overdue-exception-logic
 */
@Singleton
class VulnerabilityService(
    private val vulnerabilityRepository: VulnerabilityRepository,
    private val vulnerabilityExceptionRepository: VulnerabilityExceptionRepository,
    private val vulnerabilityConfigService: VulnerabilityConfigService
) {
    private val log = LoggerFactory.getLogger(VulnerabilityService::class.java)
    
    /**
     * Data class to hold overdue status information for a vulnerability
     *
     * @property status The overdue status (OK, OVERDUE, EXCEPTED)
     * @property ageInDays Age of vulnerability in days since scan
     * @property daysOverdue Days past the threshold (null if not overdue)
     * @property exceptionId ID of matching exception (if excepted)
     * @property exceptionReason Reason for exception (if excepted)
     * @property exceptionEndDate Exception expiration date (if excepted)
     */
    data class OverdueInfo(
        val status: OverdueStatus,
        val ageInDays: Int,
        val daysOverdue: Int?,
        val exceptionId: Long?,
        val exceptionReason: String?,
        val exceptionEndDate: LocalDateTime?
    )

    /**
     * Calculate overdue status for a vulnerability
     *
     * Determines if a vulnerability is overdue based on:
     * 1. Age of vulnerability (days since scanTimestamp)
     * 2. Configured "Reminder One" threshold
     * 3. Active exceptions (asset or product-based)
     *
     * Status logic:
     * - OK: Age <= threshold
     * - EXCEPTED: Age > threshold BUT has active exception
     * - OVERDUE: Age > threshold AND no active exception
     *
     * Feature 021: Overdue status calculation
     *
     * @param vulnerability The vulnerability to check
     * @param asset The asset the vulnerability is on
     * @return OverdueInfo with complete overdue status information
     */
    fun calculateOverdueStatus(vulnerability: Vulnerability, asset: Asset): OverdueInfo {
        // Get configured threshold
        val reminderOneDays = vulnerabilityConfigService.getReminderOneDays()
        
        // Calculate age in days from scan timestamp to now
        val ageInDays = ChronoUnit.DAYS.between(vulnerability.scanTimestamp, LocalDateTime.now()).toInt()
        
        // Check if any active exception matches this vulnerability
        val activeExceptions = vulnerabilityExceptionRepository.findAll().toList()
            .filter { it.isActive() }
        
        val matchingException = activeExceptions.firstOrNull { exception ->
            exception.matches(vulnerability, asset)
        }
        
        // Determine overdue status
        val isOverdue = ageInDays > reminderOneDays
        val status = when {
            matchingException != null -> OverdueStatus.EXCEPTED  // Has exception, regardless of age
            isOverdue -> OverdueStatus.OVERDUE                    // Overdue and no exception
            else -> OverdueStatus.OK                               // Within threshold
        }
        
        // Calculate days overdue (only if actually overdue after considering exceptions)
        val daysOverdue = if (status == OverdueStatus.OVERDUE) {
            ageInDays - reminderOneDays
        } else {
            null
        }
        
        log.trace("Vulnerability {} on asset {}: age={}d, threshold={}d, status={}, exception={}", 
            vulnerability.id, asset.id, ageInDays, reminderOneDays, status, matchingException?.id)
        
        return OverdueInfo(
            status = status,
            ageInDays = ageInDays,
            daysOverdue = daysOverdue,
            exceptionId = matchingException?.id,
            exceptionReason = matchingException?.reason,
            exceptionEndDate = matchingException?.expirationDate
        )
    }

    /**
     * Get current vulnerabilities (latest scan per asset) with exception status
     *
     * @param severity Optional CVSS severity filter (e.g., "Critical", "High")
     * @param system Optional system/asset name filter
     * @param exceptionStatus Optional filter: "excepted", "not_excepted", "overdue", "ok", or null (all)
     * @param product Optional product/version filter (substring match)
     * @param page Page number (0-indexed)
     * @param size Page size (default 50)
     * @return Paginated list of vulnerabilities with exception information
     */
    fun getCurrentVulnerabilities(
        severity: String? = null,
        system: String? = null,
        exceptionStatus: String? = null,
        product: String? = null,
        page: Int = 0,
        size: Int = 50
    ): Pair<List<VulnerabilityWithExceptionDto>, Long> {
        log.debug("Getting current vulnerabilities - severity: {}, system: {}, exceptionStatus: {}, product: {}, page: {}, size: {}",
            severity, system, exceptionStatus, product, page, size)

        // Get all vulnerabilities ordered by scan timestamp DESC
        val allVulns = vulnerabilityRepository.findAll().sortedByDescending { it.scanTimestamp }

        // Group by asset ID and get max scan timestamp per asset
        val latestScanPerAsset = allVulns
            .groupBy { it.asset.id }
            .mapValues { (_, vulns) -> vulns.maxOf { it.scanTimestamp } }

        log.debug("Found {} unique assets with scans", latestScanPerAsset.size)

        // Filter to only vulnerabilities from latest scan
        var currentVulns = allVulns.filter { vuln ->
            vuln.scanTimestamp == latestScanPerAsset[vuln.asset.id]
        }

        log.debug("Filtered to {} current vulnerabilities", currentVulns.size)

        // Apply severity filter
        if (!severity.isNullOrBlank()) {
            currentVulns = currentVulns.filter { vuln ->
                vuln.cvssSeverity?.equals(severity, ignoreCase = true) == true
            }
            log.debug("After severity filter: {} vulnerabilities", currentVulns.size)
        }

        // Apply system filter (asset name contains)
        if (!system.isNullOrBlank()) {
            currentVulns = currentVulns.filter { vuln ->
                vuln.asset.name.contains(system, ignoreCase = true)
            }
            log.debug("After system filter: {} vulnerabilities", currentVulns.size)
        }

        // Apply product filter (vulnerable product versions contains)
        if (!product.isNullOrBlank()) {
            currentVulns = currentVulns.filter { vuln ->
                vuln.vulnerableProductVersions?.contains(product, ignoreCase = true) == true
            }
            log.debug("After product filter: {} vulnerabilities", currentVulns.size)
        }

        // Get all active exceptions (not expired)
        val activeExceptions = vulnerabilityExceptionRepository.findAll().toList()
            .filter { it.isActive() }

        // Map to DTOs with exception information and overdue status
        val vulnsWithException = currentVulns.map { vuln ->
            // Calculate overdue status
            val overdueInfo = calculateOverdueStatus(vuln, vuln.asset)
            
            // Check if any active exception matches this vulnerability
            val matchingException = activeExceptions.firstOrNull { exception ->
                exception.matches(vuln, vuln.asset)
            }

            val hasException = matchingException != null
            val exceptionReason = matchingException?.reason

            VulnerabilityWithExceptionDto(
                id = vuln.id,
                asset = vuln.asset,  // Include full asset entity
                assetId = vuln.asset.id!!,
                assetName = vuln.asset.name,
                assetIp = vuln.asset.ip,
                vulnerabilityId = vuln.vulnerabilityId,
                cvssSeverity = vuln.cvssSeverity,
                vulnerableProductVersions = vuln.vulnerableProductVersions,
                daysOpen = vuln.daysOpen,
                scanTimestamp = vuln.scanTimestamp,
                hasException = hasException,
                exceptionReason = exceptionReason,
                // Feature 021: Add overdue status fields
                ageInDays = overdueInfo.ageInDays,
                overdueStatus = overdueInfo.status,
                daysOverdue = overdueInfo.daysOverdue,
                exceptionId = overdueInfo.exceptionId,
                exceptionEndDate = overdueInfo.exceptionEndDate
            )
        }

        // Apply exception status filter (support both hyphen and underscore formats)
        // Feature 021: Enhanced to support overdue status filtering
        val normalizedExceptionStatus = exceptionStatus?.lowercase()?.replace("-", "_")
        val result = when (normalizedExceptionStatus) {
            "excepted" -> vulnsWithException.filter { it.overdueStatus == OverdueStatus.EXCEPTED }
            "not_excepted" -> vulnsWithException.filter { it.overdueStatus != OverdueStatus.EXCEPTED }
            "overdue" -> vulnsWithException.filter { it.overdueStatus == OverdueStatus.OVERDUE }
            "ok" -> vulnsWithException.filter { it.overdueStatus == OverdueStatus.OK }
            else -> vulnsWithException
        }

        val totalElements = result.size.toLong()
        
        // Apply pagination
        val startIndex = page * size
        val endIndex = minOf(startIndex + size, result.size)
        
        val paginatedResult = if (startIndex < result.size) {
            result.subList(startIndex, endIndex)
        } else {
            emptyList()
        }

        log.info("Returning {} current vulnerabilities (page {}, size {}), total: {}", 
            paginatedResult.size, page, size, totalElements)
        return Pair(paginatedResult, totalElements)
    }

    /**
     * Get distinct product versions from all vulnerabilities
     * Feature 021 Phase 3: For product autocomplete
     *
     * @param searchTerm Optional search term to filter products
     * @param limit Maximum number of results (default: 50)
     * @return List of unique product version strings
     */
    fun getDistinctProducts(searchTerm: String? = null, limit: Int = 50): List<String> {
        log.debug("Getting distinct products - searchTerm: {}, limit: {}", searchTerm, limit)
        
        val allProducts = vulnerabilityRepository.findDistinctProductVersions()
        
        val filtered = if (!searchTerm.isNullOrBlank()) {
            allProducts.filter { it.contains(searchTerm, ignoreCase = true) }
        } else {
            allProducts
        }
        
        val limited = filtered.take(limit)
        log.info("Returning {} distinct products", limited.size)
        return limited
    }

    /**
     * Preview vulnerabilities that would be affected by an exception
     * Feature 021 Phase 3: For impact preview before creating exception
     *
     * @param exceptionType Type of exception (IP/PRODUCT/ASSET)
     * @param targetValue Target value (IP address, product name, or asset name)
     * @param assetId Asset ID (for ASSET type)
     * @param limit Maximum number of vulnerabilities to return (default: 10)
     * @return Pair of (affected vulnerabilities sample, total count)
     */
    fun previewExceptionImpact(
        exceptionType: com.secman.domain.VulnerabilityException.ExceptionType,
        targetValue: String,
        assetId: Long? = null,
        limit: Int = 10
    ): Pair<List<VulnerabilityWithExceptionDto>, Int> {
        log.debug("Previewing exception impact - type: {}, target: {}, assetId: {}", 
            exceptionType, targetValue, assetId)
        
        val allVulnerabilities = getAllVulnerabilities()
        
        val affected = when (exceptionType) {
            com.secman.domain.VulnerabilityException.ExceptionType.IP -> {
                // Filter by IP address (match asset IP)
                allVulnerabilities.filter { vuln ->
                    vuln.assetIp?.equals(targetValue, ignoreCase = true) == true
                }
            }
            com.secman.domain.VulnerabilityException.ExceptionType.PRODUCT -> {
                // Filter by product (substring match)
                allVulnerabilities.filter { vuln ->
                    vuln.vulnerableProductVersions?.contains(targetValue, ignoreCase = true) == true
                }
            }
            com.secman.domain.VulnerabilityException.ExceptionType.ASSET -> {
                // Filter by asset ID
                if (assetId != null) {
                    allVulnerabilities.filter { vuln -> vuln.assetId == assetId }
                } else {
                    emptyList()
                }
            }
        }
        
        val totalCount = affected.size
        val sample = affected.take(limit)
        
        log.info("Exception would affect {} vulnerabilities (showing {} sample)", 
            totalCount, sample.size)
        return Pair(sample, totalCount)
    }
}
