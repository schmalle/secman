package com.secman.service

import com.secman.domain.Asset
import com.secman.domain.Vulnerability
import com.secman.domain.VulnerabilityException
import com.secman.dto.OverdueStatus
import com.secman.dto.VulnerabilityWithExceptionDto
import com.secman.repository.VulnerabilityRepository
import com.secman.repository.VulnerabilityExceptionRepository
import io.micronaut.cache.annotation.Cacheable
import jakarta.inject.Singleton
import org.slf4j.LoggerFactory
import java.time.LocalDateTime
import java.time.temporal.ChronoUnit

/**
 * Service for vulnerability operations and filtering
 *
 * Handles:
 * - Querying current vulnerabilities (latest scan per asset)
 * - Filtering by severity, system, exception status, overdue status
 * - Checking exception status per vulnerability
 * - Calculating overdue status based on configurable threshold
 *
 * Related to: Feature 004-i-want-to (VULN Role & Vulnerability Management UI)
 * Related to: Feature 021-vulnerability-overdue-exception-logic
 */
@Singleton
open class VulnerabilityService(
    private val vulnerabilityRepository: VulnerabilityRepository,
    private val vulnerabilityExceptionRepository: VulnerabilityExceptionRepository,
    private val vulnerabilityConfigService: VulnerabilityConfigService,
    private val assetRepository: com.secman.repository.AssetRepository
) {
    private val log = LoggerFactory.getLogger(VulnerabilityService::class.java)

    /**
     * Get active exceptions with caching (5-minute TTL)
     *
     * PERFORMANCE: This replaces the inefficient findAll().filter{} pattern.
     * Uses the existing repository method and caches results for 5 minutes.
     * Cache is configured in application.yml under micronaut.caches.active_exceptions
     *
     * @return List of active (non-expired) exceptions
     */
    @Cacheable("active_exceptions")
    open fun getActiveExceptions(): List<VulnerabilityException> {
        log.debug("Loading active exceptions from database (cache miss)")
        return vulnerabilityExceptionRepository
            .findByExpirationDateIsNullOrExpirationDateGreaterThan(LocalDateTime.now())
    }
    
    /**
     * Data class to hold overdue status information for a vulnerability
     *
     * @property status The overdue status (OK, OVERDUE, EXCEPTED)
     * @property ageInDays Age of vulnerability in days since scan
     * @property daysOverdue Days past the threshold (null if not overdue)
     * @property exceptionId ID of matching exception (if excepted)
     * @property exceptionReason Reason for exception (if excepted)
     * @property exceptionEndDate Exception expiration date (if excepted)
     */
    data class OverdueInfo(
        val status: OverdueStatus,
        val ageInDays: Int,
        val daysOverdue: Int?,
        val exceptionId: Long?,
        val exceptionReason: String?,
        val exceptionEndDate: LocalDateTime?
    )

    /**
     * Calculate overdue status for a vulnerability
     *
     * Determines if a vulnerability is overdue based on:
     * 1. Age of vulnerability (days since scanTimestamp)
     * 2. Configured "Reminder One" threshold
     * 3. Active exceptions (asset or product-based)
     *
     * Status logic:
     * - OK: Age <= threshold
     * - EXCEPTED: Age > threshold BUT has active exception
     * - OVERDUE: Age > threshold AND no active exception
     *
     * Feature 021: Overdue status calculation
     *
     * PERFORMANCE: When calling this method in a loop, pass a pre-loaded list of
     * active exceptions to avoid N+1 queries. Use getActiveExceptions() to get
     * the cached list.
     *
     * @param vulnerability The vulnerability to check
     * @param asset The asset the vulnerability is on
     * @param activeExceptions Optional pre-loaded list of active exceptions (avoids N+1)
     * @return OverdueInfo with complete overdue status information
     */
    fun calculateOverdueStatus(
        vulnerability: Vulnerability,
        asset: Asset,
        activeExceptions: List<VulnerabilityException>? = null
    ): OverdueInfo {
        // Get configured threshold
        val reminderOneDays = vulnerabilityConfigService.getReminderOneDays()

        // Calculate age in days from scan timestamp to now
        val ageInDays = ChronoUnit.DAYS.between(vulnerability.scanTimestamp, LocalDateTime.now()).toInt()

        // Use pre-loaded exceptions or fetch from cache
        val exceptions = activeExceptions ?: getActiveExceptions()

        val matchingException = exceptions.firstOrNull { exception ->
            exception.matches(vulnerability, asset)
        }

        // Determine overdue status
        val isOverdue = ageInDays > reminderOneDays
        val status = when {
            matchingException != null -> OverdueStatus.EXCEPTED  // Has exception, regardless of age
            isOverdue -> OverdueStatus.OVERDUE                    // Overdue and no exception
            else -> OverdueStatus.OK                               // Within threshold
        }

        // Calculate days overdue (only if actually overdue after considering exceptions)
        val daysOverdue = if (status == OverdueStatus.OVERDUE) {
            ageInDays - reminderOneDays
        } else {
            null
        }

        log.trace("Vulnerability {} on asset {}: age={}d, threshold={}d, status={}, exception={}",
            vulnerability.id, asset.id, ageInDays, reminderOneDays, status, matchingException?.id)

        return OverdueInfo(
            status = status,
            ageInDays = ageInDays,
            daysOverdue = daysOverdue,
            exceptionId = matchingException?.id,
            exceptionReason = matchingException?.reason,
            exceptionEndDate = matchingException?.expirationDate
        )
    }

    /**
     * Get current vulnerabilities (latest scan per asset) with exception status
     *
     * @param severity Optional CVSS severity filter (e.g., "Critical", "High")
     * @param system Optional system/asset name filter
     * @param exceptionStatus Optional filter: "excepted", "not_excepted", "overdue", "ok", or null (all)
     * @param product Optional product/version filter (substring match)
     * @param adDomain Optional AD domain filter (substring match, case-insensitive)
     * @param page Page number (0-indexed)
     * @param size Page size (default 50)
     * @return Paginated list of vulnerabilities with exception information
     */
    fun getCurrentVulnerabilities(
        severity: String? = null,
        system: String? = null,
        exceptionStatus: String? = null,
        product: String? = null,
        adDomain: String? = null,
        page: Int = 0,
        size: Int = 50
    ): Pair<List<VulnerabilityWithExceptionDto>, Long> {
        log.debug("Getting current vulnerabilities - severity: {}, system: {}, exceptionStatus: {}, product: {}, adDomain: {}, page: {}, size: {}",
            severity, system, exceptionStatus, product, adDomain, page, size)

        // OPTIMIZATION: Use database query instead of loading all vulnerabilities into memory
        // This is significantly faster for large datasets (100K+ vulnerabilities)
        val pageable = io.micronaut.data.model.Pageable.from(page, size)

        // Use optimized query that filters at database level
        val currentVulnsPage = vulnerabilityRepository.findLatestVulnerabilitiesPerAssetWithFilters(
            severity = severity?.takeIf { it.isNotBlank() },
            assetName = system?.takeIf { it.isNotBlank() },
            productFilter = product?.takeIf { it.isNotBlank() },
            domainFilter = adDomain?.takeIf { it.isNotBlank() },
            pageable = io.micronaut.data.model.Pageable.UNPAGED // Get all for exception status filtering
        )

        val currentVulns = currentVulnsPage.content
        log.debug("Found {} current vulnerabilities from database", currentVulns.size)

        // PERFORMANCE: Get active exceptions ONCE (cached for 5 minutes)
        // This replaces the inefficient findAll().filter{} pattern
        val activeExceptions = getActiveExceptions()

        log.debug("Found {} active exceptions (from cache)", activeExceptions.size)

        // Map to DTOs with exception information and overdue status
        val vulnsWithException = currentVulns.map { vuln ->
            // Calculate overdue status - pass pre-loaded exceptions to avoid N+1 queries
            val overdueInfo = calculateOverdueStatus(vuln, vuln.asset, activeExceptions)

            // Check if any active exception matches this vulnerability
            val matchingException = activeExceptions.firstOrNull { exception ->
                exception.matches(vuln, vuln.asset)
            }

            val hasException = matchingException != null
            val exceptionReason = matchingException?.reason

            VulnerabilityWithExceptionDto(
                id = vuln.id,
                asset = vuln.asset,  // Include full asset entity
                assetId = vuln.asset.id!!,
                assetName = vuln.asset.name,
                assetIp = vuln.asset.ip,
                vulnerabilityId = vuln.vulnerabilityId,
                cvssSeverity = vuln.cvssSeverity,
                vulnerableProductVersions = vuln.vulnerableProductVersions,
                daysOpen = vuln.daysOpen,
                scanTimestamp = vuln.scanTimestamp,
                hasException = hasException,
                exceptionReason = exceptionReason,
                // Feature 021: Add overdue status fields
                ageInDays = overdueInfo.ageInDays,
                overdueStatus = overdueInfo.status,
                daysOverdue = overdueInfo.daysOverdue,
                exceptionId = overdueInfo.exceptionId,
                exceptionEndDate = overdueInfo.exceptionEndDate
            )
        }

        // Apply exception status filter (support both hyphen and underscore formats)
        // Feature 021: Enhanced to support overdue status filtering
        val normalizedExceptionStatus = exceptionStatus?.lowercase()?.replace("-", "_")
        val result = when (normalizedExceptionStatus) {
            "excepted" -> vulnsWithException.filter { it.overdueStatus == OverdueStatus.EXCEPTED }
            "not_excepted" -> vulnsWithException.filter { it.overdueStatus != OverdueStatus.EXCEPTED }
            "overdue" -> vulnsWithException.filter { it.overdueStatus == OverdueStatus.OVERDUE }
            "ok" -> vulnsWithException.filter { it.overdueStatus == OverdueStatus.OK }
            else -> vulnsWithException
        }

        val totalElements = result.size.toLong()
        
        // Apply pagination
        val startIndex = page * size
        val endIndex = minOf(startIndex + size, result.size)
        
        val paginatedResult = if (startIndex < result.size) {
            result.subList(startIndex, endIndex)
        } else {
            emptyList()
        }

        log.info("Returning {} current vulnerabilities (page {}, size {}), total: {}",
            paginatedResult.size, page, size, totalElements)
        return Pair(paginatedResult, totalElements)
    }

    /**
     * PERFORMANCE OPTIMIZED: Get current vulnerabilities with proper database pagination
     *
     * This method uses database-level pagination and access control, replacing the
     * inefficient pattern of loading all data and filtering in-memory.
     *
     * Key optimizations:
     * 1. Database-level pagination (only fetches requested page)
     * 2. Database-level access control (filters by asset IDs in SQL)
     * 3. Cached active exceptions (5-minute TTL)
     *
     * Note: Exception status filtering still happens in-memory on the paginated result.
     * This means the returned page may have fewer items than requested if filtered.
     * For exact pagination with exception status, the caller should request larger pages
     * or use the legacy getCurrentVulnerabilities method.
     *
     * Feature: Database Structure Optimization - Phase 2
     *
     * @param accessibleAssetIds Set of asset IDs the user can access (from AssetFilterService)
     * @param isAdmin If true, bypasses asset ID filtering (ADMIN has full access)
     * @param severity Optional CVSS severity filter
     * @param system Optional system/asset name filter
     * @param exceptionStatus Optional filter: "excepted", "not_excepted", "overdue", "ok", or null
     * @param product Optional product/version filter (substring match)
     * @param adDomain Optional AD domain filter (substring match)
     * @param page Page number (0-indexed)
     * @param size Page size
     * @return PaginatedVulnerabilitiesResponse with proper pagination metadata
     */
    fun getCurrentVulnerabilitiesOptimized(
        accessibleAssetIds: Set<Long>,
        isAdmin: Boolean,
        severity: String?,
        system: String?,
        exceptionStatus: String?,
        product: String?,
        adDomain: String?,
        page: Int,
        size: Int
    ): com.secman.dto.PaginatedVulnerabilitiesResponse {
        log.debug("Getting current vulnerabilities (optimized) - isAdmin: {}, assetIds: {}, severity: {}, system: {}, exceptionStatus: {}, page: {}, size: {}",
            isAdmin, if (isAdmin) "ALL" else accessibleAssetIds.size, severity, system, exceptionStatus, page, size)

        val pageable = io.micronaut.data.model.Pageable.from(page, size)

        // Get active exceptions ONCE (cached)
        val activeExceptions = getActiveExceptions()
        log.debug("Found {} active exceptions (from cache)", activeExceptions.size)

        // Choose query based on admin status
        val vulnPage = if (isAdmin) {
            // ADMIN: Use simple query without asset ID filtering
            vulnerabilityRepository.findLatestVulnerabilitiesPerAssetWithFilters(
                severity = severity?.takeIf { it.isNotBlank() },
                assetName = system?.takeIf { it.isNotBlank() },
                productFilter = product?.takeIf { it.isNotBlank() },
                domainFilter = adDomain?.takeIf { it.isNotBlank() },
                pageable = if (exceptionStatus.isNullOrBlank()) pageable else io.micronaut.data.model.Pageable.UNPAGED
            )
        } else {
            // Non-ADMIN: Use query with access control
            if (accessibleAssetIds.isEmpty()) {
                // User has no accessible assets - return empty result
                return com.secman.dto.PaginatedVulnerabilitiesResponse(
                    content = emptyList(),
                    totalElements = 0,
                    totalPages = 0,
                    currentPage = page,
                    pageSize = size,
                    hasNext = false,
                    hasPrevious = false
                )
            }
            vulnerabilityRepository.findLatestVulnerabilitiesWithAccessControl(
                accessibleAssetIds = accessibleAssetIds,
                severity = severity?.takeIf { it.isNotBlank() },
                assetName = system?.takeIf { it.isNotBlank() },
                productFilter = product?.takeIf { it.isNotBlank() },
                domainFilter = adDomain?.takeIf { it.isNotBlank() },
                pageable = if (exceptionStatus.isNullOrBlank()) pageable else io.micronaut.data.model.Pageable.UNPAGED
            )
        }

        val currentVulns = vulnPage.content
        log.debug("Found {} vulnerabilities from database query", currentVulns.size)

        // Map to DTOs with exception information
        val vulnsWithException = currentVulns.map { vuln ->
            val overdueInfo = calculateOverdueStatus(vuln, vuln.asset, activeExceptions)
            val matchingException = activeExceptions.firstOrNull { it.matches(vuln, vuln.asset) }

            VulnerabilityWithExceptionDto(
                id = vuln.id,
                asset = vuln.asset,
                assetId = vuln.asset.id!!,
                assetName = vuln.asset.name,
                assetIp = vuln.asset.ip,
                vulnerabilityId = vuln.vulnerabilityId,
                cvssSeverity = vuln.cvssSeverity,
                vulnerableProductVersions = vuln.vulnerableProductVersions,
                daysOpen = vuln.daysOpen,
                scanTimestamp = vuln.scanTimestamp,
                hasException = matchingException != null,
                exceptionReason = matchingException?.reason,
                ageInDays = overdueInfo.ageInDays,
                overdueStatus = overdueInfo.status,
                daysOverdue = overdueInfo.daysOverdue,
                exceptionId = overdueInfo.exceptionId,
                exceptionEndDate = overdueInfo.exceptionEndDate
            )
        }

        // Apply exception status filter if specified
        val normalizedExceptionStatus = exceptionStatus?.lowercase()?.replace("-", "_")
        val filteredResult = if (!normalizedExceptionStatus.isNullOrBlank()) {
            val filtered = when (normalizedExceptionStatus) {
                "excepted" -> vulnsWithException.filter { it.overdueStatus == OverdueStatus.EXCEPTED }
                "not_excepted" -> vulnsWithException.filter { it.overdueStatus != OverdueStatus.EXCEPTED }
                "overdue" -> vulnsWithException.filter { it.overdueStatus == OverdueStatus.OVERDUE }
                "ok" -> vulnsWithException.filter { it.overdueStatus == OverdueStatus.OK }
                else -> vulnsWithException
            }
            // Need to apply manual pagination since we fetched all for filtering
            val totalElements = filtered.size.toLong()
            val totalPages = kotlin.math.ceil(totalElements.toDouble() / size).toInt()
            val startIndex = page * size
            val endIndex = minOf(startIndex + size, filtered.size)
            val paginatedContent = if (startIndex < filtered.size) filtered.subList(startIndex, endIndex) else emptyList()

            com.secman.dto.PaginatedVulnerabilitiesResponse(
                content = paginatedContent,
                totalElements = totalElements,
                totalPages = totalPages,
                currentPage = page,
                pageSize = size,
                hasNext = page < totalPages - 1,
                hasPrevious = page > 0
            )
        } else {
            // No exception filter - use DB pagination metadata
            com.secman.dto.PaginatedVulnerabilitiesResponse(
                content = vulnsWithException,
                totalElements = vulnPage.totalSize,
                totalPages = vulnPage.totalPages,
                currentPage = page,
                pageSize = size,
                hasNext = page < vulnPage.totalPages - 1,
                hasPrevious = page > 0
            )
        }

        log.info("Returning {} current vulnerabilities (page {}/{}, total {})",
            filteredResult.content.size, page + 1, filteredResult.totalPages, filteredResult.totalElements)
        return filteredResult
    }

    /**
     * Get distinct product versions from all vulnerabilities
     * Feature 021 Phase 3: For product autocomplete
     *
     * @param searchTerm Optional search term to filter products
     * @param limit Maximum number of results (default: 50)
     * @return List of unique product version strings
     */
    fun getDistinctProducts(searchTerm: String? = null, limit: Int = 50): List<String> {
        log.debug("Getting distinct products - searchTerm: {}, limit: {}", searchTerm, limit)

        val allProducts = vulnerabilityRepository.findDistinctProductVersions()

        val filtered = if (!searchTerm.isNullOrBlank()) {
            allProducts.filter { it.contains(searchTerm, ignoreCase = true) }
        } else {
            allProducts
        }

        val limited = filtered.take(limit)
        log.info("Returning {} distinct products", limited.size)
        return limited
    }

    /**
     * Get distinct AD domains from all assets
     * For filter dropdown population in Current Vulnerabilities view
     *
     * @return List of unique AD domain names
     */
    fun getDistinctAdDomains(): List<String> {
        log.debug("Getting distinct AD domains")

        val domains = assetRepository.findDistinctAdDomains()

        log.info("Returning {} distinct AD domains", domains.size)
        return domains
    }

    /**
     * Preview vulnerabilities that would be affected by an exception
     * Feature 021 Phase 3: For impact preview before creating exception
     *
     * @param exceptionType Type of exception (IP/PRODUCT/ASSET)
     * @param targetValue Target value (IP address, product name, or asset name)
     * @param assetId Asset ID (for ASSET type)
     * @param limit Maximum number of vulnerabilities to return (default: 10)
     * @return Pair of (affected vulnerabilities sample, total count)
     */
    fun previewExceptionImpact(
        exceptionType: com.secman.domain.VulnerabilityException.ExceptionType,
        targetValue: String,
        assetId: Long? = null,
        limit: Int = 10
    ): Pair<List<VulnerabilityWithExceptionDto>, Int> {
        log.debug("Previewing exception impact - type: {}, target: {}, assetId: {}", 
            exceptionType, targetValue, assetId)
        
        // Get all current vulnerabilities (latest scan per asset)
        val allVulns = vulnerabilityRepository.findAll().sortedByDescending { it.scanTimestamp }
        val latestScanPerAsset = allVulns
            .groupBy { it.asset.id }
            .mapValues { (_, vulns) -> vulns.maxOf { it.scanTimestamp } }
        
        val currentVulns = allVulns.filter { vuln ->
            vuln.asset.id != null && vuln.scanTimestamp == latestScanPerAsset[vuln.asset.id]
        }
        
        // Filter based on exception type
        val affected = when (exceptionType) {
            com.secman.domain.VulnerabilityException.ExceptionType.IP -> {
                // Filter by IP address (match asset IP)
                currentVulns.filter { vuln ->
                    vuln.asset.ip?.equals(targetValue, ignoreCase = true) == true
                }
            }
            com.secman.domain.VulnerabilityException.ExceptionType.PRODUCT -> {
                // Filter by product (substring match)
                currentVulns.filter { vuln ->
                    vuln.vulnerableProductVersions?.contains(targetValue, ignoreCase = true) == true
                }
            }
            com.secman.domain.VulnerabilityException.ExceptionType.ASSET -> {
                // Filter by asset ID
                if (assetId != null) {
                    currentVulns.filter { vuln -> vuln.asset.id == assetId }
                } else {
                    emptyList()
                }
            }
        }
        
        val totalCount = affected.size

        // PERFORMANCE: Get active exceptions ONCE (cached for 5 minutes)
        val activeExceptions = getActiveExceptions()

        // Convert to DTO with exception info
        val affectedDtos = affected.map { vuln ->
            // Calculate overdue status - pass pre-loaded exceptions to avoid N+1 queries
            val overdueInfo = calculateOverdueStatus(vuln, vuln.asset, activeExceptions)
            
            // Check if any active exception matches this vulnerability
            val matchingException = activeExceptions.firstOrNull { exception ->
                exception.matches(vuln, vuln.asset)
            }

            val hasException = matchingException != null
            val exceptionReason = matchingException?.reason

            VulnerabilityWithExceptionDto(
                id = vuln.id,
                asset = vuln.asset,
                assetId = vuln.asset.id!!,
                assetName = vuln.asset.name,
                assetIp = vuln.asset.ip,
                vulnerabilityId = vuln.vulnerabilityId,
                cvssSeverity = vuln.cvssSeverity,
                vulnerableProductVersions = vuln.vulnerableProductVersions,
                daysOpen = vuln.daysOpen,
                scanTimestamp = vuln.scanTimestamp,
                hasException = hasException,
                exceptionReason = exceptionReason,
                ageInDays = overdueInfo.ageInDays,
                overdueStatus = overdueInfo.status,
                daysOverdue = overdueInfo.daysOverdue,
                exceptionId = overdueInfo.exceptionId,
                exceptionEndDate = overdueInfo.exceptionEndDate
            )
        }
        
        val sample = affectedDtos.take(limit)
        
        log.info("Exception would affect {} vulnerabilities (showing {} sample)",
            totalCount, sample.size)
        return Pair(sample, totalCount)
    }

    /**
     * Cleanup duplicate vulnerabilities from the database
     *
     * A duplicate vulnerability is defined as:
     * - Same asset ID
     * - Same vulnerability ID (CVE)
     * - Same scan timestamp
     *
     * The cleanup process keeps the oldest record (lowest ID) and removes newer duplicates.
     * This is safe because the record with the lowest ID was created first and represents
     * the original entry.
     *
     * @return VulnerabilityCleanupResult with statistics about the cleanup operation
     */
    fun cleanupDuplicates(): com.secman.dto.VulnerabilityCleanupResult {
        log.info("Starting vulnerability duplicate cleanup")

        // Get all vulnerabilities
        val allVulnerabilities = vulnerabilityRepository.findAll().toList()
        val totalScanned = allVulnerabilities.size

        log.debug("Scanned {} total vulnerabilities", totalScanned)

        // Group by composite key: (assetId, vulnerabilityId, scanTimestamp)
        // Duplicates will have multiple entries in the same group
        val grouped = allVulnerabilities.groupBy { vuln ->
            Triple(vuln.asset.id, vuln.vulnerabilityId, vuln.scanTimestamp)
        }

        log.debug("Grouped into {} unique vulnerability keys", grouped.size)

        // Find groups with duplicates (more than 1 vulnerability with same key)
        val duplicateGroups = grouped.filter { (_, vulns) -> vulns.size > 1 }

        log.info("Found {} groups with duplicates", duplicateGroups.size)

        // For each duplicate group, keep the one with the lowest ID (oldest) and delete the rest
        var duplicatesRemoved = 0
        var duplicatesFound = 0

        duplicateGroups.forEach { (key, vulns) ->
            // Sort by ID to ensure we keep the oldest (lowest ID)
            val sorted = vulns.sortedBy { it.id }

            // Count duplicates (all except the first one)
            val duplicateCount = sorted.size - 1
            duplicatesFound += duplicateCount

            log.debug("Group {} has {} duplicates. Keeping ID {} and removing {} others",
                key, duplicateCount, sorted.first().id, sorted.drop(1).map { it.id })

            // Delete all except the first (oldest)
            sorted.drop(1).forEach { duplicate ->
                try {
                    vulnerabilityRepository.deleteById(duplicate.id!!)
                    duplicatesRemoved++
                    log.trace("Deleted duplicate vulnerability ID {}", duplicate.id)
                } catch (e: Exception) {
                    log.error("Failed to delete duplicate vulnerability ID {}: {}",
                        duplicate.id, e.message, e)
                }
            }
        }

        val uniqueRemaining = totalScanned - duplicatesRemoved

        log.info("Cleanup completed: scanned={}, duplicatesFound={}, duplicatesRemoved={}, uniqueRemaining={}",
            totalScanned, duplicatesFound, duplicatesRemoved, uniqueRemaining)

        return if (duplicatesRemoved > 0) {
            com.secman.dto.VulnerabilityCleanupResult.success(
                totalScanned = totalScanned,
                duplicatesFound = duplicatesFound,
                duplicatesRemoved = duplicatesRemoved,
                uniqueRemaining = uniqueRemaining
            )
        } else {
            com.secman.dto.VulnerabilityCleanupResult.noCleanupNeeded(totalScanned)
        }
    }
}
