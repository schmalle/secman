package com.secman.service

import com.secman.config.MemoryOptimizationConfig
import com.secman.domain.Asset
import com.secman.domain.Vulnerability
import com.secman.domain.VulnerabilityException
import com.secman.dto.AddVulnerabilityRequestDto
import com.secman.dto.AddVulnerabilityResponseDto
import com.secman.dto.OverdueStatus
import com.secman.dto.VulnerabilityWithExceptionDto
import com.secman.repository.VulnerabilityRepository
import com.secman.repository.VulnerabilityExceptionRepository
import io.micronaut.cache.annotation.Cacheable
import jakarta.inject.Singleton
import jakarta.persistence.EntityManager
import jakarta.transaction.Transactional
import org.slf4j.LoggerFactory
import java.time.LocalDateTime
import java.time.temporal.ChronoUnit

/**
 * Service for vulnerability operations and filtering
 *
 * Handles:
 * - Querying current vulnerabilities (latest scan per asset)
 * - Filtering by severity, system, exception status, overdue status
 * - Checking exception status per vulnerability
 * - Calculating overdue status based on configurable threshold
 *
 * Related to: Feature 004-i-want-to (VULN Role & Vulnerability Management UI)
 * Related to: Feature 021-vulnerability-overdue-exception-logic
 * Related to: Feature 073-memory-optimization (SQL-level filtering, batched cleanup)
 */
@Singleton
open class VulnerabilityService(
    private val vulnerabilityRepository: VulnerabilityRepository,
    private val vulnerabilityExceptionRepository: VulnerabilityExceptionRepository,
    private val vulnerabilityConfigService: VulnerabilityConfigService,
    private val assetRepository: com.secman.repository.AssetRepository,
    private val entityManager: EntityManager,
    private val memoryConfig: MemoryOptimizationConfig
) {
    private val log = LoggerFactory.getLogger(VulnerabilityService::class.java)

    /**
     * Get total vulnerability count with caching (5-minute TTL)
     * Avoids expensive COUNT(*) on 358k+ rows for every unfiltered page load
     *
     * @return Total count of all vulnerabilities
     */
    @Cacheable("vulnerability_total_count")
    open fun getCachedTotalCount(): Long {
        log.debug("Loading total vulnerability count from database (cache miss)")
        return vulnerabilityRepository.countAll()
    }

    /**
     * Get active exceptions with caching (5-minute TTL)
     *
     * PERFORMANCE: This replaces the inefficient findAll().filter{} pattern.
     * Uses the existing repository method and caches results for 5 minutes.
     * Cache is configured in application.yml under micronaut.caches.active_exceptions
     *
     * @return List of active (non-expired) exceptions
     */
    @Cacheable("active_exceptions")
    open fun getActiveExceptions(): List<VulnerabilityException> {
        log.debug("Loading active exceptions from database (cache miss)")
        return vulnerabilityExceptionRepository
            .findByExpirationDateIsNullOrExpirationDateGreaterThan(LocalDateTime.now())
    }
    
    /**
     * Data class to hold overdue status information for a vulnerability
     *
     * @property status The overdue status (OK, OVERDUE, EXCEPTED)
     * @property ageInDays Age of vulnerability in days since scan
     * @property daysOverdue Days past the threshold (null if not overdue)
     * @property exceptionId ID of matching exception (if excepted)
     * @property exceptionReason Reason for exception (if excepted)
     * @property exceptionEndDate Exception expiration date (if excepted)
     */
    data class OverdueInfo(
        val status: OverdueStatus,
        val ageInDays: Int,
        val daysOverdue: Int?,
        val exceptionId: Long?,
        val exceptionReason: String?,
        val exceptionEndDate: LocalDateTime?
    )

    /**
     * Calculate overdue status for a vulnerability
     *
     * Determines if a vulnerability is overdue based on:
     * 1. Age of vulnerability (days since scanTimestamp)
     * 2. Configured "Reminder One" threshold
     * 3. Active exceptions (asset or product-based)
     *
     * Status logic:
     * - OK: Age <= threshold
     * - EXCEPTED: Age > threshold BUT has active exception
     * - OVERDUE: Age > threshold AND no active exception
     *
     * Feature 021: Overdue status calculation
     *
     * PERFORMANCE: When calling this method in a loop, pass a pre-loaded list of
     * active exceptions to avoid N+1 queries. Use getActiveExceptions() to get
     * the cached list.
     *
     * @param vulnerability The vulnerability to check
     * @param asset The asset the vulnerability is on
     * @param activeExceptions Optional pre-loaded list of active exceptions (avoids N+1)
     * @return OverdueInfo with complete overdue status information
     */
    fun calculateOverdueStatus(
        vulnerability: Vulnerability,
        asset: Asset,
        activeExceptions: List<VulnerabilityException>? = null
    ): OverdueInfo {
        // Get configured threshold
        val reminderOneDays = vulnerabilityConfigService.getReminderOneDays()

        // Calculate age in days from scan timestamp to now
        val ageInDays = ChronoUnit.DAYS.between(vulnerability.scanTimestamp, LocalDateTime.now()).toInt()

        // Use pre-loaded exceptions or fetch from cache
        val exceptions = activeExceptions ?: getActiveExceptions()

        val matchingException = exceptions.firstOrNull { exception ->
            exception.matches(vulnerability, asset)
        }

        // Determine overdue status
        val isOverdue = ageInDays > reminderOneDays
        val status = when {
            matchingException != null -> OverdueStatus.EXCEPTED  // Has exception, regardless of age
            isOverdue -> OverdueStatus.OVERDUE                    // Overdue and no exception
            else -> OverdueStatus.OK                               // Within threshold
        }

        // Calculate days overdue (only if actually overdue after considering exceptions)
        val daysOverdue = if (status == OverdueStatus.OVERDUE) {
            ageInDays - reminderOneDays
        } else {
            null
        }

        log.trace("Vulnerability {} on asset {}: age={}d, threshold={}d, status={}, exception={}",
            vulnerability.id, asset.id, ageInDays, reminderOneDays, status, matchingException?.id)

        return OverdueInfo(
            status = status,
            ageInDays = ageInDays,
            daysOverdue = daysOverdue,
            exceptionId = matchingException?.id,
            exceptionReason = matchingException?.reason,
            exceptionEndDate = matchingException?.expirationDate
        )
    }

    /**
     * Get current vulnerabilities (latest scan per asset) with exception status
     *
     * @param severity Optional CVSS severity filter (e.g., "Critical", "High")
     * @param system Optional system/asset name filter
     * @param exceptionStatus Optional filter: "excepted", "not_excepted", "overdue", "ok", or null (all)
     * @param product Optional product/version filter (substring match)
     * @param adDomain Optional AD domain filter (substring match, case-insensitive)
     * @param page Page number (0-indexed)
     * @param size Page size (default 50)
     * @return Paginated list of vulnerabilities with exception information
     */
    fun getCurrentVulnerabilities(
        severity: String? = null,
        system: String? = null,
        exceptionStatus: String? = null,
        product: String? = null,
        adDomain: String? = null,
        page: Int = 0,
        size: Int = 50
    ): Pair<List<VulnerabilityWithExceptionDto>, Long> {
        log.debug("Getting current vulnerabilities - severity: {}, system: {}, exceptionStatus: {}, product: {}, adDomain: {}, page: {}, size: {}",
            severity, system, exceptionStatus, product, adDomain, page, size)

        // OPTIMIZATION: Use database query instead of loading all vulnerabilities into memory
        // This is significantly faster for large datasets (100K+ vulnerabilities)
        val pageable = io.micronaut.data.model.Pageable.from(page, size)

        // Use optimized query that filters at database level
        val currentVulnsPage = vulnerabilityRepository.findLatestVulnerabilitiesPerAssetWithFilters(
            severity = severity?.takeIf { it.isNotBlank() },
            assetName = system?.takeIf { it.isNotBlank() },
            productFilter = product?.takeIf { it.isNotBlank() },
            domainFilter = adDomain?.takeIf { it.isNotBlank() },
            cloudAccountIdFilter = null, // Not supported in this legacy function
            pageable = io.micronaut.data.model.Pageable.UNPAGED // Get all for exception status filtering
        )

        val currentVulns = currentVulnsPage.content
        log.debug("Found {} current vulnerabilities from database", currentVulns.size)

        // PERFORMANCE: Get active exceptions ONCE (cached for 5 minutes)
        // This replaces the inefficient findAll().filter{} pattern
        val activeExceptions = getActiveExceptions()

        log.debug("Found {} active exceptions (from cache)", activeExceptions.size)

        // Map to DTOs with exception information and overdue status
        val vulnsWithException = currentVulns.map { vuln ->
            // Calculate overdue status - pass pre-loaded exceptions to avoid N+1 queries
            val overdueInfo = calculateOverdueStatus(vuln, vuln.asset, activeExceptions)

            // Check if any active exception matches this vulnerability
            val matchingException = activeExceptions.firstOrNull { exception ->
                exception.matches(vuln, vuln.asset)
            }

            val hasException = matchingException != null
            val exceptionReason = matchingException?.reason

            VulnerabilityWithExceptionDto(
                id = vuln.id,
                asset = vuln.asset,  // Include full asset entity
                assetId = vuln.asset.id!!,
                assetName = vuln.asset.name,
                assetIp = vuln.asset.ip,
                vulnerabilityId = vuln.vulnerabilityId,
                cvssSeverity = vuln.cvssSeverity,
                vulnerableProductVersions = vuln.vulnerableProductVersions,
                daysOpen = vuln.daysOpen,
                scanTimestamp = vuln.scanTimestamp,
                hasException = hasException,
                exceptionReason = exceptionReason,
                // Feature 021: Add overdue status fields
                ageInDays = overdueInfo.ageInDays,
                overdueStatus = overdueInfo.status,
                daysOverdue = overdueInfo.daysOverdue,
                exceptionId = overdueInfo.exceptionId,
                exceptionEndDate = overdueInfo.exceptionEndDate
            )
        }

        // Apply exception status filter (support both hyphen and underscore formats)
        // Feature 021: Enhanced to support overdue status filtering
        val normalizedExceptionStatus = exceptionStatus?.lowercase()?.replace("-", "_")
        val result = when (normalizedExceptionStatus) {
            "excepted" -> vulnsWithException.filter { it.overdueStatus == OverdueStatus.EXCEPTED }
            "not_excepted" -> vulnsWithException.filter { it.overdueStatus != OverdueStatus.EXCEPTED }
            "overdue" -> vulnsWithException.filter { it.overdueStatus == OverdueStatus.OVERDUE }
            "ok" -> vulnsWithException.filter { it.overdueStatus == OverdueStatus.OK }
            else -> vulnsWithException
        }

        val totalElements = result.size.toLong()
        
        // Apply pagination
        val startIndex = page * size
        val endIndex = minOf(startIndex + size, result.size)
        
        val paginatedResult = if (startIndex < result.size) {
            result.subList(startIndex, endIndex)
        } else {
            emptyList()
        }

        log.info("Returning {} current vulnerabilities (page {}, size {}), total: {}",
            paginatedResult.size, page, size, totalElements)
        return Pair(paginatedResult, totalElements)
    }

    /**
     * PERFORMANCE OPTIMIZED: Get current vulnerabilities with proper database pagination
     *
     * This method uses database-level pagination and access control, replacing the
     * inefficient pattern of loading all data and filtering in-memory.
     *
     * Key optimizations:
     * 1. Database-level pagination (only fetches requested page)
     * 2. Database-level access control (filters by asset IDs in SQL)
     * 3. Cached active exceptions (5-minute TTL)
     *
     * Note: Exception status filtering still happens in-memory on the paginated result.
     * This means the returned page may have fewer items than requested if filtered.
     * For exact pagination with exception status, the caller should request larger pages
     * or use the legacy getCurrentVulnerabilities method.
     *
     * Feature: Database Structure Optimization - Phase 2
     *
     * @param accessibleAssetIds Set of asset IDs the user can access (from AssetFilterService)
     * @param isAdmin If true, bypasses asset ID filtering (ADMIN has full access)
     * @param severity Optional CVSS severity filter
     * @param system Optional system/asset name filter
     * @param exceptionStatus Optional filter: "excepted", "not_excepted", "overdue", "ok", or null
     * @param product Optional product/version filter (substring match)
     * @param adDomain Optional AD domain filter (substring match)
     * @param cloudAccountId Optional AWS cloud account ID filter (substring match)
     * @param page Page number (0-indexed)
     * @param size Page size
     * @return PaginatedVulnerabilitiesResponse with proper pagination metadata
     */
    companion object {
        // Allowlist of sortable column names mapped to JPQL ORDER BY expressions
        // Uses aliases 'v' (Vulnerability) and 'a' (Asset) from the query
        val SORT_FIELD_MAP = mapOf(
            "assetName" to "a.name",
            "assetIp" to "a.ip",
            "vulnerabilityId" to "v.vulnerabilityId",
            "cvssSeverity" to "v.cvssSeverity",
            "vulnerableProductVersions" to "v.vulnerableProductVersions",
            "daysOpen" to "v.daysOpen",
            "scanTimestamp" to "v.scanTimestamp",
            "importTimestamp" to "v.importTimestamp"
        )
        // Same mapping for native SQL (uses column names)
        val SORT_FIELD_MAP_NATIVE = mapOf(
            "assetName" to "a.name",
            "assetIp" to "a.ip",
            "vulnerabilityId" to "v.vulnerability_id",
            "cvssSeverity" to "v.cvss_severity",
            "vulnerableProductVersions" to "v.vulnerable_product_versions",
            "daysOpen" to "v.days_open",
            "scanTimestamp" to "v.scan_timestamp",
            "importTimestamp" to "v.import_timestamp"
        )
    }

    @Transactional
    open fun getCurrentVulnerabilitiesOptimized(
        accessibleAssetIds: Set<Long>,
        isAdmin: Boolean,
        severity: String?,
        system: String?,
        exceptionStatus: String?,
        product: String?,
        adDomain: String?,
        cloudAccountId: String? = null,
        page: Int,
        size: Int,
        sort: String? = null,
        sortDir: String? = null
    ): com.secman.dto.PaginatedVulnerabilitiesResponse {
        log.debug("Getting current vulnerabilities (optimized) - isAdmin: {}, assetIds: {}, severity: {}, system: {}, exceptionStatus: {}, cloudAccountId: {}, page: {}, size: {}",
            isAdmin, if (isAdmin) "ALL" else accessibleAssetIds.size, severity, system, exceptionStatus, cloudAccountId, page, size)

        // Pre-process filter values: lowercase domain filter since adDomain is stored normalized
        val normalizedDomainFilter = adDomain?.takeIf { it.isNotBlank() }?.lowercase()
        val normalizedCloudAccountIdFilter = cloudAccountId?.takeIf { it.isNotBlank() }
        val normalizedSeverity = severity?.takeIf { it.isNotBlank() }
        val normalizedSystem = system?.takeIf { it.isNotBlank() }
        val normalizedProduct = product?.takeIf { it.isNotBlank() }
        val normalizedExceptionStatus = exceptionStatus?.lowercase()?.replace("-", "_")?.takeIf { it.isNotBlank() }

        // Non-ADMIN: check for empty accessible assets
        if (!isAdmin && accessibleAssetIds.isEmpty()) {
            return com.secman.dto.PaginatedVulnerabilitiesResponse(
                content = emptyList(),
                totalElements = 0,
                totalPages = 0,
                currentPage = page,
                pageSize = size,
                hasNext = false,
                hasPrevious = false
            )
        }

        // Get active exceptions ONCE (cached)
        val activeExceptions = getActiveExceptions()
        log.debug("Found {} active exceptions (from cache)", activeExceptions.size)

        // PERFORMANCE (Feature 073): When exception status filter is set,
        // use SQL-level filtering to avoid loading all 358k rows into memory
        // This now applies to both admin AND non-admin users
        if (!normalizedExceptionStatus.isNullOrBlank()) {
            return if (isAdmin) {
                getCurrentVulnerabilitiesByStatusSql(
                    normalizedExceptionStatus, normalizedSeverity, normalizedSystem,
                    normalizedProduct, normalizedDomainFilter, normalizedCloudAccountIdFilter,
                    activeExceptions, page, size
                )
            } else {
                // Feature 073: SQL-level filtering for non-admin users
                getCurrentVulnerabilitiesByStatusSqlWithAccessControl(
                    accessibleAssetIds, normalizedExceptionStatus, normalizedSeverity,
                    normalizedSystem, normalizedProduct, normalizedDomainFilter,
                    normalizedCloudAccountIdFilter, activeExceptions, page, size
                )
            }
        }

        // Determine if custom sort is requested
        val hasCustomSort = !sort.isNullOrBlank() && SORT_FIELD_MAP.containsKey(sort)
        val pageable = io.micronaut.data.model.Pageable.from(page, size)

        // PERFORMANCE: Use EntityManager with dynamic ORDER BY for custom sorts (admin only)
        // The @Query JPQL methods have hardcoded ORDER BY, so Pageable.sort doesn't work with them
        if (hasCustomSort && isAdmin) {
            return getCurrentVulnerabilitiesWithCustomSort(
                normalizedSeverity, normalizedSystem, normalizedProduct,
                normalizedDomainFilter, normalizedCloudAccountIdFilter,
                normalizedExceptionStatus, activeExceptions,
                sort!!, sortDir, page, size
            )
        }

        // Choose query based on admin status (uses default ORDER BY from JPQL)
        // No exception status filter at this point - use standard pagination
        val vulnPage = if (isAdmin) {
            vulnerabilityRepository.findLatestVulnerabilitiesPerAssetWithFilters(
                severity = normalizedSeverity,
                assetName = normalizedSystem,
                productFilter = normalizedProduct,
                domainFilter = normalizedDomainFilter,
                cloudAccountIdFilter = normalizedCloudAccountIdFilter,
                pageable = pageable
            )
        } else {
            vulnerabilityRepository.findLatestVulnerabilitiesWithAccessControl(
                accessibleAssetIds = accessibleAssetIds,
                severity = normalizedSeverity,
                assetName = normalizedSystem,
                productFilter = normalizedProduct,
                domainFilter = normalizedDomainFilter,
                cloudAccountIdFilter = normalizedCloudAccountIdFilter,
                pageable = pageable
            )
        }

        val currentVulns = vulnPage.content
        log.debug("Found {} vulnerabilities from database query", currentVulns.size)

        // Map to DTOs with exception information
        val vulnsWithException = mapToVulnerabilityDtos(currentVulns, activeExceptions)

        // Check if all filters are empty (for cached count optimization)
        val hasNoFilters = normalizedSeverity == null && normalizedSystem == null && normalizedProduct == null
                && normalizedDomainFilter == null && normalizedCloudAccountIdFilter == null

        // No exception filter - use DB pagination metadata
        // PERFORMANCE: Use cached total count for unfiltered admin queries
        val totalElements = if (isAdmin && hasNoFilters) {
            getCachedTotalCount()
        } else {
            vulnPage.totalSize
        }
        val totalPages = if (totalElements > 0) kotlin.math.ceil(totalElements.toDouble() / size).toInt() else 0

        val filteredResult = com.secman.dto.PaginatedVulnerabilitiesResponse(
            content = vulnsWithException,
            totalElements = totalElements,
            totalPages = totalPages,
            currentPage = page,
            pageSize = size,
            hasNext = page < totalPages - 1,
            hasPrevious = page > 0
        )

        log.info("Returning {} current vulnerabilities (page {}/{}, total {})",
            filteredResult.content.size, page + 1, filteredResult.totalPages, filteredResult.totalElements)
        return filteredResult
    }

    /**
     * SQL-level exception status filtering for admin users
     * Eliminates loading all 358k rows into memory when filtering by overdue/excepted/ok
     */
    private fun getCurrentVulnerabilitiesByStatusSql(
        exceptionStatus: String,
        severity: String?,
        system: String?,
        product: String?,
        domainFilter: String?,
        cloudAccountIdFilter: String?,
        activeExceptions: List<VulnerabilityException>,
        page: Int,
        size: Int
    ): com.secman.dto.PaginatedVulnerabilitiesResponse {
        val reminderOneDays = vulnerabilityConfigService.getReminderOneDays()
        val thresholdDate = LocalDateTime.now().minusDays(reminderOneDays.toLong())
        val pageOffset = page * size

        log.debug("Using SQL-level exception status filter: {} (threshold: {} days, date: {})",
            exceptionStatus, reminderOneDays, thresholdDate)

        val (vulns, totalCount) = when (exceptionStatus) {
            "overdue" -> {
                val data = vulnerabilityRepository.findOverdueVulnerabilitiesAdmin(
                    thresholdDate, severity, system, product, domainFilter, cloudAccountIdFilter, size, pageOffset
                )
                val count = vulnerabilityRepository.countOverdueVulnerabilitiesAdmin(
                    thresholdDate, severity, system, product, domainFilter, cloudAccountIdFilter
                )
                Pair(data, count)
            }
            "excepted" -> {
                val data = vulnerabilityRepository.findExceptedVulnerabilitiesAdmin(
                    severity, system, product, domainFilter, cloudAccountIdFilter, size, pageOffset
                )
                val count = vulnerabilityRepository.countExceptedVulnerabilitiesAdmin(
                    severity, system, product, domainFilter, cloudAccountIdFilter
                )
                Pair(data, count)
            }
            "ok" -> {
                val data = vulnerabilityRepository.findOkVulnerabilitiesAdmin(
                    thresholdDate, severity, system, product, domainFilter, cloudAccountIdFilter, size, pageOffset
                )
                val count = vulnerabilityRepository.countOkVulnerabilitiesAdmin(
                    thresholdDate, severity, system, product, domainFilter, cloudAccountIdFilter
                )
                Pair(data, count)
            }
            else -> {
                // "not_excepted" falls back to in-memory (combination of overdue + ok)
                log.debug("Unsupported SQL exception status '{}', falling back", exceptionStatus)
                return getCurrentVulnerabilitiesOptimized(
                    emptySet(), true, severity, system, null, product,
                    domainFilter, cloudAccountIdFilter, page, size
                )
            }
        }

        log.debug("SQL status filter returned {} vulns (total: {})", vulns.size, totalCount)

        val vulnsWithException = mapToVulnerabilityDtos(vulns, activeExceptions)
        val totalPages = if (totalCount > 0) kotlin.math.ceil(totalCount.toDouble() / size).toInt() else 0

        return com.secman.dto.PaginatedVulnerabilitiesResponse(
            content = vulnsWithException,
            totalElements = totalCount,
            totalPages = totalPages,
            currentPage = page,
            pageSize = size,
            hasNext = page < totalPages - 1,
            hasPrevious = page > 0
        )
    }

    /**
     * SQL-level exception status filtering for non-admin users (with access control)
     * Feature: 073-memory-optimization
     *
     * Eliminates loading all data into memory when filtering by overdue/excepted/ok
     * for non-admin users. Access control is pushed to SQL level.
     */
    private fun getCurrentVulnerabilitiesByStatusSqlWithAccessControl(
        accessibleAssetIds: Set<Long>,
        exceptionStatus: String,
        severity: String?,
        system: String?,
        product: String?,
        domainFilter: String?,
        cloudAccountIdFilter: String?,
        activeExceptions: List<VulnerabilityException>,
        page: Int,
        size: Int
    ): com.secman.dto.PaginatedVulnerabilitiesResponse {
        val reminderOneDays = vulnerabilityConfigService.getReminderOneDays()
        val thresholdDate = LocalDateTime.now().minusDays(reminderOneDays.toLong())
        val pageOffset = page * size

        log.debug("Using SQL-level exception status filter (non-admin): {} (threshold: {} days, assets: {})",
            exceptionStatus, reminderOneDays, accessibleAssetIds.size)

        val (vulns, totalCount) = when (exceptionStatus) {
            "overdue" -> {
                val data = vulnerabilityRepository.findOverdueVulnerabilitiesWithAccessControl(
                    accessibleAssetIds, thresholdDate, severity, system, product,
                    domainFilter, cloudAccountIdFilter, size, pageOffset
                )
                val count = vulnerabilityRepository.countOverdueVulnerabilitiesWithAccessControl(
                    accessibleAssetIds, thresholdDate, severity, system, product,
                    domainFilter, cloudAccountIdFilter
                )
                Pair(data, count)
            }
            "excepted" -> {
                val data = vulnerabilityRepository.findExceptedVulnerabilitiesWithAccessControl(
                    accessibleAssetIds, severity, system, product,
                    domainFilter, cloudAccountIdFilter, size, pageOffset
                )
                val count = vulnerabilityRepository.countExceptedVulnerabilitiesWithAccessControl(
                    accessibleAssetIds, severity, system, product,
                    domainFilter, cloudAccountIdFilter
                )
                Pair(data, count)
            }
            "ok" -> {
                val data = vulnerabilityRepository.findOkVulnerabilitiesWithAccessControl(
                    accessibleAssetIds, thresholdDate, severity, system, product,
                    domainFilter, cloudAccountIdFilter, size, pageOffset
                )
                val count = vulnerabilityRepository.countOkVulnerabilitiesWithAccessControl(
                    accessibleAssetIds, thresholdDate, severity, system, product,
                    domainFilter, cloudAccountIdFilter
                )
                Pair(data, count)
            }
            else -> {
                // "not_excepted" = overdue + ok (not easily combined in SQL)
                // Fall back to standard pagination without exception status
                log.debug("Unsupported SQL exception status '{}' for non-admin, falling back", exceptionStatus)
                return getCurrentVulnerabilitiesOptimized(
                    accessibleAssetIds, false, severity, system, null, product,
                    domainFilter, cloudAccountIdFilter, page, size
                )
            }
        }

        log.debug("SQL status filter (non-admin) returned {} vulns (total: {})", vulns.size, totalCount)

        val vulnsWithException = mapToVulnerabilityDtos(vulns, activeExceptions)
        val totalPages = if (totalCount > 0) kotlin.math.ceil(totalCount.toDouble() / size).toInt() else 0

        return com.secman.dto.PaginatedVulnerabilitiesResponse(
            content = vulnsWithException,
            totalElements = totalCount,
            totalPages = totalPages,
            currentPage = page,
            pageSize = size,
            hasNext = page < totalPages - 1,
            hasPrevious = page > 0
        )
    }

    /**
     * Map vulnerability entities to DTOs with exception and overdue status information
     */
    private fun mapToVulnerabilityDtos(
        vulns: List<Vulnerability>,
        activeExceptions: List<VulnerabilityException>
    ): List<VulnerabilityWithExceptionDto> {
        return vulns.map { vuln ->
            val overdueInfo = calculateOverdueStatus(vuln, vuln.asset, activeExceptions)
            val matchingException = activeExceptions.firstOrNull { it.matches(vuln, vuln.asset) }

            VulnerabilityWithExceptionDto(
                id = vuln.id,
                asset = vuln.asset,
                assetId = vuln.asset.id!!,
                assetName = vuln.asset.name,
                assetIp = vuln.asset.ip,
                vulnerabilityId = vuln.vulnerabilityId,
                cvssSeverity = vuln.cvssSeverity,
                vulnerableProductVersions = vuln.vulnerableProductVersions,
                daysOpen = vuln.daysOpen,
                scanTimestamp = vuln.scanTimestamp,
                hasException = matchingException != null,
                exceptionReason = matchingException?.reason,
                ageInDays = overdueInfo.ageInDays,
                overdueStatus = overdueInfo.status,
                daysOverdue = overdueInfo.daysOverdue,
                exceptionId = overdueInfo.exceptionId,
                exceptionEndDate = overdueInfo.exceptionEndDate
            )
        }
    }

    /**
     * Execute paginated vulnerability query with custom ORDER BY using EntityManager
     * Required because Micronaut Data @Query with JPQL doesn't support dynamic Sort from Pageable
     */
    private fun getCurrentVulnerabilitiesWithCustomSort(
        severity: String?,
        system: String?,
        product: String?,
        domainFilter: String?,
        cloudAccountIdFilter: String?,
        exceptionStatus: String?,
        activeExceptions: List<VulnerabilityException>,
        sort: String,
        sortDir: String?,
        page: Int,
        size: Int
    ): com.secman.dto.PaginatedVulnerabilitiesResponse {
        val sortColumn = SORT_FIELD_MAP[sort] ?: "v.importTimestamp"
        val direction = if (sortDir?.lowercase() == "asc") "ASC" else "DESC"

        log.debug("Custom sort query: ORDER BY {} {}", sortColumn, direction)

        // Build JPQL dynamically with custom ORDER BY
        val jpqlBase = StringBuilder("""
            SELECT v FROM Vulnerability v
            JOIN FETCH v.asset a
            WHERE 1=1
        """.trimIndent())

        val countBase = StringBuilder("""
            SELECT COUNT(v) FROM Vulnerability v JOIN v.asset a
            WHERE 1=1
        """.trimIndent())

        val params = mutableMapOf<String, Any>()

        if (severity != null) {
            jpqlBase.append(" AND v.cvssSeverity = :severity")
            countBase.append(" AND v.cvssSeverity = :severity")
            params["severity"] = severity
        }
        if (system != null) {
            jpqlBase.append(" AND LOWER(a.name) LIKE LOWER(CONCAT('%', :assetName, '%'))")
            countBase.append(" AND LOWER(a.name) LIKE LOWER(CONCAT('%', :assetName, '%'))")
            params["assetName"] = system
        }
        if (product != null) {
            jpqlBase.append(" AND LOWER(v.vulnerableProductVersions) LIKE LOWER(CONCAT('%', :productFilter, '%'))")
            countBase.append(" AND LOWER(v.vulnerableProductVersions) LIKE LOWER(CONCAT('%', :productFilter, '%'))")
            params["productFilter"] = product
        }
        if (domainFilter != null) {
            jpqlBase.append(" AND a.adDomain LIKE CONCAT('%', :domainFilter, '%')")
            countBase.append(" AND a.adDomain LIKE CONCAT('%', :domainFilter, '%')")
            params["domainFilter"] = domainFilter
        }
        if (cloudAccountIdFilter != null) {
            jpqlBase.append(" AND a.cloudAccountId LIKE CONCAT('%', :cloudAccountIdFilter, '%')")
            countBase.append(" AND a.cloudAccountId LIKE CONCAT('%', :cloudAccountIdFilter, '%')")
            params["cloudAccountIdFilter"] = cloudAccountIdFilter
        }

        jpqlBase.append(" ORDER BY $sortColumn $direction")

        // Execute count query
        val countQuery = entityManager.createQuery(countBase.toString(), Long::class.javaObjectType)
        params.forEach { (k, v) -> countQuery.setParameter(k, v) }
        val totalCount = countQuery.singleResult

        // Execute data query with pagination
        val dataQuery = entityManager.createQuery(jpqlBase.toString(), Vulnerability::class.java)
        params.forEach { (k, v) -> dataQuery.setParameter(k, v) }
        dataQuery.firstResult = page * size
        dataQuery.maxResults = size

        @Suppress("UNCHECKED_CAST")
        val vulns = dataQuery.resultList as List<Vulnerability>

        val vulnsWithException = mapToVulnerabilityDtos(vulns, activeExceptions)
        val totalPages = if (totalCount > 0) kotlin.math.ceil(totalCount.toDouble() / size).toInt() else 0

        log.info("Custom sort query returned {} vulns (total: {}, sort: {} {})",
            vulns.size, totalCount, sortColumn, direction)

        return com.secman.dto.PaginatedVulnerabilitiesResponse(
            content = vulnsWithException,
            totalElements = totalCount,
            totalPages = totalPages,
            currentPage = page,
            pageSize = size,
            hasNext = page < totalPages - 1,
            hasPrevious = page > 0
        )
    }

    /**
     * Get distinct product versions from all vulnerabilities
     * Feature 021 Phase 3: For product autocomplete
     *
     * @param searchTerm Optional search term to filter products
     * @param limit Maximum number of results (default: 50)
     * @return List of unique product version strings
     */
    fun getDistinctProducts(searchTerm: String? = null, limit: Int = 50): List<String> {
        log.debug("Getting distinct products - searchTerm: {}, limit: {}", searchTerm, limit)

        val allProducts = vulnerabilityRepository.findDistinctProductVersions()

        val filtered = if (!searchTerm.isNullOrBlank()) {
            allProducts.filter { it.contains(searchTerm, ignoreCase = true) }
        } else {
            allProducts
        }

        val limited = filtered.take(limit)
        log.info("Returning {} distinct products", limited.size)
        return limited
    }

    /**
     * Get distinct AD domains from all assets
     * For filter dropdown population in Current Vulnerabilities view
     *
     * @return List of unique AD domain names
     */
    fun getDistinctAdDomains(): List<String> {
        log.debug("Getting distinct AD domains")

        val domains = assetRepository.findDistinctAdDomains()

        log.info("Returning {} distinct AD domains", domains.size)
        return domains
    }

    /**
     * Get distinct AWS cloud account IDs from all assets
     * For filter dropdown population in Current Vulnerabilities view
     *
     * @return List of unique AWS cloud account IDs
     */
    fun getDistinctCloudAccountIds(): List<String> {
        log.debug("Getting distinct AWS cloud account IDs")

        val accountIds = assetRepository.findDistinctCloudAccountIds()

        log.info("Returning {} distinct AWS cloud account IDs", accountIds.size)
        return accountIds
    }

    /**
     * Preview vulnerabilities that would be affected by an exception
     * Feature 021 Phase 3: For impact preview before creating exception
     *
     * @param exceptionType Type of exception (IP/PRODUCT/ASSET)
     * @param targetValue Target value (IP address, product name, or asset name)
     * @param assetId Asset ID (for ASSET type)
     * @param limit Maximum number of vulnerabilities to return (default: 10)
     * @return Pair of (affected vulnerabilities sample, total count)
     */
    fun previewExceptionImpact(
        exceptionType: com.secman.domain.VulnerabilityException.ExceptionType,
        targetValue: String,
        assetId: Long? = null,
        limit: Int = 10
    ): Pair<List<VulnerabilityWithExceptionDto>, Int> {
        log.debug("Previewing exception impact - type: {}, target: {}, assetId: {}", 
            exceptionType, targetValue, assetId)
        
        // Get all current vulnerabilities (latest scan per asset)
        val allVulns = vulnerabilityRepository.findAll().sortedByDescending { it.scanTimestamp }
        val latestScanPerAsset = allVulns
            .groupBy { it.asset.id }
            .mapValues { (_, vulns) -> vulns.maxOf { it.scanTimestamp } }
        
        val currentVulns = allVulns.filter { vuln ->
            vuln.asset.id != null && vuln.scanTimestamp == latestScanPerAsset[vuln.asset.id]
        }
        
        // Filter based on exception type
        val affected = when (exceptionType) {
            com.secman.domain.VulnerabilityException.ExceptionType.IP -> {
                // Filter by IP address (match asset IP)
                currentVulns.filter { vuln ->
                    vuln.asset.ip?.equals(targetValue, ignoreCase = true) == true
                }
            }
            com.secman.domain.VulnerabilityException.ExceptionType.PRODUCT -> {
                // Filter by product (substring match)
                currentVulns.filter { vuln ->
                    vuln.vulnerableProductVersions?.contains(targetValue, ignoreCase = true) == true
                }
            }
            com.secman.domain.VulnerabilityException.ExceptionType.ASSET -> {
                // Filter by asset ID
                if (assetId != null) {
                    currentVulns.filter { vuln -> vuln.asset.id == assetId }
                } else {
                    emptyList()
                }
            }
        }
        
        val totalCount = affected.size

        // PERFORMANCE: Get active exceptions ONCE (cached for 5 minutes)
        val activeExceptions = getActiveExceptions()

        // Convert to DTO with exception info
        val affectedDtos = affected.map { vuln ->
            // Calculate overdue status - pass pre-loaded exceptions to avoid N+1 queries
            val overdueInfo = calculateOverdueStatus(vuln, vuln.asset, activeExceptions)
            
            // Check if any active exception matches this vulnerability
            val matchingException = activeExceptions.firstOrNull { exception ->
                exception.matches(vuln, vuln.asset)
            }

            val hasException = matchingException != null
            val exceptionReason = matchingException?.reason

            VulnerabilityWithExceptionDto(
                id = vuln.id,
                asset = vuln.asset,
                assetId = vuln.asset.id!!,
                assetName = vuln.asset.name,
                assetIp = vuln.asset.ip,
                vulnerabilityId = vuln.vulnerabilityId,
                cvssSeverity = vuln.cvssSeverity,
                vulnerableProductVersions = vuln.vulnerableProductVersions,
                daysOpen = vuln.daysOpen,
                scanTimestamp = vuln.scanTimestamp,
                hasException = hasException,
                exceptionReason = exceptionReason,
                ageInDays = overdueInfo.ageInDays,
                overdueStatus = overdueInfo.status,
                daysOverdue = overdueInfo.daysOverdue,
                exceptionId = overdueInfo.exceptionId,
                exceptionEndDate = overdueInfo.exceptionEndDate
            )
        }
        
        val sample = affectedDtos.take(limit)
        
        log.info("Exception would affect {} vulnerabilities (showing {} sample)",
            totalCount, sample.size)
        return Pair(sample, totalCount)
    }

    /**
     * Cleanup duplicate vulnerabilities from the database
     *
     * A duplicate vulnerability is defined as:
     * - Same asset ID
     * - Same vulnerability ID (CVE)
     * - Same scan timestamp
     *
     * The cleanup process keeps the oldest record (lowest ID) and removes newer duplicates.
     * This is safe because the record with the lowest ID was created first and represents
     * the original entry.
     *
     * @return VulnerabilityCleanupResult with statistics about the cleanup operation
     */
    /**
     * Cleanup duplicate vulnerabilities using batched SQL-based approach
     * Feature: 073-memory-optimization
     *
     * Uses window function (ROW_NUMBER) to identify duplicates at SQL level,
     * avoiding loading all 300K+ vulnerabilities into memory.
     *
     * Processes in batches (configurable via memoryConfig.batchSize) to:
     * - Keep memory usage bounded
     * - Allow progress tracking
     * - Enable graceful interruption
     *
     * @return VulnerabilityCleanupResult with statistics about the cleanup operation
     */
    @Transactional
    open fun cleanupDuplicates(): com.secman.dto.VulnerabilityCleanupResult {
        log.info("Starting vulnerability duplicate cleanup (batched mode, batchSize={})", memoryConfig.batchSize)

        // Get total count first (for reporting)
        val totalScanned = vulnerabilityRepository.countAll().toInt()
        log.debug("Total vulnerabilities in database: {}", totalScanned)

        var duplicatesRemoved = 0
        var batchNumber = 0

        // Process duplicates in batches using SQL-level identification
        do {
            batchNumber++
            val duplicateIds = vulnerabilityRepository.findDuplicateIds(memoryConfig.batchSize)

            if (duplicateIds.isEmpty()) {
                log.debug("Batch {}: No more duplicates found", batchNumber)
                break
            }

            log.debug("Batch {}: Found {} duplicates to delete", batchNumber, duplicateIds.size)

            // Delete duplicates in this batch
            var batchDeleted = 0
            duplicateIds.forEach { id ->
                try {
                    vulnerabilityRepository.deleteById(id)
                    batchDeleted++
                    duplicatesRemoved++
                } catch (e: Exception) {
                    log.error("Failed to delete duplicate vulnerability ID {}: {}", id, e.message)
                }
            }

            log.info("Batch {}: Deleted {} duplicates (total removed: {})",
                batchNumber, batchDeleted, duplicatesRemoved)

            // Safety check: prevent infinite loop if duplicates keep appearing
            if (batchNumber > 1000) {
                log.warn("Exceeded 1000 batches, stopping cleanup. Total removed: {}", duplicatesRemoved)
                break
            }

        } while (true)

        val uniqueRemaining = totalScanned - duplicatesRemoved

        log.info("Cleanup completed: scanned={}, duplicatesRemoved={}, uniqueRemaining={}, batches={}",
            totalScanned, duplicatesRemoved, uniqueRemaining, batchNumber)

        return if (duplicatesRemoved > 0) {
            com.secman.dto.VulnerabilityCleanupResult.success(
                totalScanned = totalScanned,
                duplicatesFound = duplicatesRemoved, // In batched mode, found = removed
                duplicatesRemoved = duplicatesRemoved,
                uniqueRemaining = uniqueRemaining
            )
        } else {
            com.secman.dto.VulnerabilityCleanupResult.noCleanupNeeded(totalScanned)
        }
    }

    /**
     * Add or update vulnerability from CLI command
     * Feature: 052-cli-add-vulnerability
     *
     * Implements upsert pattern:
     * - If asset doesn't exist: create it with type=SERVER, owner=CLI-IMPORT
     * - If vulnerability with same CVE exists for asset: update it
     * - Otherwise: create new vulnerability
     *
     * @param request The add vulnerability request DTO
     * @return AddVulnerabilityResponseDto with operation result
     */
    @Transactional
    open fun addVulnerabilityFromCli(request: AddVulnerabilityRequestDto): AddVulnerabilityResponseDto {
        log.info("Adding vulnerability from CLI: hostname={}, cve={}, criticality={}, daysOpen={}",
            request.hostname, request.cve, request.criticality, request.daysOpen)

        // Step 1: Find or create asset
        var assetCreated = false
        var asset = assetRepository.findByNameIgnoreCase(request.hostname)

        if (asset == null) {
            // Create new asset with defaults
            asset = Asset(
                name = request.hostname,
                type = "SERVER",
                owner = "CLI-IMPORT"
            )
            asset.lastSeen = LocalDateTime.now()
            asset = assetRepository.save(asset)
            assetCreated = true
            log.info("Created new asset: id={}, name={}", asset.id, asset.name)
        } else {
            // Update lastSeen timestamp
            asset.lastSeen = LocalDateTime.now()
            asset = assetRepository.update(asset)
            log.debug("Found existing asset: id={}, name={}", asset.id, asset.name)
        }

        // Step 2: Map criticality to database format (title case)
        val cvssSeverity = when (request.criticality.uppercase()) {
            "CRITICAL" -> "Critical"
            "HIGH" -> "High"
            "MEDIUM" -> "Medium"
            "LOW" -> "Low"
            else -> request.criticality // Fallback to original
        }

        // Step 3: Calculate scan timestamp from daysOpen
        val scanTimestamp = LocalDateTime.now().minusDays(request.daysOpen.toLong())
        val daysOpenText = if (request.daysOpen == 1) "1 day" else "${request.daysOpen} days"

        // Step 4: Find existing vulnerability or create new one (upsert)
        val existingVuln = vulnerabilityRepository.findByAssetAndVulnerabilityId(asset, request.cve)
        val operation: String

        val vulnerability = if (existingVuln != null) {
            // Update existing vulnerability
            existingVuln.cvssSeverity = cvssSeverity
            existingVuln.daysOpen = daysOpenText
            existingVuln.scanTimestamp = scanTimestamp
            existingVuln.importTimestamp = LocalDateTime.now()
            vulnerabilityRepository.update(existingVuln)
            operation = "UPDATED"
            log.info("Updated existing vulnerability: id={}, cve={}", existingVuln.id, request.cve)
            existingVuln
        } else {
            // Create new vulnerability
            val newVuln = Vulnerability(
                asset = asset,
                vulnerabilityId = request.cve,
                cvssSeverity = cvssSeverity,
                daysOpen = daysOpenText,
                scanTimestamp = scanTimestamp
            )
            newVuln.importTimestamp = LocalDateTime.now()
            vulnerabilityRepository.save(newVuln)
            operation = "CREATED"
            log.info("Created new vulnerability: id={}, cve={}", newVuln.id, request.cve)
            newVuln
        }

        // Step 6: Synchronize importTimestamp for all other vulnerabilities on this asset
        // This ensures they are all considered part of the "latest" batch in DomainVulnsView
        // which filters by ranking importTimestamp (fix for CLI sequential imports hiding previous vulns)
        if (!assetCreated && vulnerability.importTimestamp != null) {
            val otherVulns = vulnerabilityRepository.findByAssetId(
                asset.id!!, 
                io.micronaut.data.model.Pageable.UNPAGED
            ).content
            
            val vulnsToUpdate = otherVulns.filter { it.id != vulnerability.id }
            
            if (vulnsToUpdate.isNotEmpty()) {
                log.info("Synchronizing importTimestamp for {} other vulnerabilities on asset {}", 
                    vulnsToUpdate.size, asset.name)
                
                vulnsToUpdate.forEach { v ->
                    v.importTimestamp = vulnerability.importTimestamp
                    vulnerabilityRepository.update(v)
                }
            }
        }

        // Step 5: Build response message
        val message = if (assetCreated) {
            "Asset ${asset.name} created. Vulnerability ${request.cve} added."
        } else if (operation == "UPDATED") {
            "Vulnerability ${request.cve} updated on asset ${asset.name}"
        } else {
            "Vulnerability ${request.cve} added to asset ${asset.name}"
        }

        return AddVulnerabilityResponseDto(
            success = true,
            message = message,
            assetName = asset.name,
            assetCreated = assetCreated,
            vulnerabilityId = request.cve,
            operation = operation
        )
    }
}
