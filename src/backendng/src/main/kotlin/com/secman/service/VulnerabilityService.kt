package com.secman.service

import com.secman.dto.VulnerabilityWithExceptionDto
import com.secman.repository.VulnerabilityRepository
import com.secman.repository.VulnerabilityExceptionRepository
import jakarta.inject.Singleton
import org.slf4j.LoggerFactory
import java.time.LocalDateTime

/**
 * Service for vulnerability operations and filtering
 *
 * Handles:
 * - Querying current vulnerabilities (latest scan per asset)
 * - Filtering by severity, system, exception status
 * - Checking exception status per vulnerability
 *
 * Related to: Feature 004-i-want-to (VULN Role & Vulnerability Management UI)
 */
@Singleton
class VulnerabilityService(
    private val vulnerabilityRepository: VulnerabilityRepository,
    private val vulnerabilityExceptionRepository: VulnerabilityExceptionRepository
) {
    private val log = LoggerFactory.getLogger(VulnerabilityService::class.java)

    /**
     * Get current vulnerabilities (latest scan per asset) with exception status
     *
     * @param severity Optional CVSS severity filter (e.g., "Critical", "High")
     * @param system Optional system/asset name filter
     * @param exceptionStatus Optional filter: "excepted", "not_excepted", or null (all)
     * @param product Optional product/version filter (substring match)
     * @param page Page number (0-indexed)
     * @param size Page size (default 50)
     * @return Paginated list of vulnerabilities with exception information
     */
    fun getCurrentVulnerabilities(
        severity: String? = null,
        system: String? = null,
        exceptionStatus: String? = null,
        product: String? = null,
        page: Int = 0,
        size: Int = 50
    ): Pair<List<VulnerabilityWithExceptionDto>, Long> {
        log.debug("Getting current vulnerabilities - severity: {}, system: {}, exceptionStatus: {}, product: {}, page: {}, size: {}",
            severity, system, exceptionStatus, product, page, size)

        // Get all vulnerabilities ordered by scan timestamp DESC
        val allVulns = vulnerabilityRepository.findAll().sortedByDescending { it.scanTimestamp }

        // Group by asset ID and get max scan timestamp per asset
        val latestScanPerAsset = allVulns
            .groupBy { it.asset.id }
            .mapValues { (_, vulns) -> vulns.maxOf { it.scanTimestamp } }

        log.debug("Found {} unique assets with scans", latestScanPerAsset.size)

        // Filter to only vulnerabilities from latest scan
        var currentVulns = allVulns.filter { vuln ->
            vuln.scanTimestamp == latestScanPerAsset[vuln.asset.id]
        }

        log.debug("Filtered to {} current vulnerabilities", currentVulns.size)

        // Apply severity filter
        if (!severity.isNullOrBlank()) {
            currentVulns = currentVulns.filter { vuln ->
                vuln.cvssSeverity?.equals(severity, ignoreCase = true) == true
            }
            log.debug("After severity filter: {} vulnerabilities", currentVulns.size)
        }

        // Apply system filter (asset name contains)
        if (!system.isNullOrBlank()) {
            currentVulns = currentVulns.filter { vuln ->
                vuln.asset.name.contains(system, ignoreCase = true)
            }
            log.debug("After system filter: {} vulnerabilities", currentVulns.size)
        }

        // Apply product filter (vulnerable product versions contains)
        if (!product.isNullOrBlank()) {
            currentVulns = currentVulns.filter { vuln ->
                vuln.vulnerableProductVersions?.contains(product, ignoreCase = true) == true
            }
            log.debug("After product filter: {} vulnerabilities", currentVulns.size)
        }

        // Get all active exceptions (not expired)
        val activeExceptions = vulnerabilityExceptionRepository.findAll().toList()
            .filter { it.isActive() }

        // Map to DTOs with exception information
        val vulnsWithException = currentVulns.map { vuln ->
            // Check if any active exception matches this vulnerability
            val matchingException = activeExceptions.firstOrNull { exception ->
                exception.matches(vuln, vuln.asset)
            }

            val hasException = matchingException != null
            val exceptionReason = matchingException?.reason

            VulnerabilityWithExceptionDto(
                id = vuln.id,
                asset = vuln.asset,  // Include full asset entity
                assetId = vuln.asset.id!!,
                assetName = vuln.asset.name,
                assetIp = vuln.asset.ip,
                vulnerabilityId = vuln.vulnerabilityId,
                cvssSeverity = vuln.cvssSeverity,
                vulnerableProductVersions = vuln.vulnerableProductVersions,
                daysOpen = vuln.daysOpen,
                scanTimestamp = vuln.scanTimestamp,
                hasException = hasException,
                exceptionReason = exceptionReason
            )
        }

        // Apply exception status filter (support both hyphen and underscore formats)
        val normalizedExceptionStatus = exceptionStatus?.lowercase()?.replace("-", "_")
        val result = when (normalizedExceptionStatus) {
            "excepted" -> vulnsWithException.filter { it.hasException }
            "not_excepted" -> vulnsWithException.filter { !it.hasException }
            else -> vulnsWithException
        }

        val totalElements = result.size.toLong()
        
        // Apply pagination
        val startIndex = page * size
        val endIndex = minOf(startIndex + size, result.size)
        
        val paginatedResult = if (startIndex < result.size) {
            result.subList(startIndex, endIndex)
        } else {
            emptyList()
        }

        log.info("Returning {} current vulnerabilities (page {}, size {}), total: {}", 
            paginatedResult.size, page, size, totalElements)
        return Pair(paginatedResult, totalElements)
    }
}
