package com.secman.service

import com.secman.domain.Asset
import com.secman.domain.Vulnerability
import com.secman.domain.VulnerabilityException
import com.secman.dto.OverdueStatus
import com.secman.dto.VulnerabilityWithExceptionDto
import com.secman.repository.VulnerabilityRepository
import com.secman.repository.VulnerabilityExceptionRepository
import jakarta.inject.Singleton
import org.slf4j.LoggerFactory
import java.time.LocalDateTime
import java.time.temporal.ChronoUnit

/**
 * Service for vulnerability operations and filtering
 *
 * Handles:
 * - Querying current vulnerabilities (latest scan per asset)
 * - Filtering by severity, system, exception status, overdue status
 * - Checking exception status per vulnerability
 * - Calculating overdue status based on configurable threshold
 *
 * Related to: Feature 004-i-want-to (VULN Role & Vulnerability Management UI)
 * Related to: Feature 021-vulnerability-overdue-exception-logic
 */
@Singleton
class VulnerabilityService(
    private val vulnerabilityRepository: VulnerabilityRepository,
    private val vulnerabilityExceptionRepository: VulnerabilityExceptionRepository,
    private val vulnerabilityConfigService: VulnerabilityConfigService
) {
    private val log = LoggerFactory.getLogger(VulnerabilityService::class.java)
    
    /**
     * Data class to hold overdue status information for a vulnerability
     *
     * @property status The overdue status (OK, OVERDUE, EXCEPTED)
     * @property ageInDays Age of vulnerability in days since scan
     * @property daysOverdue Days past the threshold (null if not overdue)
     * @property exceptionId ID of matching exception (if excepted)
     * @property exceptionReason Reason for exception (if excepted)
     * @property exceptionEndDate Exception expiration date (if excepted)
     */
    data class OverdueInfo(
        val status: OverdueStatus,
        val ageInDays: Int,
        val daysOverdue: Int?,
        val exceptionId: Long?,
        val exceptionReason: String?,
        val exceptionEndDate: LocalDateTime?
    )

    /**
     * Calculate overdue status for a vulnerability
     *
     * Determines if a vulnerability is overdue based on:
     * 1. Age of vulnerability (days since scanTimestamp)
     * 2. Configured "Reminder One" threshold
     * 3. Active exceptions (asset or product-based)
     *
     * Status logic:
     * - OK: Age <= threshold
     * - EXCEPTED: Age > threshold BUT has active exception
     * - OVERDUE: Age > threshold AND no active exception
     *
     * Feature 021: Overdue status calculation
     *
     * @param vulnerability The vulnerability to check
     * @param asset The asset the vulnerability is on
     * @return OverdueInfo with complete overdue status information
     */
    fun calculateOverdueStatus(vulnerability: Vulnerability, asset: Asset): OverdueInfo {
        // Get configured threshold
        val reminderOneDays = vulnerabilityConfigService.getReminderOneDays()
        
        // Calculate age in days from scan timestamp to now
        val ageInDays = ChronoUnit.DAYS.between(vulnerability.scanTimestamp, LocalDateTime.now()).toInt()
        
        // Check if any active exception matches this vulnerability
        val activeExceptions = vulnerabilityExceptionRepository.findAll().toList()
            .filter { it.isActive() }
        
        val matchingException = activeExceptions.firstOrNull { exception ->
            exception.matches(vulnerability, asset)
        }
        
        // Determine overdue status
        val isOverdue = ageInDays > reminderOneDays
        val status = when {
            matchingException != null -> OverdueStatus.EXCEPTED  // Has exception, regardless of age
            isOverdue -> OverdueStatus.OVERDUE                    // Overdue and no exception
            else -> OverdueStatus.OK                               // Within threshold
        }
        
        // Calculate days overdue (only if actually overdue after considering exceptions)
        val daysOverdue = if (status == OverdueStatus.OVERDUE) {
            ageInDays - reminderOneDays
        } else {
            null
        }
        
        log.trace("Vulnerability {} on asset {}: age={}d, threshold={}d, status={}, exception={}", 
            vulnerability.id, asset.id, ageInDays, reminderOneDays, status, matchingException?.id)
        
        return OverdueInfo(
            status = status,
            ageInDays = ageInDays,
            daysOverdue = daysOverdue,
            exceptionId = matchingException?.id,
            exceptionReason = matchingException?.reason,
            exceptionEndDate = matchingException?.expirationDate
        )
    }

    /**
     * Get current vulnerabilities (latest scan per asset) with exception status
     *
     * @param severity Optional CVSS severity filter (e.g., "Critical", "High")
     * @param system Optional system/asset name filter
     * @param exceptionStatus Optional filter: "excepted", "not_excepted", "overdue", "ok", or null (all)
     * @param product Optional product/version filter (substring match)
     * @param adDomain Optional AD domain filter (substring match, case-insensitive)
     * @param page Page number (0-indexed)
     * @param size Page size (default 50)
     * @return Paginated list of vulnerabilities with exception information
     */
    fun getCurrentVulnerabilities(
        severity: String? = null,
        system: String? = null,
        exceptionStatus: String? = null,
        product: String? = null,
        adDomain: String? = null,
        page: Int = 0,
        size: Int = 50
    ): Pair<List<VulnerabilityWithExceptionDto>, Long> {
        log.debug("Getting current vulnerabilities - severity: {}, system: {}, exceptionStatus: {}, product: {}, adDomain: {}, page: {}, size: {}",
            severity, system, exceptionStatus, product, adDomain, page, size)

        // Get all vulnerabilities ordered by scan timestamp DESC
        val allVulns = vulnerabilityRepository.findAll().sortedByDescending { it.scanTimestamp }

        // Group by asset ID and get max scan timestamp per asset
        val latestScanPerAsset = allVulns
            .groupBy { it.asset.id }
            .mapValues { (_, vulns) -> vulns.maxOf { it.scanTimestamp } }

        log.debug("Found {} unique assets with scans", latestScanPerAsset.size)

        // Filter to only vulnerabilities from latest scan
        var currentVulns = allVulns.filter { vuln ->
            vuln.scanTimestamp == latestScanPerAsset[vuln.asset.id]
        }

        log.debug("Filtered to {} current vulnerabilities", currentVulns.size)

        // Apply severity filter
        if (!severity.isNullOrBlank()) {
            currentVulns = currentVulns.filter { vuln ->
                vuln.cvssSeverity?.equals(severity, ignoreCase = true) == true
            }
            log.debug("After severity filter: {} vulnerabilities", currentVulns.size)
        }

        // Apply system filter (asset name contains)
        if (!system.isNullOrBlank()) {
            currentVulns = currentVulns.filter { vuln ->
                vuln.asset.name.contains(system, ignoreCase = true)
            }
            log.debug("After system filter: {} vulnerabilities", currentVulns.size)
        }

        // Apply product filter (vulnerable product versions contains)
        if (!product.isNullOrBlank()) {
            currentVulns = currentVulns.filter { vuln ->
                vuln.vulnerableProductVersions?.contains(product, ignoreCase = true) == true
            }
            log.debug("After product filter: {} vulnerabilities", currentVulns.size)
        }

        // Apply AD domain filter (asset AD domain contains)
        if (!adDomain.isNullOrBlank()) {
            currentVulns = currentVulns.filter { vuln ->
                vuln.asset.adDomain?.contains(adDomain, ignoreCase = true) == true
            }
            log.debug("After AD domain filter: {} vulnerabilities", currentVulns.size)
        }

        // Get all active exceptions (not expired)
        val activeExceptions = vulnerabilityExceptionRepository.findAll().toList()
            .filter { it.isActive() }

        // Map to DTOs with exception information and overdue status
        val vulnsWithException = currentVulns.map { vuln ->
            // Calculate overdue status
            val overdueInfo = calculateOverdueStatus(vuln, vuln.asset)
            
            // Check if any active exception matches this vulnerability
            val matchingException = activeExceptions.firstOrNull { exception ->
                exception.matches(vuln, vuln.asset)
            }

            val hasException = matchingException != null
            val exceptionReason = matchingException?.reason

            VulnerabilityWithExceptionDto(
                id = vuln.id,
                asset = vuln.asset,  // Include full asset entity
                assetId = vuln.asset.id!!,
                assetName = vuln.asset.name,
                assetIp = vuln.asset.ip,
                vulnerabilityId = vuln.vulnerabilityId,
                cvssSeverity = vuln.cvssSeverity,
                vulnerableProductVersions = vuln.vulnerableProductVersions,
                daysOpen = vuln.daysOpen,
                scanTimestamp = vuln.scanTimestamp,
                hasException = hasException,
                exceptionReason = exceptionReason,
                // Feature 021: Add overdue status fields
                ageInDays = overdueInfo.ageInDays,
                overdueStatus = overdueInfo.status,
                daysOverdue = overdueInfo.daysOverdue,
                exceptionId = overdueInfo.exceptionId,
                exceptionEndDate = overdueInfo.exceptionEndDate
            )
        }

        // Apply exception status filter (support both hyphen and underscore formats)
        // Feature 021: Enhanced to support overdue status filtering
        val normalizedExceptionStatus = exceptionStatus?.lowercase()?.replace("-", "_")
        val result = when (normalizedExceptionStatus) {
            "excepted" -> vulnsWithException.filter { it.overdueStatus == OverdueStatus.EXCEPTED }
            "not_excepted" -> vulnsWithException.filter { it.overdueStatus != OverdueStatus.EXCEPTED }
            "overdue" -> vulnsWithException.filter { it.overdueStatus == OverdueStatus.OVERDUE }
            "ok" -> vulnsWithException.filter { it.overdueStatus == OverdueStatus.OK }
            else -> vulnsWithException
        }

        val totalElements = result.size.toLong()
        
        // Apply pagination
        val startIndex = page * size
        val endIndex = minOf(startIndex + size, result.size)
        
        val paginatedResult = if (startIndex < result.size) {
            result.subList(startIndex, endIndex)
        } else {
            emptyList()
        }

        log.info("Returning {} current vulnerabilities (page {}, size {}), total: {}", 
            paginatedResult.size, page, size, totalElements)
        return Pair(paginatedResult, totalElements)
    }

    /**
     * Get distinct product versions from all vulnerabilities
     * Feature 021 Phase 3: For product autocomplete
     *
     * @param searchTerm Optional search term to filter products
     * @param limit Maximum number of results (default: 50)
     * @return List of unique product version strings
     */
    fun getDistinctProducts(searchTerm: String? = null, limit: Int = 50): List<String> {
        log.debug("Getting distinct products - searchTerm: {}, limit: {}", searchTerm, limit)
        
        val allProducts = vulnerabilityRepository.findDistinctProductVersions()
        
        val filtered = if (!searchTerm.isNullOrBlank()) {
            allProducts.filter { it.contains(searchTerm, ignoreCase = true) }
        } else {
            allProducts
        }
        
        val limited = filtered.take(limit)
        log.info("Returning {} distinct products", limited.size)
        return limited
    }

    /**
     * Preview vulnerabilities that would be affected by an exception
     * Feature 021 Phase 3: For impact preview before creating exception
     *
     * @param exceptionType Type of exception (IP/PRODUCT/ASSET)
     * @param targetValue Target value (IP address, product name, or asset name)
     * @param assetId Asset ID (for ASSET type)
     * @param limit Maximum number of vulnerabilities to return (default: 10)
     * @return Pair of (affected vulnerabilities sample, total count)
     */
    fun previewExceptionImpact(
        exceptionType: com.secman.domain.VulnerabilityException.ExceptionType,
        targetValue: String,
        assetId: Long? = null,
        limit: Int = 10
    ): Pair<List<VulnerabilityWithExceptionDto>, Int> {
        log.debug("Previewing exception impact - type: {}, target: {}, assetId: {}", 
            exceptionType, targetValue, assetId)
        
        // Get all current vulnerabilities (latest scan per asset)
        val allVulns = vulnerabilityRepository.findAll().sortedByDescending { it.scanTimestamp }
        val latestScanPerAsset = allVulns
            .groupBy { it.asset.id }
            .mapValues { (_, vulns) -> vulns.maxOf { it.scanTimestamp } }
        
        val currentVulns = allVulns.filter { vuln ->
            vuln.asset.id != null && vuln.scanTimestamp == latestScanPerAsset[vuln.asset.id]
        }
        
        // Filter based on exception type
        val affected = when (exceptionType) {
            com.secman.domain.VulnerabilityException.ExceptionType.IP -> {
                // Filter by IP address (match asset IP)
                currentVulns.filter { vuln ->
                    vuln.asset.ip?.equals(targetValue, ignoreCase = true) == true
                }
            }
            com.secman.domain.VulnerabilityException.ExceptionType.PRODUCT -> {
                // Filter by product (substring match)
                currentVulns.filter { vuln ->
                    vuln.vulnerableProductVersions?.contains(targetValue, ignoreCase = true) == true
                }
            }
            com.secman.domain.VulnerabilityException.ExceptionType.ASSET -> {
                // Filter by asset ID
                if (assetId != null) {
                    currentVulns.filter { vuln -> vuln.asset.id == assetId }
                } else {
                    emptyList()
                }
            }
        }
        
        val totalCount = affected.size
        
        // Get all active exceptions
        val activeExceptions = vulnerabilityExceptionRepository.findAll().toList()
            .filter { it.isActive() }
        
        // Convert to DTO with exception info
        val affectedDtos = affected.map { vuln ->
            // Calculate overdue status
            val overdueInfo = calculateOverdueStatus(vuln, vuln.asset)
            
            // Check if any active exception matches this vulnerability
            val matchingException = activeExceptions.firstOrNull { exception ->
                exception.matches(vuln, vuln.asset)
            }

            val hasException = matchingException != null
            val exceptionReason = matchingException?.reason

            VulnerabilityWithExceptionDto(
                id = vuln.id,
                asset = vuln.asset,
                assetId = vuln.asset.id!!,
                assetName = vuln.asset.name,
                assetIp = vuln.asset.ip,
                vulnerabilityId = vuln.vulnerabilityId,
                cvssSeverity = vuln.cvssSeverity,
                vulnerableProductVersions = vuln.vulnerableProductVersions,
                daysOpen = vuln.daysOpen,
                scanTimestamp = vuln.scanTimestamp,
                hasException = hasException,
                exceptionReason = exceptionReason,
                ageInDays = overdueInfo.ageInDays,
                overdueStatus = overdueInfo.status,
                daysOverdue = overdueInfo.daysOverdue,
                exceptionId = overdueInfo.exceptionId,
                exceptionEndDate = overdueInfo.exceptionEndDate
            )
        }
        
        val sample = affectedDtos.take(limit)
        
        log.info("Exception would affect {} vulnerabilities (showing {} sample)",
            totalCount, sample.size)
        return Pair(sample, totalCount)
    }

    /**
     * Cleanup duplicate vulnerabilities from the database
     *
     * A duplicate vulnerability is defined as:
     * - Same asset ID
     * - Same vulnerability ID (CVE)
     * - Same scan timestamp
     *
     * The cleanup process keeps the oldest record (lowest ID) and removes newer duplicates.
     * This is safe because the record with the lowest ID was created first and represents
     * the original entry.
     *
     * @return VulnerabilityCleanupResult with statistics about the cleanup operation
     */
    fun cleanupDuplicates(): com.secman.dto.VulnerabilityCleanupResult {
        log.info("Starting vulnerability duplicate cleanup")

        // Get all vulnerabilities
        val allVulnerabilities = vulnerabilityRepository.findAll().toList()
        val totalScanned = allVulnerabilities.size

        log.debug("Scanned {} total vulnerabilities", totalScanned)

        // Group by composite key: (assetId, vulnerabilityId, scanTimestamp)
        // Duplicates will have multiple entries in the same group
        val grouped = allVulnerabilities.groupBy { vuln ->
            Triple(vuln.asset.id, vuln.vulnerabilityId, vuln.scanTimestamp)
        }

        log.debug("Grouped into {} unique vulnerability keys", grouped.size)

        // Find groups with duplicates (more than 1 vulnerability with same key)
        val duplicateGroups = grouped.filter { (_, vulns) -> vulns.size > 1 }

        log.info("Found {} groups with duplicates", duplicateGroups.size)

        // For each duplicate group, keep the one with the lowest ID (oldest) and delete the rest
        var duplicatesRemoved = 0
        var duplicatesFound = 0

        duplicateGroups.forEach { (key, vulns) ->
            // Sort by ID to ensure we keep the oldest (lowest ID)
            val sorted = vulns.sortedBy { it.id }

            // Count duplicates (all except the first one)
            val duplicateCount = sorted.size - 1
            duplicatesFound += duplicateCount

            log.debug("Group {} has {} duplicates. Keeping ID {} and removing {} others",
                key, duplicateCount, sorted.first().id, sorted.drop(1).map { it.id })

            // Delete all except the first (oldest)
            sorted.drop(1).forEach { duplicate ->
                try {
                    vulnerabilityRepository.deleteById(duplicate.id!!)
                    duplicatesRemoved++
                    log.trace("Deleted duplicate vulnerability ID {}", duplicate.id)
                } catch (e: Exception) {
                    log.error("Failed to delete duplicate vulnerability ID {}: {}",
                        duplicate.id, e.message, e)
                }
            }
        }

        val uniqueRemaining = totalScanned - duplicatesRemoved

        log.info("Cleanup completed: scanned={}, duplicatesFound={}, duplicatesRemoved={}, uniqueRemaining={}",
            totalScanned, duplicatesFound, duplicatesRemoved, uniqueRemaining)

        return if (duplicatesRemoved > 0) {
            com.secman.dto.VulnerabilityCleanupResult.success(
                totalScanned = totalScanned,
                duplicatesFound = duplicatesFound,
                duplicatesRemoved = duplicatesRemoved,
                uniqueRemaining = uniqueRemaining
            )
        } else {
            com.secman.dto.VulnerabilityCleanupResult.noCleanupNeeded(totalScanned)
        }
    }
}
