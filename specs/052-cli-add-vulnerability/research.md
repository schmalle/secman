# Research: CLI Add Vulnerability

**Feature**: 052-cli-add-vulnerability
**Date**: 2025-12-07

## Research Summary

All technical decisions are based on existing codebase patterns. No external research needed.

---

## Decision 1: CLI Command Pattern

**Decision**: Use Picocli with Micronaut DI (matching `manage-user-mappings` pattern)

**Rationale**:
- Existing pattern in `ManageUserMappingsCommand.kt` and `AddDomainCommand.kt`
- Picocli provides parameter validation, help generation, and type conversion
- Micronaut DI allows injection of HTTP client and services

**Alternatives considered**:
- Manual arg parsing (like `QueryCommand`) - rejected for complexity
- Separate executable - rejected for code reuse

**Reference**: `src/cli/src/main/kotlin/com/secman/cli/commands/AddDomainCommand.kt:22-30`

---

## Decision 2: Backend API Integration

**Decision**: Create new endpoint `POST /api/vulnerabilities/cli-add` with upsert logic

**Rationale**:
- Follows API-first principle from constitution
- Allows RBAC enforcement at controller level
- Separates CLI from direct database access
- Existing `VulnerabilityStorageService.kt` uses HTTP client pattern

**Alternatives considered**:
- Direct database access from CLI - rejected (violates RBAC principle)
- Reuse existing `/api/crowdstrike/vulnerabilities/save` - rejected (different payload structure, batch-oriented)

**Reference**: `src/cli/src/main/kotlin/com/secman/cli/service/VulnerabilityStorageService.kt:41-70`

---

## Decision 3: Upsert Implementation

**Decision**: Add `findByAssetAndVulnerabilityId()` to VulnerabilityRepository, use update-or-create in service

**Rationale**:
- Micronaut Data JPA supports derived query methods
- Keeps logic in service layer (not raw SQL)
- Matches existing patterns in AssetRepository

**Implementation**:
```kotlin
// VulnerabilityRepository.kt
fun findByAssetAndVulnerabilityId(asset: Asset, vulnerabilityId: String): Vulnerability?
```

**Alternatives considered**:
- Native SQL UPSERT - rejected (less portable, harder to test)
- Delete-then-insert - rejected (loses created_at timestamp)

**Reference**: `src/backendng/src/main/kotlin/com/secman/repository/AssetRepository.kt:41`

---

## Decision 4: Asset Auto-Creation

**Decision**: Use existing `findByNameIgnoreCase()` + create pattern

**Rationale**:
- Case-insensitive lookup prevents duplicates
- Default type "SERVER" and owner "CLI-IMPORT" match spec requirements
- Existing pattern in CrowdStrike import flow

**Reference**: `src/backendng/src/main/kotlin/com/secman/repository/AssetRepository.kt:41`

---

## Decision 5: Authentication Flow

**Decision**: Reuse `VulnerabilityStorageService.authenticate()` pattern

**Rationale**:
- Already handles JWT token exchange
- Uses `--username` and `--password` parameters
- Returns token for subsequent API calls

**Reference**: `src/cli/src/main/kotlin/com/secman/cli/service/VulnerabilityStorageService.kt:41-70`

---

## Decision 6: Criticality Mapping

**Decision**: Map CLI input (CRITICAL/HIGH/MEDIUM/LOW) to database format (Critical/High/Medium/Low)

**Rationale**:
- Database uses title case for cvss_severity
- CLI input is uppercase for user convenience
- Simple string transformation in service layer

**Mapping**:
| CLI Input | Database Value |
|-----------|----------------|
| CRITICAL | Critical |
| HIGH | High |
| MEDIUM | Medium |
| LOW | Low |

**Reference**: `src/backendng/src/main/kotlin/com/secman/domain/Vulnerability.kt:60`

---

## Decision 7: Days Open Calculation

**Decision**: Calculate `scan_timestamp` as `LocalDateTime.now().minusDays(daysOpen)`

**Rationale**:
- Matches existing Vulnerability entity structure
- `daysOpen` stored as text (e.g., "30 days") for display
- `scan_timestamp` enables accurate overdue calculations

**Reference**: `src/backendng/src/main/kotlin/com/secman/domain/Vulnerability.kt:69-70`

---

## Open Questions

None - all technical decisions resolved based on existing patterns.
