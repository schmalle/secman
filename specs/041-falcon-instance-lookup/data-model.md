# Data Model: AWS Instance ID Lookup

**Feature**: 041-falcon-instance-lookup
**Date**: 2025-11-03
**Status**: Complete

---

## Overview

This feature extends the existing CrowdStrike vulnerability query system to support AWS EC2 Instance ID lookups. **No new database entities are required** - the feature leverages existing entities and adds runtime data structures for API query handling.

---

## Existing Entities (No Changes)

### Asset

**Location**: `src/backendng/src/main/kotlin/com/secman/domain/Asset.kt`

**Relevant Fields**:
```kotlin
@Entity
@Table(name = "asset")
data class Asset(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long = 0,

    @Column(nullable = false, length = 255)
    val name: String,

    // Existing field - used to store AWS instance IDs
    @Column(name = "cloud_instance_id", length = 20)
    val cloudInstanceId: String? = null,

    @Column(name = "cloud_account_id", length = 12)
    val cloudAccountId: String? = null,

    // Other fields...
)
```

**Usage in Feature 041**:
- `cloudInstanceId`: Stores AWS EC2 instance ID when saving query results
- Format: `i-[0-9a-fA-F]{8,17}` (supports both legacy and current formats)
- No schema migration required - field already exists

**Validation Rules** (unchanged):
- Max length: 20 characters (accommodates `i-` + 17 hex chars)
- Nullable: Yes (not all assets are AWS instances)
- Unique: No (different assets could theoretically have same instance ID in different regions/accounts)

---

## New Runtime DTOs

### QueryType Enum

**Purpose**: Discriminate between hostname and instance ID queries for cache key generation

**Location**: `src/backendng/src/main/kotlin/com/secman/service/CrowdStrikeQueryService.kt` (new enum)

```kotlin
enum class QueryType {
    HOSTNAME,
    INSTANCE_ID
}
```

**Usage**:
- Method parameter to `queryVulnerabilities()`
- Cache key component (Micronaut default key generator uses all parameters)
- Routing logic to select appropriate API query method

---

### Crow

dStrikeQueryResponse (Enhanced)

**Location**: `src/backendng/src/main/kotlin/com/secman/dto/CrowdStrikeQueryResponse.kt`

**Existing Structure**:
```kotlin
data class CrowdStrikeQueryResponse(
    val hostname: String,
    val vulnerabilities: List<CrowdStrikeVulnerabilityDto>,
    val totalCount: Int,
    val queriedAt: LocalDateTime
)
```

**Enhanced Structure** (Feature 041):
```kotlin
data class CrowdStrikeQueryResponse(
    val hostname: String,
    val instanceId: String? = null,        // NEW: AWS instance ID
    val deviceCount: Int? = null,          // NEW: Number of systems found (for multi-device cases)
    val vulnerabilities: List<CrowdStrikeVulnerabilityDto>,
    val totalCount: Int,
    val queriedAt: LocalDateTime
)
```

**Field Descriptions**:
- `instanceId`: AWS EC2 instance ID (populated when querying by instance ID)
- `deviceCount`: Number of CrowdStrike devices found with this instance ID (typically 1, rarely 2+)
- Backward compatible: New fields are nullable with defaults

---

### CrowdStrikeVulnerabilityDto (Unchanged)

**Location**: `src/backendng/src/main/kotlin/com/secman/dto/CrowdStrikeVulnerabilityDto.kt`

```kotlin
data class CrowdStrikeVulnerabilityDto(
    val id: String,
    val hostname: String,
    val ip: String?,
    val cveId: String?,
    val severity: String,
    val cvssScore: Double?,
    val affectedProduct: String?,
    val daysOpen: String?,
    val detectedAt: String,
    val status: String,
    val hasException: Boolean,
    val exceptionReason: String?
)
```

**No changes required** - existing DTO handles both hostname and instance ID queries

---

## Cache Data Structure

### Cache Configuration

**Cache Name**: `vulnerability_queries`
**TTL**: 15 minutes (900 seconds)
**Max Size**: 1000 entries
**Eviction**: Time-based (LRU if size limit reached)

**Configuration Location**: `src/backendng/src/main/resources/application.yml`

```yaml
micronaut:
  caches:
    vulnerability_queries:
      maximum-size: 1000
      expire-after-write: 15m
```

### Cache Key Structure

**Generated by Micronaut's Default CacheKeyGenerator** (composite key from method parameters):

**Hostname Query**:
```
(queryValue="web-server-01", queryType=HOSTNAME, severity=null, product=null, limit=100)
```

**Instance ID Query**:
```
(queryValue="i-0048f94221fe110cf", queryType=INSTANCE_ID, severity=null, product=null, limit=100)
```

**Key Properties**:
- Collision-free: Different `queryType` values create distinct keys
- Case-normalized: Both `queryValue` and filters are lowercased before caching
- Consistent: Same parameters always generate same key

---

## CrowdStrike API Response Models

### Device Query Response

**Endpoint**: `/devices/queries/devices/v1`

**Response Model** (simplified):
```kotlin
data class DeviceIdsResponse(
    val resources: List<String>,  // Device IDs (AIDs)
    val meta: Meta
)

data class Meta(
    val query_time: Double,
    val pagination: Pagination?
)
```

### Device Details Response

**Endpoint**: `/devices/entities/devices/v1`

**Response Model** (simplified):
```kotlin
data class DeviceDetailsResponse(
    val resources: List<DeviceDetails>,
    val errors: List<Error>?
)

data class DeviceDetails(
    val device_id: String,        // Agent ID (AID)
    val hostname: String?,
    val instance_id: String?,     // AWS instance ID
    val service_provider: String?, // "AWS_EC2", "AZURE", "GCP"
    val service_provider_account_id: String?, // AWS account ID
    val external_ip: String?,
    val local_ip: String?,
    val platform_name: String?,
    val os_version: String?,
    val first_seen: String?,
    val last_seen: String?
)
```

**Mapping to Internal DTO**:
- `device_id` ‚Üí Used for vulnerability queries
- `hostname` ‚Üí Mapped to `CrowdStrikeQueryResponse.hostname`
- `instance_id` ‚Üí Mapped to `CrowdStrikeQueryResponse.instanceId`
- Other fields: Not used in this feature (available for future enhancements)

---

## Data Flow Diagram

```
User Input (Frontend)
      ‚Üì
Auto-Detection Logic (React Component)
      ‚Üì
  i-[0-9a-fA-F]{8,17}? ‚Üí Instance ID Query
      ‚Üì                          ‚Üì
Backend Controller        [Cache Check]
      ‚Üì                          ‚Üì
CrowdStrikeQueryService    [Cache Hit? Return]
      ‚Üì                          ‚Üì
QueryType.INSTANCE_ID      [Cache Miss]
      ‚Üì                          ‚Üì
CrowdStrikeApiClient.queryByInstanceId()
      ‚Üì
[CrowdStrike API Call 1]: Query devices by instance_id filter
      ‚Üì
[CrowdStrike API Call 2]: Get device details (hostname, etc.)
      ‚Üì
[CrowdStrike API Call 3]: Query vulnerabilities by device ID
      ‚Üì
Aggregate Results ‚Üí CrowdStrikeQueryResponse
      ‚Üì
[Cache Store] (15-min TTL)
      ‚Üì
Return to Frontend
      ‚Üì
Display in Results Table
```

---

## Validation Rules

### AWS Instance ID Validation

**Format**: `i-[0-9a-fA-F]{8,17}`

**Rules**:
1. **Prefix**: Must start with `i-` (lowercase)
2. **Character Set**: Hexadecimal only (0-9, a-f, A-F)
3. **Length**: Exactly 8 or 17 characters after prefix
4. **Case**: Case-insensitive validation (accept both cases)
5. **Normalization**: Store as lowercase

**Validation Locations**:
- Frontend: Pre-submission validation
- Backend Controller: Input validation
- Backend Service: Business logic validation

**Error Messages**:
- Invalid format: "Invalid instance ID format. Expected 'i-' followed by 8 or 17 hexadecimal characters (e.g., i-0048f94221fe110cf)"
- Empty input: "Please enter a hostname or instance ID"

---

## State Transitions

### Query State Machine

```
[IDLE]
  ‚Üí User enters input
[VALIDATING]
  ‚Üí Auto-detect query type
[VALIDATED]
  ‚Üí Check cache
[CACHE_CHECK]
  ‚Üí Hit: [DISPLAYING_CACHED]
  ‚Üí Miss: [QUERYING_API]
[QUERYING_API]
  ‚Üí Success: [CACHING] ‚Üí [DISPLAYING_FRESH]
  ‚Üí Error: [ERROR_STATE]
[DISPLAYING_CACHED]
  ‚Üí Show "üìã Cached (X min ago)" badge
[DISPLAYING_FRESH]
  ‚Üí Show "‚ö° Live data" badge
[ERROR_STATE]
  ‚Üí Display error message
  ‚Üí Return to [IDLE]
```

### Cache Freshness States

| State | Age | Badge | Behavior |
|-------|-----|-------|----------|
| **Fresh** | 0-1 min | ‚ö° Live data | Just fetched from API |
| **Cached** | 1-15 min | üìã Cached (X min ago) | Served from cache |
| **Stale** | >15 min | - | Cache expired, fetch from API |

---

## Database Indexes (Existing)

**No new indexes required** - existing indexes on Asset table sufficient:

```sql
-- Existing indexes
CREATE INDEX idx_asset_name ON asset(name);
CREATE INDEX idx_asset_cloud_account_id ON asset(cloud_account_id);

-- cloudInstanceId typically not indexed (low query frequency from DB)
-- Queries primarily via CrowdStrike API, not database
```

**Rationale**: Instance ID queries are API-first (not database queries), so database indexing is not a performance concern for this feature.

---

## Relationships

### Asset ‚Üê cloudInstanceId

**Type**: One-to-One (typically)
**Cardinality**: 1 Asset : 0..1 AWS Instance ID
**Direction**: Asset stores instance ID reference
**Constraints**: None (nullable, non-unique)

**Edge Cases**:
- Multiple assets with same instance ID: Allowed (different regions/accounts)
- Asset without instance ID: Common (non-AWS assets)
- Instance ID without asset: Valid during query (asset created on save)

---

## Data Consistency

### Save Operation Behavior

**When saving instance ID query results**:

1. **Lookup existing asset by hostname**:
   ```kotlin
   val existingAsset = assetRepository.findByName(hostname)
   ```

2. **If asset exists**:
   - Update `cloudInstanceId` field with new value
   - Merge/enrich existing asset (don't create duplicate)
   - Preserve other fields (owner, workgroups, etc.)

3. **If asset doesn't exist**:
   - Create new asset with hostname as name
   - Set `cloudInstanceId` to the queried instance ID
   - Set `scanUploader` to current user
   - Follow Feature 030 (CrowdStrike Asset Auto-Creation) patterns

**Pseudocode**:
```kotlin
fun saveQueryResults(queryResponse: CrowdStrikeQueryResponse, user: User): SaveResult {
    val hostname = queryResponse.hostname
    val instanceId = queryResponse.instanceId

    val asset = assetRepository.findByName(hostname).orElseGet {
        Asset(
            name = hostname,
            type = "SERVER",
            cloudInstanceId = instanceId,
            scanUploader = user
        )
    }

    // Enrich existing asset with instance ID
    if (asset.cloudInstanceId != instanceId) {
        asset.cloudInstanceId = instanceId
    }

    assetRepository.save(asset)

    // Save vulnerabilities...
}
```

---

## Summary

**Data Changes**: None (no schema changes, no new entities)

**Runtime Enhancements**:
- Added `QueryType` enum for type discrimination
- Enhanced `CrowdStrikeQueryResponse` with optional `instanceId` and `deviceCount` fields
- Cache key structure leverages Micronaut's default composite key generation

**Validation**:
- AWS instance ID format: `i-[0-9a-fA-F]{8,17}` (case-insensitive)
- Frontend and backend validation layers
- Clear error messages for invalid formats

**Database Usage**:
- Existing `Asset.cloudInstanceId` field stores AWS instance IDs
- No migrations required
- API-first design (queries don't hit database)

---

**Status**: ‚úÖ COMPLETE
**Schema Changes**: None
**Migration Required**: No
**Backward Compatibility**: ‚úÖ Full
