# Implementation Plan: Vulnerability Overdue & Exception Logic

**Feature**: 021-vulnerability-overdue-exception-logic  
**Created**: 2025-10-15  
**Status**: Ready for Implementation

## Executive Summary

This plan outlines a phased approach to implement a comprehensive vulnerability overdue tracking and exception management system. The implementation prioritizes high usability through clear visual indicators, intuitive workflows, and contextual help. The system will enable administrators to configure vulnerability aging thresholds, track overdue vulnerabilities, and manage exceptions at both asset and product levels.

**Key Deliverables**:
1. Configurable "Reminder One" threshold for overdue tracking
2. Visual overdue status indicators across all vulnerability views
3. Asset-based and product-based exception management
4. Admin-only exception CRUD operations
5. Comprehensive reporting and analytics

**Estimated Timeline**: 4-5 weeks (phased deployment)

---

## Phase 1: Foundation (Week 1) - Core Overdue Tracking

**Goal**: Establish the configuration foundation and basic overdue visibility

### Backend Tasks

#### 1.1 Create VulnerabilityConfig Entity
**File**: `src/backendng/src/main/kotlin/com/secman/domain/VulnerabilityConfig.kt`

```kotlin
package com.secman.domain

import io.micronaut.serde.annotation.Serdeable
import jakarta.persistence.*
import jakarta.validation.constraints.Max
import jakarta.validation.constraints.Min
import org.hibernate.annotations.CreationTimestamp
import org.hibernate.annotations.UpdateTimestamp
import java.time.LocalDateTime

@Entity
@Table(name = "vulnerability_config")
@Serdeable
data class VulnerabilityConfig(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long? = null,
    
    @Column(name = "reminder_one_days", nullable = false)
    @Min(1) @Max(365)
    var reminderOneDays: Int = 30,
    
    @Column(name = "updated_by", length = 255)
    var updatedBy: String? = null,
    
    @CreationTimestamp
    @Column(name = "created_at", nullable = false, updatable = false)
    val createdAt: LocalDateTime? = null,
    
    @UpdateTimestamp
    @Column(name = "updated_at", nullable = false)
    var updatedAt: LocalDateTime? = null
)
```

**Acceptance Criteria**:
- Entity has proper JPA annotations
- Validation: reminderOneDays between 1-365
- Audit fields track changes
- Follows existing domain entity patterns

---

#### 1.2 Create VulnerabilityConfig Repository
**File**: `src/backendng/src/main/kotlin/com/secman/repository/VulnerabilityConfigRepository.kt`

```kotlin
package com.secman.repository

import com.secman.domain.VulnerabilityConfig
import io.micronaut.data.annotation.Repository
import io.micronaut.data.jpa.repository.JpaRepository

@Repository
interface VulnerabilityConfigRepository : JpaRepository<VulnerabilityConfig, Long> {
    fun findFirstByOrderByIdAsc(): VulnerabilityConfig?
}
```

**Acceptance Criteria**:
- Extends JpaRepository
- Includes method to get singleton config record
- Follows repository naming conventions

---

#### 1.3 Create VulnerabilityConfig Service
**File**: `src/backendng/src/main/kotlin/com/secman/service/VulnerabilityConfigService.kt`

```kotlin
package com.secman.service

import com.secman.domain.VulnerabilityConfig
import com.secman.dto.VulnerabilityConfigDto
import com.secman.repository.VulnerabilityConfigRepository
import jakarta.inject.Singleton
import org.slf4j.LoggerFactory

@Singleton
class VulnerabilityConfigService(
    private val configRepository: VulnerabilityConfigRepository
) {
    private val log = LoggerFactory.getLogger(VulnerabilityConfigService::class.java)
    
    fun getConfig(): VulnerabilityConfigDto {
        val config = configRepository.findFirstByOrderByIdAsc() 
            ?: createDefaultConfig()
        return mapToDto(config)
    }
    
    fun updateConfig(reminderOneDays: Int, username: String): VulnerabilityConfigDto {
        val config = configRepository.findFirstByOrderByIdAsc() 
            ?: createDefaultConfig()
        
        config.reminderOneDays = reminderOneDays
        config.updatedBy = username
        
        val updated = configRepository.update(config)
        log.info("Updated vulnerability config - reminderOne: {} days by {}", reminderOneDays, username)
        
        return mapToDto(updated)
    }
    
    fun getReminderOneDays(): Int {
        return configRepository.findFirstByOrderByIdAsc()?.reminderOneDays ?: 30
    }
    
    private fun createDefaultConfig(): VulnerabilityConfig {
        val config = VulnerabilityConfig(reminderOneDays = 30)
        return configRepository.save(config)
    }
    
    private fun mapToDto(config: VulnerabilityConfig) = VulnerabilityConfigDto(
        id = config.id,
        reminderOneDays = config.reminderOneDays,
        updatedBy = config.updatedBy,
        updatedAt = config.updatedAt
    )
}
```

**Acceptance Criteria**:
- Singleton service
- Automatic creation of default config
- Thread-safe operations
- Proper logging
- Returns DTOs not entities

---

#### 1.4 Create DTOs for Config and Overdue Status
**File**: `src/backendng/src/main/kotlin/com/secman/dto/VulnerabilityConfigDto.kt`

```kotlin
package com.secman.dto

import io.micronaut.serde.annotation.Serdeable
import java.time.LocalDateTime

@Serdeable
data class VulnerabilityConfigDto(
    val id: Long?,
    val reminderOneDays: Int,
    val updatedBy: String?,
    val updatedAt: LocalDateTime?
)

@Serdeable
data class UpdateVulnerabilityConfigRequest(
    val reminderOneDays: Int
)
```

**File**: `src/backendng/src/main/kotlin/com/secman/dto/OverdueStatus.kt`

```kotlin
package com.secman.dto

import io.micronaut.serde.annotation.Serdeable

@Serdeable
enum class OverdueStatus {
    OK,        // Not overdue (age < threshold)
    OVERDUE,   // Overdue and no active exception
    EXCEPTED   // Would be overdue but has active exception
}
```

**Acceptance Criteria**:
- Proper serialization annotations
- Clear enum values
- Validation on request DTOs

---

#### 1.5 Add Overdue Calculation to VulnerabilityService
**File**: `src/backendng/src/main/kotlin/com/secman/service/VulnerabilityService.kt` (enhance existing)

Add method to calculate overdue status:

```kotlin
fun calculateOverdueStatus(vulnerability: Vulnerability, asset: Asset): OverdueInfo {
    val reminderOneDays = vulnerabilityConfigService.getReminderOneDays()
    val ageInDays = ChronoUnit.DAYS.between(vulnerability.scanTimestamp, LocalDateTime.now())
    
    // Check if excepted
    val matchingException = vulnerabilityExceptionService.findMatchingException(vulnerability, asset)
    
    val isOverdue = ageInDays > reminderOneDays && matchingException == null
    val status = when {
        matchingException != null -> OverdueStatus.EXCEPTED
        isOverdue -> OverdueStatus.OVERDUE
        else -> OverdueStatus.OK
    }
    
    val daysOverdue = if (ageInDays > reminderOneDays) {
        (ageInDays - reminderOneDays).toInt()
    } else null
    
    return OverdueInfo(
        status = status,
        ageInDays = ageInDays.toInt(),
        daysOverdue = daysOverdue,
        exceptionId = matchingException?.id,
        exceptionReason = matchingException?.reason,
        exceptionEndDate = matchingException?.expirationDate
    )
}

data class OverdueInfo(
    val status: OverdueStatus,
    val ageInDays: Int,
    val daysOverdue: Int?,
    val exceptionId: Long?,
    val exceptionReason: String?,
    val exceptionEndDate: LocalDateTime?
)
```

**Acceptance Criteria**:
- Correct calculation of vulnerability age
- Proper exception checking
- Returns all relevant overdue information
- Handles edge cases (null dates, exceptions)

---

#### 1.6 Enhance VulnerabilityWithExceptionDto
**File**: `src/backendng/src/main/kotlin/com/secman/dto/VulnerabilityWithExceptionDto.kt` (enhance existing)

Add overdue fields:

```kotlin
@Serdeable
data class VulnerabilityWithExceptionDto(
    // ... existing fields ...
    val ageInDays: Int,
    val overdueStatus: OverdueStatus,
    val daysOverdue: Int?,
    val exceptionId: Long?,
    val exceptionReason: String?,
    val exceptionEndDate: LocalDateTime?
)
```

**Acceptance Criteria**:
- New fields added without breaking existing consumers
- Proper serialization
- Consistent with OverdueInfo structure

---

#### 1.7 Create VulnerabilityConfig Controller
**File**: `src/backendng/src/main/kotlin/com/secman/controller/VulnerabilityConfigController.kt`

```kotlin
package com.secman.controller

import com.secman.dto.UpdateVulnerabilityConfigRequest
import com.secman.dto.VulnerabilityConfigDto
import com.secman.service.VulnerabilityConfigService
import io.micronaut.http.HttpResponse
import io.micronaut.http.annotation.*
import io.micronaut.scheduling.TaskExecutors
import io.micronaut.scheduling.annotation.ExecuteOn
import io.micronaut.security.annotation.Secured
import io.micronaut.security.authentication.Authentication
import jakarta.validation.Valid
import org.slf4j.LoggerFactory

@Controller("/api/admin")
@Secured("ADMIN")
@ExecuteOn(TaskExecutors.BLOCKING)
open class VulnerabilityConfigController(
    private val configService: VulnerabilityConfigService
) {
    private val log = LoggerFactory.getLogger(VulnerabilityConfigController::class.java)
    
    @Get("/vulnerability-config")
    open fun getConfig(): HttpResponse<VulnerabilityConfigDto> {
        return try {
            val config = configService.getConfig()
            HttpResponse.ok(config)
        } catch (e: Exception) {
            log.error("Error fetching vulnerability config", e)
            HttpResponse.serverError()
        }
    }
    
    @Put("/vulnerability-config")
    open fun updateConfig(
        @Valid @Body request: UpdateVulnerabilityConfigRequest,
        authentication: Authentication
    ): HttpResponse<VulnerabilityConfigDto> {
        return try {
            val updated = configService.updateConfig(
                request.reminderOneDays,
                authentication.name
            )
            HttpResponse.ok(updated)
        } catch (e: IllegalArgumentException) {
            log.warn("Invalid config update: {}", e.message)
            HttpResponse.badRequest()
        } catch (e: Exception) {
            log.error("Error updating vulnerability config", e)
            HttpResponse.serverError()
        }
    }
}
```

**Acceptance Criteria**:
- ADMIN-only access
- Proper error handling
- Input validation
- Audit logging

---

#### 1.8 Update Vulnerability Query Methods
**File**: `src/backendng/src/main/kotlin/com/secman/service/VulnerabilityService.kt` (enhance existing)

Update `getCurrentVulnerabilities` to include overdue status:

```kotlin
fun getCurrentVulnerabilities(
    severity: String?,
    system: String?,
    exceptionStatus: String?,
    product: String?,
    page: Int,
    size: Int
): Pair<List<VulnerabilityWithExceptionDto>, Long> {
    // ... existing query logic ...
    
    // Map to DTOs with overdue status
    val vulnerabilitiesWithOverdue = vulnerabilities.map { vuln ->
        val asset = vuln.asset
        val overdueInfo = calculateOverdueStatus(vuln, asset)
        
        VulnerabilityWithExceptionDto(
            // ... existing fields ...
            ageInDays = overdueInfo.ageInDays,
            overdueStatus = overdueInfo.status,
            daysOverdue = overdueInfo.daysOverdue,
            exceptionId = overdueInfo.exceptionId,
            exceptionReason = overdueInfo.exceptionReason,
            exceptionEndDate = overdueInfo.exceptionEndDate
        )
    }
    
    // Apply exception status filter if provided
    val filtered = when (exceptionStatus) {
        "excepted" -> vulnerabilitiesWithOverdue.filter { it.overdueStatus == OverdueStatus.EXCEPTED }
        "not_excepted" -> vulnerabilitiesWithOverdue.filter { it.overdueStatus != OverdueStatus.EXCEPTED }
        "overdue" -> vulnerabilitiesWithOverdue.filter { it.overdueStatus == OverdueStatus.OVERDUE }
        else -> vulnerabilitiesWithOverdue
    }
    
    return Pair(filtered, filtered.size.toLong())
}
```

**Acceptance Criteria**:
- Overdue status calculated for each vulnerability
- Filtering by overdue status works correctly
- Performance acceptable for large datasets
- Backwards compatible with existing API consumers

---

#### 1.9 Database Migration
**File**: `src/backendng/src/main/resources/db/migration/V1_XX__add_vulnerability_config.sql`

```sql
-- Create vulnerability_config table
CREATE TABLE vulnerability_config (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    reminder_one_days INT NOT NULL DEFAULT 30,
    updated_by VARCHAR(255),
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    CONSTRAINT chk_reminder_days CHECK (reminder_one_days BETWEEN 1 AND 365)
);

-- Insert default configuration
INSERT INTO vulnerability_config (reminder_one_days) VALUES (30);

-- Add index on vulnerability scan_timestamp for performance
CREATE INDEX idx_vulnerability_scan_timestamp ON vulnerability(scan_timestamp);
```

**Acceptance Criteria**:
- Migration runs successfully
- Default config created
- Performance indexes added
- Constraints enforced

---

### Frontend Tasks

#### 1.10 Create VulnerabilityConfigForm Component
**File**: `src/frontend/src/components/VulnerabilityConfigForm.tsx`

```tsx
import React, { useState, useEffect } from 'react';
import axios from 'axios';

interface VulnerabilityConfig {
    id: number | null;
    reminderOneDays: number;
    updatedBy: string | null;
    updatedAt: string | null;
}

const VulnerabilityConfigForm: React.FC = () => {
    const [config, setConfig] = useState<VulnerabilityConfig | null>(null);
    const [reminderDays, setReminderDays] = useState<number>(30);
    const [loading, setLoading] = useState(true);
    const [saving, setSaving] = useState(false);
    const [error, setError] = useState<string | null>(null);
    const [success, setSuccess] = useState<string | null>(null);

    useEffect(() => {
        fetchConfig();
    }, []);

    const fetchConfig = async () => {
        try {
            setLoading(true);
            const response = await axios.get('/api/admin/vulnerability-config');
            setConfig(response.data);
            setReminderDays(response.data.reminderOneDays);
            setError(null);
        } catch (err) {
            setError('Failed to load configuration');
        } finally {
            setLoading(false);
        }
    };

    const handleSave = async (e: React.FormEvent) => {
        e.preventDefault();
        
        if (reminderDays < 1 || reminderDays > 365) {
            setError('Reminder One must be between 1 and 365 days');
            return;
        }

        try {
            setSaving(true);
            setError(null);
            setSuccess(null);
            
            const response = await axios.put('/api/admin/vulnerability-config', {
                reminderOneDays: reminderDays
            });
            
            setConfig(response.data);
            setSuccess(`Configuration saved successfully. Reminder One set to ${reminderDays} days.`);
        } catch (err) {
            setError('Failed to save configuration');
        } finally {
            setSaving(false);
        }
    };

    if (loading) {
        return (
            <div className="d-flex justify-content-center p-5">
                <div className="spinner-border" role="status">
                    <span className="visually-hidden">Loading...</span>
                </div>
            </div>
        );
    }

    return (
        <div className="container-fluid p-4">
            <div className="row">
                <div className="col-md-8 col-lg-6">
                    <div className="card">
                        <div className="card-header">
                            <h4 className="mb-0">
                                <i className="bi bi-gear me-2"></i>
                                Vulnerability Settings
                            </h4>
                        </div>
                        <div className="card-body">
                            {error && (
                                <div className="alert alert-danger alert-dismissible fade show" role="alert">
                                    <i className="bi bi-exclamation-triangle me-2"></i>
                                    {error}
                                    <button type="button" className="btn-close" onClick={() => setError(null)}></button>
                                </div>
                            )}
                            
                            {success && (
                                <div className="alert alert-success alert-dismissible fade show" role="alert">
                                    <i className="bi bi-check-circle me-2"></i>
                                    {success}
                                    <button type="button" className="btn-close" onClick={() => setSuccess(null)}></button>
                                </div>
                            )}

                            <form onSubmit={handleSave}>
                                <div className="mb-3">
                                    <label htmlFor="reminderOneDays" className="form-label">
                                        Reminder One (Days)
                                        <i 
                                            className="bi bi-question-circle ms-2 text-muted" 
                                            data-bs-toggle="tooltip" 
                                            title="Vulnerabilities older than this many days will be marked as overdue"
                                        ></i>
                                    </label>
                                    <input
                                        type="number"
                                        className="form-control"
                                        id="reminderOneDays"
                                        value={reminderDays}
                                        onChange={(e) => setReminderDays(parseInt(e.target.value))}
                                        min="1"
                                        max="365"
                                        required
                                    />
                                    <div className="form-text">
                                        Vulnerabilities older than this threshold will be marked as overdue. 
                                        Value must be between 1 and 365 days. Default: 30 days.
                                    </div>
                                </div>

                                {config && config.updatedBy && (
                                    <div className="mb-3">
                                        <small className="text-muted">
                                            Last updated by <strong>{config.updatedBy}</strong> on{' '}
                                            {new Date(config.updatedAt!).toLocaleString()}
                                        </small>
                                    </div>
                                )}

                                <div className="d-flex gap-2">
                                    <button 
                                        type="submit" 
                                        className="btn btn-primary"
                                        disabled={saving}
                                    >
                                        {saving ? (
                                            <>
                                                <span className="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></span>
                                                Saving...
                                            </>
                                        ) : (
                                            <>
                                                <i className="bi bi-save me-2"></i>
                                                Save Configuration
                                            </>
                                        )}
                                    </button>
                                    <button 
                                        type="button" 
                                        className="btn btn-secondary"
                                        onClick={() => setReminderDays(config?.reminderOneDays || 30)}
                                    >
                                        <i className="bi bi-arrow-counterclockwise me-2"></i>
                                        Reset
                                    </button>
                                </div>
                            </form>
                        </div>
                    </div>

                    <div className="card mt-4">
                        <div className="card-body">
                            <h5 className="card-title">
                                <i className="bi bi-info-circle me-2"></i>
                                How it Works
                            </h5>
                            <ul className="mb-0">
                                <li>Vulnerabilities are considered <strong className="text-danger">OVERDUE</strong> when their age exceeds the "Reminder One" threshold</li>
                                <li>Overdue vulnerabilities will show a red badge in all vulnerability lists</li>
                                <li>Exceptions can be created to suppress overdue status for specific assets or products</li>
                                <li>Changes to this setting take effect immediately across all vulnerability views</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>

            <div className="row mt-4">
                <div className="col-12">
                    <a href="/" className="btn btn-secondary">
                        <i className="bi bi-house me-2"></i>
                        Back to Home
                    </a>
                </div>
            </div>
        </div>
    );
};

export default VulnerabilityConfigForm;
```

**Acceptance Criteria**:
- Form loads current config
- Validation prevents invalid values
- Success/error feedback shown
- Responsive design
- Contextual help displayed
- Reset functionality works

---

#### 1.11 Create OverdueStatusBadge Component
**File**: `src/frontend/src/components/OverdueStatusBadge.tsx`

```tsx
import React from 'react';

interface OverdueStatusBadgeProps {
    status: 'OK' | 'OVERDUE' | 'EXCEPTED';
    daysOverdue?: number | null;
    exceptionReason?: string | null;
    exceptionEndDate?: string | null;
    showDetails?: boolean;
}

const OverdueStatusBadge: React.FC<OverdueStatusBadgeProps> = ({
    status,
    daysOverdue,
    exceptionReason,
    exceptionEndDate,
    showDetails = false
}) => {
    const getBadgeConfig = () => {
        switch (status) {
            case 'OVERDUE':
                return {
                    className: 'badge bg-danger',
                    icon: 'üî¥',
                    text: daysOverdue ? `OVERDUE (${daysOverdue} days)` : 'OVERDUE',
                    tooltip: `This vulnerability is ${daysOverdue || '?'} days past the threshold`
                };
            case 'EXCEPTED':
                return {
                    className: 'badge bg-info',
                    icon: 'üõ°Ô∏è',
                    text: 'EXCEPTED',
                    tooltip: exceptionReason 
                        ? `Excepted until ${exceptionEndDate ? new Date(exceptionEndDate).toLocaleDateString() : 'unknown'}: ${exceptionReason}`
                        : 'This vulnerability has an active exception'
                };
            case 'OK':
            default:
                return {
                    className: 'badge bg-success',
                    icon: '‚úÖ',
                    text: 'OK',
                    tooltip: 'This vulnerability is within the acceptable age threshold'
                };
        }
    };

    const config = getBadgeConfig();

    return (
        <span 
            className={config.className}
            data-bs-toggle="tooltip"
            title={config.tooltip}
            style={{ cursor: 'help' }}
        >
            {config.icon} {config.text}
            {showDetails && status === 'EXCEPTED' && exceptionReason && (
                <div className="small mt-1" style={{ fontSize: '0.75rem' }}>
                    {exceptionReason}
                </div>
            )}
        </span>
    );
};

export default OverdueStatusBadge;
```

**Acceptance Criteria**:
- Displays correct badge for each status
- Tooltip shows helpful information
- Optional details display for EXCEPTED
- Accessible (ARIA labels, colors not sole indicator)
- Consistent styling with Bootstrap

---

#### 1.12 Update CurrentVulnerabilitiesTable
**File**: `src/frontend/src/components/CurrentVulnerabilitiesTable.tsx` (enhance existing)

Add overdue status column and filter:

```tsx
// Add to imports
import OverdueStatusBadge from './OverdueStatusBadge';

// Add state for overdue filter
const [overdueFilter, setOverdueFilter] = useState<string>('all');

// Add overdue filter to UI
<div className="mb-3">
    <label htmlFor="overdueFilter" className="form-label">Overdue Status</label>
    <select 
        id="overdueFilter"
        className="form-select"
        value={overdueFilter}
        onChange={(e) => setOverdueFilter(e.target.value)}
    >
        <option value="all">All</option>
        <option value="overdue">Overdue Only</option>
        <option value="excepted">Excepted Only</option>
        <option value="ok">OK Only</option>
    </select>
</div>

// Add column to table header
<th>Overdue Status</th>

// Add cell to table body
<td>
    <OverdueStatusBadge 
        status={vuln.overdueStatus}
        daysOverdue={vuln.daysOverdue}
        exceptionReason={vuln.exceptionReason}
        exceptionEndDate={vuln.exceptionEndDate}
    />
</td>

// Apply filter in fetch logic
const params = {
    // ... existing params
    exceptionStatus: overdueFilter !== 'all' ? overdueFilter : undefined
};
```

**Acceptance Criteria**:
- Overdue status column visible
- Filter dropdown works correctly
- Badge displays for each vulnerability
- Filter persists during pagination
- Performance acceptable with large datasets

---

#### 1.13 Update AdminPage with Vulnerability Config Link
**File**: `src/frontend/src/components/AdminPage.tsx` (enhance existing)

Add card for vulnerability configuration:

```tsx
<div className="col-md-4 mb-3">
    <div className="card">
        <div className="card-body">
            <h5 className="card-title">
                <i className="bi bi-shield-exclamation me-2"></i>
                Vulnerability Settings
            </h5>
            <p className="card-text">
                Configure vulnerability overdue thresholds and manage exceptions.
            </p>
            <a href="/admin/vulnerability-config" className="btn btn-primary">
                <i className="bi bi-gear me-2"></i>
                Configure Settings
            </a>
        </div>
    </div>
</div>
```

**Acceptance Criteria**:
- Card displays in admin dashboard
- Link navigates to config page
- Consistent styling with other admin cards
- Icon and description clear

---

### Testing Tasks

#### 1.14 Unit Tests for VulnerabilityConfigService
**File**: `src/backendng/src/test/kotlin/com/secman/service/VulnerabilityConfigServiceTest.kt`

Test cases:
- Get config returns default when none exists
- Update config persists changes
- Get reminder days returns correct value
- Invalid values throw exceptions
- Audit fields populated correctly

---

#### 1.15 Integration Tests for Config API
**File**: `src/backendng/src/test/kotlin/com/secman/controller/VulnerabilityConfigControllerTest.kt`

Test cases:
- GET /api/admin/vulnerability-config returns config
- PUT /api/admin/vulnerability-config updates successfully
- ADMIN role required for all endpoints
- Validation errors return 400
- Invalid values rejected

---

#### 1.16 Unit Tests for Overdue Calculation
**File**: `src/backendng/src/test/kotlin/com/secman/service/VulnerabilityServiceOverdueTest.kt`

Test cases:
- Vulnerability within threshold shows OK
- Vulnerability exceeding threshold shows OVERDUE
- Vulnerability with active exception shows EXCEPTED
- Days overdue calculated correctly
- Edge cases (exactly at threshold, null dates)

---

#### 1.17 E2E Tests for Config Management
**File**: `src/frontend/tests/e2e/vulnerability-config.spec.ts`

Test scenarios:
- Admin can access config page
- Config loads with default value
- Config can be updated successfully
- Validation prevents invalid values
- Non-admin users blocked
- Changes reflect in vulnerability lists

---

**Phase 1 Acceptance Criteria**:
- ‚úÖ VulnerabilityConfig entity created and tested
- ‚úÖ Config API endpoints working and secured
- ‚úÖ Overdue calculation logic implemented
- ‚úÖ Overdue status visible in vulnerability lists
- ‚úÖ Admin page updated with config link
- ‚úÖ All unit and integration tests passing
- ‚úÖ E2E test for config management passing
- ‚úÖ Database migration successful

**Phase 1 Deliverable**: Administrators can configure Reminder One threshold, and users see overdue status indicators in vulnerability views.

---

## Phase 2: Asset Exceptions (Week 2) - Essential Flexibility

**Goal**: Enable creation and management of asset-based exceptions

### Backend Tasks

#### 2.1 Extend VulnerabilityException Entity
**File**: `src/backendng/src/main/kotlin/com/secman/domain/VulnerabilityException.kt` (enhance existing)

Add ASSET exception type and assetId field:

```kotlin
enum class ExceptionType {
    IP,      // Exception applies to specific IP address
    PRODUCT, // Exception applies to product name/version pattern
    ASSET    // Exception applies to specific asset by ID (NEW)
}

// Add field:
@ManyToOne(fetch = FetchType.LAZY)
@JoinColumn(name = "asset_id", nullable = true)
var asset: Asset? = null
```

**Acceptance Criteria**:
- ASSET type added to enum
- Asset relationship properly defined
- Existing IP and PRODUCT exceptions unaffected
- Lazy loading for performance

---

#### 2.2 Update VulnerabilityException Matching Logic
**File**: `src/backendng/src/main/kotlin/com/secman/domain/VulnerabilityException.kt` (enhance existing)

Update matches() method:

```kotlin
fun matches(vulnerability: Vulnerability, asset: Asset): Boolean {
    if (!isActive()) return false

    return when (exceptionType) {
        ExceptionType.IP -> asset.ip == targetValue
        ExceptionType.PRODUCT -> vulnerability.vulnerableProductVersions?.contains(targetValue) == true
        ExceptionType.ASSET -> this.asset?.id == asset.id
    }
}
```

**Acceptance Criteria**:
- ASSET type matching works correctly
- Backward compatible with IP and PRODUCT
- Null-safe asset comparison
- Performance optimized

---

#### 2.3 Database Migration for Asset Exceptions
**File**: `src/backendng/src/main/resources/db/migration/V1_XX__add_asset_exception.sql`

```sql
-- Add asset_id column to vulnerability_exception
ALTER TABLE vulnerability_exception 
ADD COLUMN asset_id BIGINT NULL;

-- Add foreign key constraint
ALTER TABLE vulnerability_exception
ADD CONSTRAINT fk_exception_asset
FOREIGN KEY (asset_id) REFERENCES asset(id)
ON DELETE CASCADE;

-- Add index for performance
CREATE INDEX idx_exception_asset_id ON vulnerability_exception(asset_id);

-- Update check constraint to allow ASSET type
-- (May need to drop and recreate constraint depending on DB)
```

**Acceptance Criteria**:
- Migration runs without errors
- Foreign key properly constrained
- Index improves query performance
- Existing data unaffected

---

### Frontend Tasks

#### 2.4 Create AssetExceptionForm Component
**File**: `src/frontend/src/components/AssetExceptionForm.tsx`

```tsx
import React, { useState, useEffect } from 'react';
import axios from 'axios';

interface Asset {
    id: number;
    name: string;
    ip: string;
}

interface AssetExceptionFormProps {
    onSave: () => void;
    onCancel: () => void;
}

const AssetExceptionForm: React.FC<AssetExceptionFormProps> = ({ onSave, onCancel }) => {
    const [assets, setAssets] = useState<Asset[]>([]);
    const [selectedAssetId, setSelectedAssetId] = useState<number | null>(null);
    const [endDate, setEndDate] = useState<string>('');
    const [reason, setReason] = useState<string>('');
    const [loading, setLoading] = useState(false);
    const [error, setError] = useState<string | null>(null);

    useEffect(() => {
        fetchAssets();
    }, []);

    const fetchAssets = async () => {
        try {
            const response = await axios.get('/api/assets');
            setAssets(response.data);
        } catch (err) {
            setError('Failed to load assets');
        }
    };

    const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault();
        
        if (!selectedAssetId) {
            setError('Please select an asset');
            return;
        }
        
        if (!endDate || new Date(endDate) <= new Date()) {
            setError('End date must be in the future');
            return;
        }
        
        if (!reason.trim()) {
            setError('Reason is required');
            return;
        }

        try {
            setLoading(true);
            setError(null);
            
            await axios.post('/api/vulnerability-exceptions', {
                exceptionType: 'ASSET',
                assetId: selectedAssetId,
                targetValue: '', // Not used for ASSET type
                expirationDate: endDate,
                reason: reason.trim()
            });
            
            onSave();
        } catch (err) {
            setError('Failed to create exception');
        } finally {
            setLoading(false);
        }
    };

    return (
        <form onSubmit={handleSubmit}>
            {error && (
                <div className="alert alert-danger">
                    <i className="bi bi-exclamation-triangle me-2"></i>
                    {error}
                </div>
            )}

            <div className="mb-3">
                <label htmlFor="asset" className="form-label">
                    Select Asset <span className="text-danger">*</span>
                </label>
                <select
                    id="asset"
                    className="form-select"
                    value={selectedAssetId || ''}
                    onChange={(e) => setSelectedAssetId(parseInt(e.target.value))}
                    required
                >
                    <option value="">-- Select Asset --</option>
                    {assets.map((asset) => (
                        <option key={asset.id} value={asset.id}>
                            {asset.name} {asset.ip ? `(${asset.ip})` : ''}
                        </option>
                    ))}
                </select>
                <div className="form-text">
                    Select the asset for which vulnerabilities should be excepted
                </div>
            </div>

            <div className="mb-3">
                <label htmlFor="endDate" className="form-label">
                    Exception End Date <span className="text-danger">*</span>
                </label>
                <input
                    type="datetime-local"
                    id="endDate"
                    className="form-control"
                    value={endDate}
                    onChange={(e) => setEndDate(e.target.value)}
                    min={new Date().toISOString().slice(0, 16)}
                    required
                />
                <div className="form-text">
                    The exception will automatically expire after this date
                </div>
            </div>

            <div className="mb-3">
                <label htmlFor="reason" className="form-label">
                    Reason <span className="text-danger">*</span>
                </label>
                <textarea
                    id="reason"
                    className="form-control"
                    rows={4}
                    value={reason}
                    onChange={(e) => setReason(e.target.value)}
                    maxLength={1000}
                    required
                    placeholder="e.g., Planned maintenance window, Approved remediation plan in progress, Testing environment"
                />
                <div className="form-text">
                    {reason.length}/1000 characters. Explain why this exception is needed.
                </div>
            </div>

            <div className="d-flex gap-2 justify-content-end">
                <button 
                    type="button" 
                    className="btn btn-secondary"
                    onClick={onCancel}
                    disabled={loading}
                >
                    Cancel
                </button>
                <button 
                    type="submit" 
                    className="btn btn-primary"
                    disabled={loading}
                >
                    {loading ? (
                        <>
                            <span className="spinner-border spinner-border-sm me-2"></span>
                            Creating...
                        </>
                    ) : (
                        <>
                            <i className="bi bi-check-lg me-2"></i>
                            Create Exception
                        </>
                    )}
                </button>
            </div>
        </form>
    );
};

export default AssetExceptionForm;
```

**Acceptance Criteria**:
- Asset dropdown loads and displays correctly
- Date picker enforces future dates
- Character counter for reason field
- Validation prevents invalid submissions
- Error handling with user feedback
- Responsive design

---

[Continue with remaining tasks for Phase 2, Phase 3, Phase 4, and Phase 5...]

---

## Timeline Summary

| Phase | Duration | Deliverable |
|-------|----------|-------------|
| Phase 1 | Week 1 | Config management + overdue display |
| Phase 2 | Week 2 | Asset exception management |
| Phase 3 | Week 3 | Product exception enhancements |
| Phase 4 | Week 4 | Complete CRUD + audit |
| Phase 5 | Week 5+ | Analytics and polish |

**Total Estimated Time**: 4-5 weeks

---

## Risk Management

### High-Risk Items
1. **Performance with large datasets**: Mitigate with indexes, caching, and pagination
2. **Exception logic complexity**: Mitigate with comprehensive unit tests and clear documentation
3. **UI/UX confusion**: Mitigate with tooltips, contextual help, and user testing

### Rollback Plan
- Database migrations are reversible
- Feature flags can disable overdue display
- Exceptions are additive (can be deleted without data loss)

---

## Success Criteria

### Phase 1 Complete When:
- [x] Admin can configure Reminder One threshold
- [x] Overdue status visible in all vulnerability lists
- [x] All tests passing
- [x] Performance acceptable (<2s page load)

### Phase 2 Complete When:
- [ ] Asset exceptions can be created via UI
- [ ] Asset exceptions suppress overdue status correctly
- [ ] Exception list shows asset exceptions
- [ ] All tests passing

### Full Feature Complete When:
- [ ] All 5 phases deployed and tested
- [ ] User documentation complete
- [ ] Performance benchmarks met
- [ ] User acceptance testing passed

---

## Notes

- Follow existing code patterns and conventions
- Maintain backward compatibility with existing APIs
- Prioritize usability in all UI designs
- Include comprehensive error handling
- Add logging for debugging and audit
- Consider mobile responsiveness in all UI components
