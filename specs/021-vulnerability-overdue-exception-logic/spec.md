# Feature Specification: Vulnerability Overdue & Exception Logic

**Feature Branch**: `021-vulnerability-overdue-exception-logic`
**Created**: 2025-10-15
**Status**: Implementation Planning
**Input**: User request for complex exception logic with "Reminder One" configuration and asset/product-based exceptions

## Overview

Implement a comprehensive overdue tracking and exception management system for vulnerabilities. The system introduces a configurable "Reminder One" threshold (default: 30 days) that marks vulnerabilities as overdue. Exceptions can be created at both asset and product levels to suppress overdue status during defined time periods.

### Key Requirements

1. **Global Reminder Configuration**: Admin-configurable "Reminder One" threshold (default: 30 days)
2. **Overdue Status**: Vulnerabilities older than "Reminder One" days are marked as overdue
3. **Asset-Based Exceptions**: Exceptions can be applied to specific assets (by IP or asset ID)
4. **Product-Based Exceptions**: Exceptions can be applied to vulnerability products/versions
5. **Time-Bound Exceptions**: All exceptions require an end date
6. **Admin-Only Access**: Exception management restricted to ADMIN role
7. **UI Integration**: Overdue status visible in all vulnerability views
8. **CRUD Operations**: Full create, read, update, delete for exceptions

## User Scenarios & Testing *(mandatory)*

### User Story 1 - Configure Global Reminder One Setting (Priority: P1)

An administrator needs to configure the global "Reminder One" threshold that determines when vulnerabilities become overdue. This setting controls the organization's vulnerability management SLA.

**Why this priority**: Foundation for the entire overdue tracking system. Without this configuration, no vulnerabilities can be marked as overdue. This is the first setting administrators need to establish.

**Independent Test**: Can be tested by navigating to admin settings, setting "Reminder One" to 30 days, saving, and verifying the value persists across sessions. Delivers immediate value by establishing the organization's vulnerability aging policy.

**Acceptance Scenarios**:

1. **Given** an administrator is on the admin settings page, **When** they navigate to "Vulnerability Settings", **Then** they see a "Reminder One" input field with a default value of 30 days.
2. **Given** an administrator sets "Reminder One" to 45 days, **When** they save the settings, **Then** the value is persisted and used for all overdue calculations.
3. **Given** an administrator enters an invalid value (e.g., negative number or non-numeric), **When** they attempt to save, **Then** validation fails with a clear error message.
4. **Given** "Reminder One" is set to 30 days, **When** the system evaluates vulnerabilities, **Then** vulnerabilities with age > 30 days are marked as overdue.
5. **Given** the system has no "Reminder One" configuration, **When** it is first initialized, **Then** the default value of 30 days is automatically created.

**Technical Notes**:
- Store in a new `VulnerabilityConfig` entity similar to `EmailConfig`, `FalconConfig`
- Single record in database (singleton pattern)
- Include audit fields: `createdAt`, `updatedAt`, `updatedBy`

---

### User Story 2 - View Overdue Status in Vulnerability Lists (Priority: P1)

Users need to see which vulnerabilities are overdue in all vulnerability management views. The overdue status helps prioritize remediation efforts and track SLA compliance.

**Why this priority**: Core visibility requirement. Users must be able to identify overdue vulnerabilities at a glance. This directly supports the primary use case of vulnerability management and prioritization.

**Independent Test**: Can be tested by creating vulnerabilities with different ages and verifying the overdue indicator appears for those exceeding the "Reminder One" threshold. Works independently once the configuration is in place.

**Acceptance Scenarios**:

1. **Given** "Reminder One" is set to 30 days and a vulnerability is 45 days old with no exception, **When** viewing the vulnerability list, **Then** the vulnerability shows an "OVERDUE" badge or indicator.
2. **Given** "Reminder One" is set to 30 days and a vulnerability is 20 days old, **When** viewing the vulnerability list, **Then** the vulnerability does NOT show an overdue indicator.
3. **Given** a vulnerability is overdue but has an active asset exception, **When** viewing the vulnerability list, **Then** the vulnerability does NOT show an overdue indicator and displays "EXCEPTED" status.
4. **Given** a vulnerability is overdue but has an active product exception, **When** viewing the vulnerability list, **Then** the vulnerability does NOT show an overdue indicator and displays "EXCEPTED" status.
5. **Given** a vulnerability had an exception that has now expired, **When** the exception end date passes, **Then** the vulnerability becomes overdue (if it meets the age criteria).

**UI Requirements**:
- Add "Overdue Status" column to vulnerability tables
- Show visual indicator: üî¥ OVERDUE badge (red), ‚úÖ OK (green), üõ°Ô∏è EXCEPTED (blue)
- Add filter option: "Show only overdue", "Show excepted", "Show all"
- Display days overdue: e.g., "OVERDUE (15 days past threshold)"

**Technical Notes**:
- Calculate on backend: `vulnerability.scanTimestamp + reminderOne < now() && !hasActiveException`
- Add to DTOs: `isOverdue: boolean`, `overdueStatus: enum`, `daysOverdue: number`
- Index vulnerability table on `scan_timestamp` for performance

---

### User Story 3 - Create Asset-Based Exceptions (Priority: P1)

An administrator needs to create exceptions for specific assets, preventing vulnerabilities on those assets from showing as overdue during maintenance windows, testing periods, or planned remediation cycles.

**Why this priority**: Critical for operational flexibility. Administrators need to temporarily suppress overdue alerts for assets undergoing maintenance or with approved remediation plans. This prevents alert fatigue and focuses attention on actionable items.

**Independent Test**: Can be tested by creating an asset exception for a specific IP/asset, creating overdue vulnerabilities on that asset, and verifying they don't show as overdue during the exception period.

**Acceptance Scenarios**:

1. **Given** an administrator is on the Exception Management page, **When** they click "Create Exception" and select "Asset Exception", **Then** they see a form with fields: Asset Selector (IP/Name), End Date, Reason.
2. **Given** an administrator creates an asset exception for IP "192.168.1.100" valid until "2025-12-31", **When** the exception is saved, **Then** all vulnerabilities on assets with that IP are marked as excepted.
3. **Given** an asset exception exists and covers multiple assets with the same IP, **When** viewing vulnerabilities for any of those assets, **Then** all show the excepted status.
4. **Given** an administrator tries to create an exception without an end date, **When** they submit the form, **Then** validation fails requiring an end date.
5. **Given** an asset exception expires (end date passes), **When** the system re-evaluates overdue status, **Then** vulnerabilities on that asset become overdue again (if they meet age criteria).
6. **Given** an administrator creates an exception with an end date in the past, **When** they submit, **Then** validation fails with a message that end date must be in the future.

**UI Requirements**:
- Modal form for exception creation
- Asset selector: dropdown or autocomplete search by IP, name, or asset ID
- Date picker for end date (required)
- Text area for reason (required, max 1000 characters)
- List existing asset exceptions with: Asset, End Date, Reason, Created By, Actions (Edit/Delete)

**Technical Notes**:
- Extend existing `VulnerabilityException` entity with new exception type: `ASSET`
- Add relationship to Asset entity or store asset ID directly
- Match logic: `exception.exceptionType == ASSET && exception.assetId == vulnerability.asset.id`

---

### User Story 4 - Create Product-Based Exceptions (Priority: P1)

An administrator needs to create exceptions for specific products/versions, preventing all vulnerabilities matching that product pattern from showing as overdue. This is useful for known issues awaiting vendor patches or organization-wide remediation campaigns.

**Why this priority**: Enables organization-wide exception management. When a vulnerability affects many assets but has a known mitigation timeline, administrators can create a single product exception instead of multiple asset exceptions.

**Independent Test**: Can be tested by creating a product exception (e.g., "OpenSSL 1.0.2"), creating vulnerabilities with that product on multiple assets, and verifying none show as overdue.

**Acceptance Scenarios**:

1. **Given** an administrator is on the Exception Management page, **When** they click "Create Exception" and select "Product Exception", **Then** they see a form with fields: Product Pattern (text), End Date, Reason.
2. **Given** an administrator creates a product exception for "OpenSSL 1.0.2" valid until "2025-12-31", **When** the exception is saved, **Then** all vulnerabilities with "OpenSSL 1.0.2" in their product field are marked as excepted.
3. **Given** a product exception exists for "OpenSSL", **When** vulnerabilities are evaluated, **Then** any vulnerability with "OpenSSL" in `vulnerableProductVersions` field is marked as excepted (substring match).
4. **Given** multiple product exceptions exist, **When** a vulnerability matches any exception, **Then** it is marked as excepted (OR logic).
5. **Given** a product exception expires, **When** the system re-evaluates, **Then** all previously excepted vulnerabilities for that product become overdue (if they meet age criteria).

**UI Requirements**:
- Modal form for exception creation
- Product pattern input: text field with example: "OpenSSL 1.0.2" or "Apache 2.4"
- Help text: "This will match any vulnerability containing this text in the product field"
- Date picker for end date (required)
- Text area for reason (required, max 1000 characters)
- List existing product exceptions with: Product Pattern, End Date, Reason, Affected Count, Created By, Actions

**Technical Notes**:
- Reuse `VulnerabilityException.ExceptionType.PRODUCT` (already exists)
- Match logic: `vulnerability.vulnerableProductVersions?.contains(exception.targetValue) == true`
- Consider adding affected vulnerability count to exception list (requires query)

---

### User Story 5 - Manage Exceptions (Edit/Delete) (Priority: P2)

An administrator needs to update existing exceptions (extend end dates, change reasons) or delete exceptions that are no longer needed. This maintains accuracy of the exception system.

**Why this priority**: Important for maintaining the exception system but not blocking for initial functionality. Administrators can work around by deleting and recreating exceptions initially.

**Independent Test**: Can be tested by creating an exception, editing its end date and reason, verifying changes persist, then deleting it and verifying it's removed.

**Acceptance Scenarios**:

1. **Given** an exception exists, **When** an administrator clicks "Edit" on the exception, **Then** a form opens pre-populated with current values.
2. **Given** an administrator edits an exception's end date, **When** they save, **Then** the new end date is applied and all affected vulnerabilities are re-evaluated.
3. **Given** an administrator clicks "Delete" on an exception, **When** they confirm the deletion, **Then** the exception is removed and vulnerabilities are re-evaluated for overdue status.
4. **Given** an administrator tries to edit an exception to have an end date in the past, **When** they submit, **Then** validation fails.
5. **Given** an exception is deleted, **When** viewing the exception history/audit log, **Then** the deletion is recorded with timestamp and user.

**UI Requirements**:
- Edit button opens modal with pre-filled form
- Delete button shows confirmation dialog: "Are you sure? X vulnerabilities will lose exception status."
- Show last updated timestamp and user on exception list
- Optimistic UI updates with rollback on error

**Technical Notes**:
- Add audit logging for exception changes
- Consider soft delete vs hard delete (recommend hard delete for simplicity)
- Update `updatedAt` and `updatedBy` fields on edit

---

### User Story 6 - Exception Reporting and Analytics (Priority: P3)

Administrators and security managers need to view reports on exception usage, including counts of excepted vulnerabilities, most common exception reasons, and exception history trends.

**Why this priority**: Nice-to-have for mature vulnerability management programs. Helps justify exceptions and identify patterns, but not required for core functionality.

**Independent Test**: Can be tested independently by creating various exceptions and viewing aggregate statistics.

**Acceptance Scenarios**:

1. **Given** exceptions exist, **When** an administrator views the exception dashboard, **Then** they see: Total active exceptions, Total vulnerabilities excepted, Top 5 exception reasons.
2. **Given** exceptions have been created and deleted over time, **When** viewing exception history, **Then** administrators see a timeline of exception changes.
3. **Given** an administrator wants to export exception data, **When** they click "Export", **Then** a CSV with all exceptions and their details is downloaded.
4. **Given** multiple assets share an exception, **When** viewing exception details, **Then** administrators see a list of all affected assets and vulnerabilities.

**UI Requirements**:
- Dashboard widget: Exception statistics card
- Exception detail page: show affected assets and vulnerabilities
- Export to CSV functionality
- Charts: Exception trend over time, exception type breakdown

**Technical Notes**:
- Create queries for exception analytics
- Cache exception counts for performance
- Consider adding exception history table for audit trail

---

## Data Model Changes

### New Entity: VulnerabilityConfig

```kotlin
@Entity
@Table(name = "vulnerability_config")
data class VulnerabilityConfig(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    var id: Long? = null,
    
    @Column(name = "reminder_one_days", nullable = false)
    @Min(1) @Max(365)
    var reminderOneDays: Int = 30,
    
    @Column(name = "updated_by", length = 255)
    var updatedBy: String? = null,
    
    @Column(name = "created_at", updatable = false)
    var createdAt: LocalDateTime? = null,
    
    @Column(name = "updated_at")
    var updatedAt: LocalDateTime? = null
)
```

### Extended Entity: VulnerabilityException

Add new exception type:
```kotlin
enum class ExceptionType {
    IP,      // Exception applies to specific IP address (existing)
    PRODUCT, // Exception applies to product name/version pattern (existing)
    ASSET    // Exception applies to specific asset by ID (NEW)
}

// Add field:
@Column(name = "asset_id")
var assetId: Long? = null
```

### New DTOs

```kotlin
data class VulnerabilityOverdueDto(
    val vulnerabilityId: Long,
    val assetId: Long,
    val assetName: String,
    val assetIp: String?,
    val vulnerabilityIdentifier: String?,
    val severity: String?,
    val product: String?,
    val scanTimestamp: LocalDateTime,
    val ageInDays: Long,
    val isOverdue: Boolean,
    val overdueStatus: OverdueStatus, // OVERDUE, EXCEPTED, OK
    val daysOverdue: Int?,
    val exceptionId: Long?,
    val exceptionReason: String?,
    val exceptionEndDate: LocalDateTime?
)

enum class OverdueStatus {
    OK,        // Not overdue
    OVERDUE,   // Overdue and no exception
    EXCEPTED   // Would be overdue but has active exception
}

data class VulnerabilityConfigDto(
    val id: Long?,
    val reminderOneDays: Int,
    val updatedBy: String?,
    val updatedAt: LocalDateTime?
)
```

---

## API Changes

### New Endpoints

```kotlin
// Vulnerability Configuration
GET    /api/admin/vulnerability-config
PUT    /api/admin/vulnerability-config
```

### Enhanced Existing Endpoints

```kotlin
// Add overdueStatus to response
GET    /api/vulnerabilities/current
GET    /api/assets/{id}/vulnerabilities
GET    /api/vulnerabilities/history/{assetId}
GET    /api/account-vulns

// Enhanced exception endpoints
POST   /api/vulnerability-exceptions (add ASSET type support)
PUT    /api/vulnerability-exceptions/{id}
GET    /api/vulnerability-exceptions/{id}/affected-vulnerabilities
```

---

## Frontend Changes

### New Components

1. **VulnerabilityConfigForm** - Admin form for Reminder One configuration
2. **OverdueStatusBadge** - Reusable badge component showing overdue/excepted/ok status
3. **AssetExceptionForm** - Form for creating/editing asset-based exceptions

### Enhanced Components

1. **CurrentVulnerabilitiesTable** - Add overdue status column and filter
2. **AssetVulnTable** - Add overdue status column
3. **AccountVulnsView** - Add overdue status indicators
4. **VulnerabilityExceptionsTable** - Add asset exception type and affected count
5. **AdminPage** - Add link to Vulnerability Settings

### New Pages

1. **/admin/vulnerability-config** - Vulnerability configuration page
2. **/admin/exceptions** - Unified exception management (merge with existing if separate)

---

## Implementation Order (High Usability Focus)

### Phase 1: Foundation (P1 - Core Functionality)
**Goal**: Establish basic overdue tracking and display

1. **Backend**: Create VulnerabilityConfig entity, repository, service
2. **Backend**: Add config API endpoints (GET/PUT)
3. **Backend**: Add overdue calculation logic to VulnerabilityService
4. **Backend**: Update vulnerability DTOs with overdue fields
5. **Frontend**: Create VulnerabilityConfigForm component
6. **Frontend**: Add config management to AdminPage
7. **Frontend**: Create OverdueStatusBadge component
8. **Frontend**: Update CurrentVulnerabilitiesTable with overdue column
9. **Testing**: Unit tests for overdue calculation
10. **Testing**: Integration tests for config management

**Deliverable**: Administrators can configure Reminder One, users see overdue status in vulnerability lists

### Phase 2: Asset Exceptions (P1 - Essential Flexibility)
**Goal**: Enable asset-based exception management

1. **Backend**: Extend VulnerabilityException with ASSET type and assetId field
2. **Backend**: Update exception matching logic to support ASSET type
3. **Backend**: Add migration script for database schema changes
4. **Frontend**: Create AssetExceptionForm component with asset selector
5. **Frontend**: Update VulnerabilityExceptionsTable to show asset exceptions
6. **Frontend**: Add exception creation workflow with type selection
7. **Testing**: Unit tests for asset exception matching
8. **Testing**: E2E tests for asset exception creation and application

**Deliverable**: Administrators can create asset-based exceptions that suppress overdue status

### Phase 3: Product Exceptions Enhancement (P1 - Scale)
**Goal**: Improve product exception usability

1. **Backend**: Add affected vulnerability count query for product exceptions
2. **Backend**: Optimize exception matching queries with indexes
3. **Frontend**: Update VulnerabilityExceptionsTable to show affected count
4. **Frontend**: Add product exception creation with product selector/autocomplete
5. **Frontend**: Add preview of affected vulnerabilities before creating exception
6. **Testing**: Performance tests for exception matching at scale
7. **Testing**: E2E tests for product exception workflows

**Deliverable**: Enhanced product exception management with visibility into impact

### Phase 4: Exception Management (P2 - Maintenance)
**Goal**: Full CRUD operations on exceptions

1. **Backend**: Add audit logging for exception changes
2. **Backend**: Add exception detail endpoint with affected vulnerabilities
3. **Frontend**: Implement edit exception functionality
4. **Frontend**: Add confirmation dialogs with impact preview for delete
5. **Frontend**: Add exception history/audit log view
6. **Testing**: Unit tests for exception lifecycle
7. **Testing**: E2E tests for edit/delete workflows

**Deliverable**: Complete exception management with edit/delete capabilities

### Phase 5: Reporting & Polish (P3 - Advanced)
**Goal**: Analytics and user experience refinements

1. **Backend**: Create exception analytics queries and endpoints
2. **Backend**: Add exception impact reports
3. **Frontend**: Create exception dashboard with statistics
4. **Frontend**: Add filtering and sorting to exception tables
5. **Frontend**: Implement CSV export for exceptions
6. **Frontend**: Add exception detail page with affected items
7. **Testing**: Load tests for analytics queries
8. **Documentation**: User guide for exception management

**Deliverable**: Comprehensive exception analytics and polished UX

---

## Usability Considerations

### Clear Visual Hierarchy
- Use color-coded badges: üî¥ Red (OVERDUE), üõ°Ô∏è Blue (EXCEPTED), ‚úÖ Green (OK)
- Position overdue status prominently in vulnerability tables (2nd or 3rd column)
- Use consistent iconography across all views

### Intuitive Workflows
- Single-click access to exception creation from vulnerability list
- Inline filters: "Show only overdue" checkbox, "Exception status" dropdown
- Smart defaults: Pre-fill asset/product from context when creating exception
- Bulk actions: "Create exception for selected vulnerabilities"

### Contextual Help
- Tooltips explaining: "Reminder One", "Overdue status", "Exception types"
- Example text in forms: "e.g., 192.168.1.100 or select from dropdown"
- Help text for product patterns: "Matches any vulnerability containing this text"
- Preview impact: "This exception will affect 23 vulnerabilities"

### Feedback & Transparency
- Show immediate feedback: "Exception created successfully. 15 vulnerabilities updated."
- Display exception details on hover: "Excepted until 2025-12-31: Planned maintenance window"
- Confirmation dialogs: "Delete exception? 8 vulnerabilities will become overdue."
- Progress indicators for bulk operations

### Performance
- Client-side filtering when possible (small datasets)
- Server-side pagination for large vulnerability lists
- Cache exception evaluations (invalidate on exception changes)
- Lazy load affected vulnerability counts

### Accessibility
- ARIA labels for status badges
- Keyboard navigation for exception forms
- Screen reader friendly status announcements
- High contrast colors for colorblind users

---

## Migration Strategy

### Database Migration
1. Create `vulnerability_config` table
2. Insert default record: `reminderOneDays = 30`
3. Add `asset_id` column to `vulnerability_exception` table (nullable)
4. Add index on `vulnerability.scan_timestamp` for performance

### Data Migration
- No existing data migration needed (new feature)
- Existing IP and PRODUCT exceptions continue to work unchanged

### Rollout Plan
1. **Week 1**: Deploy Phase 1 (config + overdue display) - read-only feature
2. **Week 2**: Deploy Phase 2 (asset exceptions) - enables suppression
3. **Week 3**: Deploy Phase 3 (product enhancement) - improves usability
4. **Week 4**: Deploy Phase 4 (exception management) - completes CRUD
5. **Week 5+**: Phase 5 (reporting) - iterative improvements

---

## Testing Strategy

### Unit Tests
- VulnerabilityConfig CRUD operations
- Overdue calculation logic with various scenarios
- Exception matching logic for all types
- DTO mappings with overdue fields

### Integration Tests
- Config API endpoints
- Exception creation with different types
- Vulnerability queries with overdue status
- Exception expiration handling

### E2E Tests
- Complete exception workflow: create asset exception ‚Üí verify suppression ‚Üí delete ‚Üí verify overdue
- Config update ‚Üí vulnerability list refresh ‚Üí overdue status changes
- Exception expiration simulation (date manipulation)
- Multi-asset exception scenarios

### Performance Tests
- Vulnerability list query with 10,000+ vulnerabilities
- Exception matching with 100+ active exceptions
- Overdue calculation for 1,000+ assets
- Dashboard analytics with full dataset

### Security Tests
- ADMIN role enforcement for config and exception endpoints
- Workgroup isolation for vulnerability visibility
- Input validation for all forms
- SQL injection prevention in exception queries

---

## Success Metrics

### Functional Completeness
- ‚úÖ Administrators can configure Reminder One
- ‚úÖ Overdue status visible in all vulnerability views
- ‚úÖ Asset and product exceptions can be created
- ‚úÖ Exceptions suppress overdue status during validity period
- ‚úÖ Expired exceptions automatically release vulnerabilities
- ‚úÖ Full CRUD operations on exceptions

### Performance
- Vulnerability list loads in < 2 seconds with 1,000 records
- Exception matching adds < 100ms to query time
- Dashboard analytics complete in < 5 seconds

### Usability
- Exception creation takes < 30 seconds (measured from intent to completion)
- < 5% error rate on exception form submissions
- Positive user feedback on overdue visibility
- < 10 support requests per month related to exception logic

### Business Impact
- Reduce false positive overdue alerts by 30%+
- Improve vulnerability remediation prioritization
- Enable flexible SLA management with exceptions
- Support compliance reporting with overdue tracking

---

## Open Questions

1. **Should exceptions support recurring patterns?** (e.g., monthly maintenance windows)
   - Decision: No for MVP, add in Phase 5 if requested
   
2. **Should we notify users when exceptions expire?**
   - Decision: Yes, add email notification in Phase 4
   
3. **Should non-ADMIN users see exception reasons?**
   - Decision: Yes, transparency improves trust and understanding
   
4. **Should we support CIDR ranges in asset exceptions?**
   - Decision: Yes, similar to existing IP exception patterns
   
5. **Maximum exception duration?**
   - Decision: No hard limit, but warn if > 365 days

---

## Dependencies

- Existing VulnerabilityException entity (Features 003, 004)
- Asset and Vulnerability entities
- VulnerabilityService and VulnerabilityExceptionService
- Admin authentication and role checking
- Bootstrap 5.3 for UI components

---

## Related Features

- Feature 003: Vulnerability Management System (base vulnerability tracking)
- Feature 004: VULN Role & Vulnerability Management UI (exception foundation)
- Feature 008: Workgroup-Based Access Control (visibility filtering)
- Feature 013/016: User mapping uploads (similar bulk upload pattern)

---

## Risks & Mitigations

| Risk | Impact | Likelihood | Mitigation |
|------|--------|------------|------------|
| Performance degradation with many exceptions | High | Medium | Add indexes, cache exception evaluations, optimize queries |
| Confusion between exception types | Medium | Medium | Clear UI labels, contextual help, preview affected items |
| Exception abuse (too many exceptions) | Medium | Low | Admin-only access, reporting on exception usage, expiration required |
| Data inconsistency during migration | High | Low | Thorough migration testing, rollback plan, default values |
| Complex exception logic causing bugs | Medium | Medium | Comprehensive unit tests, clear specification, code reviews |

---

## Non-Functional Requirements

### Security
- ADMIN-only access to all exception and config endpoints
- Input validation on all forms (dates, IP addresses, text length)
- SQL injection prevention in exception queries
- Audit logging for all exception changes

### Performance
- Support 10,000+ vulnerabilities with minimal performance impact
- Exception matching adds < 100ms to vulnerability queries
- Real-time overdue status calculation (no batch processing)

### Scalability
- Design supports 100+ simultaneous exceptions
- Database indexes optimize large-scale queries
- Efficient caching strategy for exception evaluations

### Maintainability
- Clear code structure following existing patterns
- Comprehensive documentation for exception logic
- Reusable components (OverdueStatusBadge, etc.)
- Minimal coupling between exception types

### Reliability
- Graceful degradation if exception service fails (show all as overdue)
- Transaction handling for exception CRUD operations
- Rollback capability for failed exception operations

---

## Future Enhancements (Post-MVP)

1. **Exception Templates**: Pre-defined exception patterns for common scenarios
2. **Exception Approval Workflow**: Require approval for exceptions > 90 days
3. **Exception Notifications**: Email alerts when exceptions are about to expire
4. **Bulk Exception Operations**: Apply exception to multiple assets/products at once
5. **Exception Inheritance**: Asset exceptions inherit to child assets in hierarchy
6. **Exception Analytics Dashboard**: Advanced reporting and trending
7. **API for External Systems**: Allow exception creation via REST API
8. **Exception Comments**: Discussion thread on each exception for justification
9. **Recurring Exceptions**: Support for repeating maintenance windows
10. **Exception Categories**: Tag exceptions by type (maintenance, vendor delay, etc.)

---

## Glossary

- **Reminder One**: Configurable threshold (in days) after which vulnerabilities are considered overdue
- **Overdue**: A vulnerability whose age exceeds the Reminder One threshold and has no active exception
- **Exception**: A rule that prevents vulnerabilities from being marked as overdue during a defined period
- **Asset Exception**: Exception applied to all vulnerabilities on a specific asset
- **Product Exception**: Exception applied to all vulnerabilities matching a product/version pattern
- **Exception Period**: Time range during which an exception is active (start to end date)
- **Affected Vulnerabilities**: Count of vulnerabilities currently covered by an exception
- **Exception Status**: Current state of an exception (Active/Expired)
- **Overdue Status**: Calculated status of a vulnerability (OK/OVERDUE/EXCEPTED)
